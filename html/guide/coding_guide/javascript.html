<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SW개발 품질가이드</title>
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/lightbox.css">
    <!-- For Include -->
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <!-- HTML5SHIV -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <![endif]-->
    <script src="../../../js/jquery-3.3.1.min.js"></script>
    <script src="../../../js/common.js"></script>
    <script src="../../../js/lightbox-plus-jquery.js"></script>
    <!-- Code Box Copy begin -->
    <link href="../../../css/code-box-copy.css" rel="stylesheet">
    <script src="../../../js/prism.min.js"></script>
    <script src="../../../js/code-box-copy.js"></script>
    <!-- Code Box Copy end -->
</head>
<body>
<!-- START wrap -->
<div id="wrap">

    <!-- START header -->
    <div id="header">
        <!-- tablet에서만 나타나는 버튼 -->
        <div class="menu-toggle-btn">
            <span class="sr-only">메뉴버튼</span>
        </div>
        <span class="logo">
            <a href="../../../index.html">
                <img src="../../../img/posco-logo.png" alt="withPOSCO 로고">
            </a>
            <span class="logo-text point">swBasic</span><span class="logo-text">SW개발 품질가이드</span>
        </span>

        <!-- site-map -->
        <div class="right-menu site-map">
            <div class="site-map-btn">
                <span class="sr-only">사이트 맵</span>
            </div>

            <div class="site-map-wrapper">
                <div class="site-map-wrapper">
                    <div class="btn close">
                        <span class="sr-only">닫기</span>
                    </div>
                    <ul>
                        <li class="title">INTRO                             <ul class="sub-menu">                                 <li><a href="../../intro/intro/intro.html">Intro</a></li>                             </ul>                         </li>

                        <li class="title">SW개발을 위한 방법론
                            <ul class="sub-menu">
                                <li>swBasic 개발방법론
                                    <ul>
                                        <li><a href="../../methodology/development/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/development/process00.html">프로세스(단계)</a></li>
                                    </ul>
                                </li>
                                <li>swBasic 테스트방법론
                                    <ul>
                                        <li><a href="../../methodology/test/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/test/process01.html">프로세스(단계)</a></li>
                                    </ul>
                                </li>
                                <li>swBasic Agile 방법
                                    <ul>
                                        <li><a href="../../methodology/agile/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/agile/process01.html">프로세스(&프랙티스)</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">개발 가이드
                            <ul class="sub-menu">
                                <li><a href="../../guide/summary/summary01.html">개요</a></li>
                                <li>개발 기법
                                    <ul>
                                        <li><a href="../../guide/technique/summary01.html">요구사항 도출</a></li>
                                        <li><a href="../../guide/technique/summary02.html">요구사항 분석</a></li>
                                        <li><a href="../../guide/technique/summary03.html">요구사항 명세</a></li>
                                        <li><a href="../../guide/technique/summary04.html">요구사항 검증</a></li>
                                        <li><a href="../../guide/technique/architecture_plan.html">아키텍처 설계</a></li>
                                        <li><a href="http://ux.posco.net:7091/html/main.html">UI/UX 표준 가이드</a></li>
                                        <li><a href="../../guide/technique/teststrategy_guide.html">테스트 계획</a></li>
                                        <li><a href="../../guide/technique/testcase_guide00.html">테스트 설계</a></li>
                                        <li><a href="../../guide/technique/unittest.html">테스트 수행</a></li>
                                    </ul>
                                </li>
                                <li>개발 Coding 가이드
                                    <ul>
                                        <li><a href="../../guide/coding_guide/java.html">Coding Style Guide<br/>(convention)</a>
                                        </li>
                                        <li><a href="../../guide/coding_guide/hardcoding_guide.html">HardCoding 적용
                                            Guide</a></li>
                                        <li><a href="../../guide/coding_guide/security_weaknesses.html">Secure Coding
                                            Guide</a></li>
                                        <li><a href="../../guide/coding_guide/open_source.html">오픈소스 개발 가이드</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">개발도구
                            <ul class="sub-menu">
                                <li>개요
                                    <ul>
                                        <li><a href="../../tool/summary/summary01.html">개발 도구란</a></li>
                                    </ul>
                                </li>
                                <li>프로젝트 관리
                                    <ul>
                                        <li><a href="../../tool/all/redmine.html">Redmine</a></li>
                                    </ul>
                                </li>
                                <li>요구사항 관리
                                    <ul>
                                        <li><a href="../../tool/all/osrmt.html">OSRMT</a></li>
                                    </ul>
                                </li>
                                <li>설계/모델링
                                    <ul>
                                        <li><a href="../../tool/all/startuml.html">StarUML</a></li>
                                    </ul>
                                </li>
                                <li>형상관리
                                    <ul>
                                        <li><a href="../../tool/all/git.html">Git</a></li>
                                        <li><a href="../../tool/all/nexus.html">Nexus</a></li>
                                    </ul>
                                </li>
                                <li>빌드
                                    <ul>
                                        <li><a href="../../tool/all/maven.html">Maven</a></li>
                                    </ul>
                                </li>
                                <li>소스진단
                                    <ul>
                                        <li><a href="../../tool/all/sonarqube.html">SonarQube</a></li>
                                    </ul>
                                </li>
                                <li>단위테스트
                                    <ul>
                                        <li><a href="../../tool/all/junit.html">Junit</a></li>
                                    </ul>
                                </li>
                                <li>통합테스트
                                    <ul>
                                        <li><a href="../../tool/all/fitnesse.html">Fitness</a></li>
                                    </ul>
                                </li>
                                <li>부하테스트
                                    <ul>
                                        <li><a href="../../tool/all/jmeter.html">Jmeter</a></li>
                                    </ul>
                                </li>
                                <li>지속통합/배포
                                    <ul>
                                        <li><a href="../../tool/all/jenkins.html">Jenkins</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">품질관리
                            <ul class="sub-menu">

                                <li><a href="../../quality/guide/guide.html">품질관리 가이드</a></li>
                                <li>품질점검
                                    <ul>
                                        <li><a href="../../quality/assurance/testinspection_standard01.html">체크리스트</a>
                                        </li>
                                    </ul>
                                </li>
                                <li>품질지표
                                    <ul>
                                        <li><a href="../../quality/indicator/quality_indicator01.html">프로세스 품질지표</a>
                                        </li>
                                        <li><a href="../../quality/indicator/quality_indicator02.html">프로덕트 품질지표</a>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">다운로드
                            <ul class="sub-menu">
                                <li>SW개발을 위한 방법론
                                    <ul>
                                        <li><a href="../../download/methodology/development_template.html">swBasic
                                            개발방법론</a></li>
                                        <li><a href="../../download/methodology/test_template.html">swBasic 테스트방법론</a>
                                        </li>
                                        <li><a href="../../download/methodology/agile_template.html">swBasic Agile
                                            방법</a></li>
                                    </ul>
                                </li>

                                <li>사내 보유 방법론
                                    <ul>
                                        <li><a href="../../download/company/our_development.html">자체개발방법론</a></li>
                                        <li>
                                            <a href="../../download/company/international_development.html">대외SW개발방법론</a>
                                        </li>
                                        <li><a href="../../download/company/eic_development.html">EIC 전산개발방법론</a></li>
                                        <li><a href="../../download/company/solution_development.html">솔루션개발방법론</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <!-- END header -->

    <!-- START nav -->
    <div id="nav">
        <ul class="menu-list accordion active">
            <!-- Intro -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">Intro</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../intro/intro/intro.html">Intro</a>
            </ul>

            <!-- 방법론 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">SW개발을 위한 방법론</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../methodology/development/summary01.html">swBasic 개발방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/development/summary01.html">개요</a></li>
                        <li><a href="../../methodology/development/process00.html">프로세스(절차)</a>
                            <ul class="sub-inner depth3">
                                <li><a href="../../methodology/development/process00.html">요구정의</a>
                                <li><a href="../../methodology/development/process01.html">분석</a>
                                <li><a href="../../methodology/development/process02.html">아키텍처 설계</a>
                                <li><a href="../../methodology/development/process03.html">설계</a>
                                <li><a href="../../methodology/development/process04.html">구현</a>
                                <li><a href="../../methodology/development/process05.html">테스트</a>
                                <li><a href="../../methodology/development/process06.html">인도</a>
                                <li><a href="../../methodology/development/process06.html">반복주기 관리</a>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="../../methodology/test/summary01.html">swBasic 테스트방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/test/summary01.html">개요</a></li>
                        <li><a href="../../methodology/test/process01.html">프로세스(절차)</a>
                            <ul class="sub-inner depth3">
                                <li><a href="../../methodology/test/process01.html">테스트 계획</a></li>
                                <li><a href="../../methodology/test/process02.html">테스트 설계</a></li>
                                <li><a href="../../methodology/test/process03.html">테스트 실행</a></li>
                                <li><a href="../../methodology/test/process04.html">테스트 평가</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="../../methodology/agile/process01.html">swBasic Agile 방법</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/agile/process01.html">프로세스 (&프랙티스)</a></li>
                        <li><a href="../../methodology/agile/summary02.html">적용가이드</a></li>
                        <li><a href="../../methodology/agile/summary01.html">Agile Manifesto</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 개발 가이드 -->
            <li class="toggle accordion-toggle active-tab">
                <a class="menu-link active" href="javascript:;">개발 가이드</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu open" style="display: block">
                <li><a href="../../guide/summary/summary01.html">개요</a></li>
                <li><a href="../../guide/technique/summary01.html">개발 기법</a>
                    <ul class="sub-inner">
                        <li><a href="../../guide/technique/summary01.html">요구사항 도출</a></li>
                        <li><a href="../../guide/technique/summary02.html">요구사항 분석</a></li>
                        <li><a href="../../guide/technique/summary03.html">요구사항 명세</a></li>
                        <li><a href="../../guide/technique/summary04.html">요구사항 검증</a></li>
                        <li><a href="../../guide/technique/architecture_plan.html">아키텍처 설계</a></li>
                        <li><a href="http://ux.posco.net:7091/html/main.html">UI/UX 표준 가이드</a></li>
                        <li><a href="../../guide/technique/teststrategy_guide.html">테스트 계획</a></li>
                        <li><a href="../../guide/technique/testcase_guide00.html">테스트 설계</a></li>
                        <li><a href="../../guide/technique/unittest.html">테스트 수행</a></li>
                    </ul>
                </li>
                <li><a class="active on" href="../../guide/coding_guide/java.html">개발 Coding 가이드</a>
                    <ul class="sub-inner">
                        <li><a class="active on" href="../../guide/coding_guide/java.html">Coding Style
                            Guide(convention)</a></li>
                        <li><a href="../../guide/coding_guide/hardcoding_guide.html">HardCoding 적용 Guide</a></li>
                        <li><a href="../../guide/coding_guide/security_weaknesses.html">Secure Coding Guide</a></li>
                        <li><a href="../../guide/coding_guide/open_source.html">오픈소스 개발 가이드</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 개발도구 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">개발도구</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../tool/summary/summary01.html">개요</a><li>
                <li><a href="../../tool/all/redmine.html">프로젝트 관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/redmine.html">Redmine</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/osrmt.html">요구사항 관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/osrmt.html">OSRMT</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/startuml.html">설계/모델링</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/startuml.html">StarUML</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/git.html">형상관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/git.html">Git</a></li>
                        <li><a href="../../tool/all/nexus.html">Nexus</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/maven.html">빌드</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/maven.html">Maven</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/sonarqube.html">소스 진단</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/sonarqube.html">SonarQube</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/junit.html">단위테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/junit.html">Junit</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/fitnesse.html">통합테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/fitnesse.html">Fitness</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/jmeter.html">부하테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/jmeter.html">Jmeter</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/jenkins.html">지속통합/배포</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/jenkins.html">Jenkins</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 품질관리 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">품질관리</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">

                <li><a href="../../quality/guide/guide.html">품질관리 가이드</a></li>
                <li><a href="../../quality/assurance/testinspection_standard02.html">품질점검</a>
                    <ul class="sub-inner">
                        <li><a href="../../quality/assurance/testinspection_standard02.html">요구사항 체크리스트</a> </li> <li><a href="../../quality/assurance/testinspection_standard01.html">테스트 체크리스트</a> </li>
                    </ul>
                </li>
                <li><a href="../../quality/indicator/quality_indicator01.html">품질지표</a>
                    <ul class="sub-inner">
                        <li><a href="../../quality/indicator/quality_indicator01.html">프로젝트 품질지표</a></li>
                        <li><a href="../../quality/indicator/quality_indicator02.html">프로덕트 품질지표</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 다운로드 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">다운로드</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../download/methodology/development_template.html">SW개발을 위한 방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../download/methodology/development_template.html">swBasic 개발방법론</a></li>
                        <li><a href="../../download/methodology/test_template.html">swBasic 테스트방법론</a></li>
                        <li><a href="../../download/methodology/agile_template.html">swBasic Agile 방법</a></li>
                    </ul>
                </li>
                <li><a href="../../download/company/our_development.html">사내 보유 방법론</a></li>
            </ul>
        </ul>
    </div>
    <!-- END nav -->

    <!-- START main -->
    <main id="main">
        <header class="page-header-wrap">
            <div class="page-header">
                <h1>Coding Style Guide(convention)</h1>
                <!-- breadcrumb -->
                <ol class="breadcrumb">
                    <li><a href="../../intro/intro/intro.html"><span class="sr-only">Home</span></a></li>
                    <li><a href="../../download/guide/technique.html">개발 가이드</a></li>
                    <li><a href="../../guide/coding_guide/java.html">개발 Coding 가이드</a></li>
                    <li><a href="../../guide/coding_guide/java.html">Coding Style Guide(convention)</a></li>
                    <li class="active">javascript</li>
                </ol>

                <ul class="top-nav-menu">
                    <li><a href="java.html">Java</a></li>
                    <li><a href="jsp.html">JSP</a></li>
                    <li class="active"><a href="javascript.html">JavaScript</a></li>
                    <li><a href="python.html">Python</a></li>
                    <li><a href="c.html">C++</a></li>
                </ul>
            </div>
        </header>

        <!-- START container -->
        <div class="container">
            <div id="accordian" class="links well">
                <dl>
                    <dt>소개</dt>
                    <div class="content">
                        <dd><a href="#title1-1">전문 용어 참고 사항</a></dd>
                        <dd><a href="#title1-2">안내 사항</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>소스 파일 기본 사항</dt>
                    <div class="content">
                        <dd><a href="#title2-1">파일 이름</a></dd>
                        <dd><a href="#title2-2">파일 인코딩 : UTF-8</a></dd>
                        <dd><a href="#title2-3">특수 문자</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>소스 파일 구조</dt>
                    <div class="content">
                        <dd><a href="#title3-1">라이센스 또는 저작권 정보 (있는 경우)</a></dd>
                        <dd><a href="#title3-2">@fileoverview JSDoc (있는 경우)</a></dd>
                        <dd><a href="#title3-3">goog.module 문</a></dd>
                        <dd><a href="#title3-4">goog.require 문</a></dd>
                        <dd><a href="#title3-5">파일의 구현</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>서식 지정</dt>
                    <div class="content">
                        <dd><a href="#title4-1">교정기</a></dd>
                        <dd><a href="#title4-2">블록 들여 쓰기 : +2 공백</a></dd>
                        <dd><a href="#title4-3">진술</a></dd>
                        <dd><a href="#title4-4">칼럼 제한 : 80</a></dd>
                        <dd><a href="#title4-5">줄 바꿈</a></dd>
                        <dd><a href="#title4-6">공백</a></dd>
                        <dd><a href="#title4-7">그룹 괄호 : 권장</a></dd>
                        <dd><a href="#title4-8">코멘트</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>언어 기능</dt>
                    <div class="content">
                        <dd><a href="#title5-1">지역 변수 선언</a></dd>
                        <dd><a href="#title5-2">배열 리터럴</a></dd>
                        <dd><a href="#title5-3">객체 리터럴</a></dd>
                        <dd><a href="#title5-4">클래스</a></dd>
                        <dd><a href="#title5-5">함수</a></dd>
                        <dd><a href="#title5-6">문자열 리터럴</a></dd>
                        <dd><a href="#title5-7">숫자 리터럴</a></dd>
                        <dd><a href="#title5-8">제어 구조</a></dd>
                        <dd><a href="#title5-9">이</a></dd>
                        <dd><a href="#title5-10">허용되지 않는 기능</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>이름 지정</dt>
                    <div class="content">
                        <dd><a href="#title6-1">모든 식별자에 공통적 인 규칙</a></dd>
                        <dd><a href="#title6-2">식별자 유형별 규칙</a></dd>
                        <dd><a href="#title6-3">낙타의 경우 : 정의 됨</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>JSDoc</dt>
                    <div class="content">
                        <dd><a href="#title7-1">일반 서식</a></dd>
                        <dd><a href="#title7-2">Markdown</a></dd>
                        <dd><a href="#title7-3">JSDoc 태그</a></dd>
                        <dd><a href="#title7-4">줄 바꿈</a></dd>
                        <dd><a href="#title7-5">상위 / 파일 수준 주석</a></dd>
                        <dd><a href="#title7-6">수업 코멘트</a></dd>
                        <dd><a href="#title7-7">열거 형 및 typedef 주석</a></dd>
                        <dd><a href="#title7-8">메소드와 함수 주석</a></dd>
                        <dd><a href="#title7-9">부동산 의견</a></dd>
                        <dd><a href="#title7-10">유형 주석</a></dd>
                        <dd><a href="#title7-11">가시성 주석</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>정책</dt>
                    <div class="content">
                        <dd><a href="#title8-1">8.1 Google 스타일에 명시되지 않은 문제 : 일관성을 유지하십시오!</a></dd>
                        <dd><a href="#title8-2">8.2 컴파일러 경고</a></dd>
                        <dd><a href="#title8-3">8.3 사용 중단</a></dd>
                        <dd><a href="#title8-4">8.4 Google 스타일에없는 코드</a></dd>
                        <dd><a href="#title8-5">8.5 지역 스타일 규칙</a></dd>
                        <dd><a href="#title8-6">8.6 생성 된 코드 : 주로 면제 됨</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>부록</dt>
                    <div class="content">
                        <dd><a href="#title9-1">9.1 JSDoc 태그 참조</a></dd>
                        <dd><a href="#title9-2">9.2 일반적으로 오해 된 스타일 규칙</a></dd>
                        <dd><a href="#title9-3">9.3 스타일 관련 도구</a></dd>
                        <dd><a href="#title9-4">9.4 기존 플랫폼의 예외</a></dd>
                    </div>
                </dl>
            </div>

            <h2 id="title1">소개</h2>
            <div class="content">
                <p> 본 문서는 JavaScript 프로그래밍 언어의 소스 코드에 대한 POSCOICT의 코딩 가이드를 정의한 것입니다.</p>
                <p>프로젝트가 점점 복잡해지고 규모가 커지면서 개발자가 혼자 코드를 작성하기 보다는 여러 개발자들이 함께 작업하면서 서로 협업하여 시스템을 만들어 나가는 것이 일반화되었습니다.
                    이러한 상호간의 공동작업이 중요해지면서 자신의 코드뿐만 아니라 타 개발자의 코드도 함께 분석하고 리뷰하여 문제점을 함께 파악하고 공동으로 해결해 나가는 경우가 많아지고 있는
                    추세입니다.</p>
                <p>이러한 개발환경에서 코드 스타일을 통일하는 것은 소스코드의 가독성을 높이고 오류의 가능성을 줄이며 개발의 생산성을 높이는데 중요한 역할을 담당하고 있습니다.</p>
                <p>본 가이드는 Google 스타일 가이드 기반으로 작성이 되어졌으므로 일반적 JavaScript 프로그래밍의 소스 코드 개발에 문제가 없으며 통상적인 JavaScript Coding
                    의 표준을 준수한다라고 볼 수가 있습니다.</p>
                <p>다만, 포스코ICT 의 특정 개발시 필요한 코딩 가이드 부분은 프로젝트별 요구 사항과 환경을 고려하여 별도 표기로 추가 관리할 예정에 있습니다.</p>
                <p>가이드에 기술된 내용은 POSCOICT 각 사업부에서 정보시스템 구현 시 개발자들이 숙독하고 코딩 시 적용할 것을 권고합니다</p>
                <p>개발 프로젝트의 경우에 따라 해당 프로젝트에서 요구되어 지는 별도의 코딩 가이드가 있으면 요구되는 코딩 가이드를 우선 적용하며 본 코딩 가이드는 참조 또는 보완용으로 적용하면
                    됩니다. </p>

                <h3 id="title1-1">1. 전문 용어 참고 사항</h3>
                <div class="content">
                    <p>이 문서에서는 달리 명확히하지 않는 한 :</p>
                    <ol class="ol-styled">
                        <li><p>주석 이라는 용어 는 항상 구현 주석을 나타냅니다 . 인간이 읽을 수있는 텍스트와 기계에서 읽을 수있는 주석 모두에 공통적 인 용어 "JSDoc"을 사용하는
                            대신
                            <q>설명서 주석을</q> 사용하지 않습니다 <code>/** … */</code>.</p></li>
                        <li><p>이 스타일 가이드는 사용 <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a> 문구 사용할 때 용어를 해야이
                            , 해야하지 , 해야이 , 안 , 그리고 수도를 . 조건은 선호 와 회피 에 대응을 해야 하고 해야하지 각각. 명령형 및 선언 형 명령문은 규범 적이며 필수 요소에
                            해당 합니다 .
                        </p></li>
                    </ol>
                    <p>다른 <q>용어 노트</q> 는 문서 전체에서 간혹 나타납니다. </p>
                </div>

                <h3 id="title1-2">2. 안내 사항</h3>
                <div class="content">
                    <p>이 문서의 예제 코드는 비 규범 적 입니다. 즉, 예를 구글 스타일에있는 동안, 그들은 설명 할 수 없습니다 만 코드를 표현하는 세련된 방법. 예제에서의
                        선택적인 형식화 선택은 규칙으로 시행해서는 안됩니다.</p>
                </div>
            </div>

            <h2 id="title2">소스 파일 기본 사항</h2>
            <div class="content">
                <h3 id="title2-1">2.1 파일 이름</h3>
                <div class="content">
                    <p>파일 이름은 모두 소문자 여야하며 밑줄 ( <code>_</code>) 또는 대시 ( <code>-</code>) 가 포함될 수 있지만 추가 구두점 은 포함될
                        수 없습니다. 프로젝트에서 사용하는 규칙을 따릅니다. 파일 이름의 확장자가 있어야합니다 <code>.js</code>.</p>
                </div>
                <h3 id="title2-2">2.2 파일 인코딩 : UTF-8</h3>
                <div class="content">
                    <p>소스 파일은 UTF-8 로 인코딩됩니다 .</p>
                </div>
                <h3 id="title2-3">2.3 특수 문자</h3>
                <div class="content">
                    <h4>2.3.1 공백 문자</h4>
                    <p>줄 종결 자 시퀀스와는 별도로 ASCII 수평 공백 문자 (0x20)는 소스 파일의 아무 곳에 나 나타나는 유일한 공백 문자입니다. 이것은</p>
                    <ol class="ol-styled">
                        <li><p>문자열 리터럴의 다른 모든 공백 문자는 이스케이프 처리됩니다.</p></li>
                        <li><p>탭 문자는 들여 쓰기에 사용 되지 않습니다.</p></li>
                    </ol>
                    <h4>2.3.2 특수 이스케이프 시퀀스</h4>
                    <p>특별한 이스케이프 시퀀스 (이 모든 문자를 들어 <code>\'</code>, <code>\"</code>, <code>\\</code>, <code>\b</code>,
                        <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>), 그 시퀀스 (예 :
                        해당 숫자
                        탈출보다는 사용 <code>\x0a</code>, <code>\u000a</code>또는 <code>\u{a}</code>). 레거시 8 진수 이스케이프는 사용되지
                        않습니다.</p>
                    <h4>2.3.3 비 ASCII 문자</h4>
                    <p>나머지 비 ASCII 문자의 경우 실제 유니 코드 문자 (예 <code>∞</code>:) 또는 동등한 16 진수 또는 유니 코드 이스케이프 (예 :)
                        <code>\u221e</code>가
                        사용되므로 코드 를 읽고 이해하기가 더 쉽습니다.</p>
                    <p class="tip">팁 : 유니 코드 이스케이프의 경우, 때로는 실제 유니 코드 문자가 사용되는 경우에도 설명 주석이 매우 유용 할 수 있습니다.</p>
                    <table class="table table-styled">
                        <thead>
                        <tr>
                            <th>예</th>
                            <th>토론</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td><code class="prettyprint lang-js prettyprinted" style="">const units = 'μs';</code>
                            </td>
                            <td>최고 : 댓글 없이도 완벽하게 명확합니다.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code class="prettyprint lang-js prettyprinted" style="">const units = '\u03bcs'; //
                                    'μs' </code>
                            </td>
                            <td>허용되었지만이를 수행 할 이유가 없습니다.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code class="prettyprint lang-js prettyprinted" style="">const units = '\u03bcs'; //
                                    Greek
                                    letter mu, 's' </code>
                            </td>
                            <td>허용되었지만 어색하고 실수하기 쉽습니다.</td>
                        </tr>
                        <tr>
                            <td><code class="badcode">const units = '\u03bcs';</code>
                            </td>
                            <td>불쌍한 : 독자는 이것이 무엇인지 전혀 모른다.</td>
                        </tr>
                        <tr>
                            <td>
                                <code class="prettyprint lang-js prettyprinted" style="">return '\ufeff' + content; //
                                    byte
                                    order mark </code>
                            </td>
                            <td>
                                Good : 인쇄 할 수없는 문자에 대해서는 이스케이프를 사용하고, 필요한 경우 주석으로 처리하십시오.
                            </td>
                        </tr>
                        </tbody>
                    </table>

                    <p class="tip">팁 : 일부 프로그램이 비 ASCII
                        문자를 제대로 처리하지 못할 수 있다는 두려움에서 코드를 쉽게 읽을 수 없게 만들지 마십시오. 그러한 일이 발생하면
                        해당 프로그램이 고장 났고 수정 해야합니다 .</p>
                </div>
            </div>

            <h2 id="title3">소스 파일 구조</h2>
            <div class="content">
                <p>소스 파일은 다음 순서 로 구성됩니다 .</p>
                <ol class="ol-styled">
                    <li>라이센스 또는 저작권 정보 (있을 경우)</li>
                    <li><code>@fileoverview</code> JSDoc (있는 경우)</li>
                    <li><code>goog.module</code> 성명서</li>
                    <li><code>goog.require</code> 성명</li>
                    <li>파일의 구현</li>
                </ol>

                <p>정확히 하나의 공백 행 은 파일의 구현을 제외하고 존재하는 각 섹션을 구분합니다. 공백은 1 또는 2 개의 공백 행이 선행 될 수 있습니다.</p>

                <h3 id="title3-1">3.1 라이센스 또는 저작권 정보 (있는 경우)</h3>
                <div class="content">
                    <p>라이센스 또는 저작권 정보가 파일에 속하면 여기에 속합니다.</p>
                </div>

                <h3 id="title3-2">3.2 <code>@fileoverview</code>JSDoc (있는 경우)</h3>
                <div class="content">
                    <p>형식 규칙에 대한 <a
                            href="https://google.github.io/styleguide/jsguide.html#jsdoc-top-file-level-comments">7.5 맨
                        위 / 파일
                        수준 주석</a> 을 참조하십시오 .</p>
                </div>

                <h3 id="title3-3">3.3 <code>goog.module</code>진술</h3>
                <div class="content">
                    <p>모든 파일은 <code>goog.module</code>한 줄에 정확히 하나의 이름을 <code>goog.module</code>선언해야합니다 . 선언이 포함 된 줄은 줄
                        바꿈되어서는 안되며 따라서 80 열 제한의 예외입니다.</p>
                    <p>goog.module에 대한 전체 인수는 네임 스페이스를 정의합니다. 이는 패키지 이름 (코드가있는 디렉토리 구조의 단편을 반영하는 식별자)과 선택적으로 끝에 연결되는
                        main class / enum / interface입니다.</p>
                    <p>예</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.module('search.urlHistory.UrlHistoryService');</code></pre>
                    </div>
                    <h4>3.3.1 계층 구조</h4>
                    <p>모듈 네임 스페이스는 결코 다른 모듈의 네임 스페이스의 직접적인 자식 으로 명명 될 수 없습니다 .</p>
                    <p>불법 </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.module('foo.bar');   // 'foo.bar.qux' would be fine, though
goog.module('foo.bar.baz');</code></pre>
                    </div>

                    <p>디렉토리 계층 구조는 네임 스페이스 계층 구조를 반영하므로 더 깊이 중첩 된 하위가 상위 수준의 상위 디렉토리의 하위 디렉토리가됩니다. 이것은 "부모"네임 스페이스 그룹의
                        소유자는 동일한
                        하위 디렉토리에 존재하므로 모든 하위 네임 스페이스를 반드시 인식해야 함을 의미합니다.</p>
                    <h4>3.3.2 <code>goog.setTestOnly</code></h4>
                    <p>단일 <code>goog.module</code>문에 선택적으로 goog.setTestOnly ()를 호출 할 수 있습니다.</p>
                    <h4>3.3.3 <code>goog.module.declareLegacyNamespace</code></h4>
                    <p><code>goog.module</code>선택적으로 하나의 명령문 다음에에 대한 호출이 올 수
                        <code>goog.module.declareLegacyNamespace();</code>있습니다.
                        <code>goog.module.declareLegacyNamespace()</code>가능하면 피하십시오.</p>
                    <p class="example">예: </p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();</code></pre>
                    </div>

                    <p><code>goog.module.declareLegacyNamespace</code>전통적인 객체 계층 구조 기반의 네임 스페이스에서 쉽게 전환 할 수 있지만 명명 규칙이
                        있습니다. 아이
                        모듈 이름이 부모 네임 스페이스 후 작성해야합니다,이 이름은 안 다른의 자식 또는 부모
                        <code>goog.module</code>(예를
                        들어, <code>goog.module('parent');</code>그리고
                        <code>goog.module('parent.child');</code>수는 둘 안전하게 존재도 수
                        <code>goog.module('parent');</code>와 <code>goog.module('parent.child.grandchild');</code>).</p>
                    <h4>3.3.4 ES6 모듈</h4>
                    <p>ES6합니다 (즉, 아직 모듈 사용하지 마십시오 <code>export</code>과 <code>import</code>그들의 의미는 아직 확정되지 않는 한,
                        키워드). 이 정책은 의미가 완전히 표준화되면 다시 검토됩니다.</p>
                </div>
                <h3 id="title3-4">3.4 <code>goog.require</code>진술</h3>
                <div class="content">
                    <p>가져 오기는 <code>goog.require</code>모듈 선언 다음에 그룹화 된 명령문 으로 완료됩니다 . 각각 <code>goog.require</code>은 하나의
                        상수 별칭에
                        할당되거나 다른 상수 별칭으로 파괴됩니다. 이러한 별칭은 <code>require</code>코드 또는 형식 주석에 관계없이 d 종속성 을 참조 할 수있는 유일한 방법
                        <code>goog.require</code>입니다.
                        인수로 사용하는 경우를 제외하고는 정규화 된 이름이 사용되지 않습니다 . 가능한 경우 별칭 이름을 가져온 모듈 이름의 마지막 점으로 구분 된 구성 요소와 일치시켜야 합니다
                        (명확하게
                        별칭의
                        케이스가 해당 유형을 올바르게 식별 할 수 있도록 적절한 대 / 소문자를 사용하여 추가 구성 요소가 포함될 수 있음). 가독성.
                        <code>goog.require</code>
                        문은 파일의 다른 곳에 나타나지 않을 수도 있습니다.</p>

                    <p>모듈을 부작용에 대해서만 가져 오면 할당이 생략 될 수 있지만 정규화 된 이름은 파일의 다른 곳에서는 나타나지 않을 수 있습니다. 이것이 필요한 이유를 설명하고 컴파일러
                        경고를
                        억제하려면 주석이 필요합니다.</p>
                    <p>선은 다음 규칙에 따라 정렬됩니다. 왼쪽에있는 이름이 먼저오고 그 이름으로 알파벳 순으로 정렬됩니다. 그런 다음 왼쪽에있는 이름으로 다시 정렬해야합니다.
                        마지막으로 <code>goog.require</code>독립형 호출 (일반적으로 부작용을 위해 가져온 모듈 용)입니다.</p>
                    <p class="tip">팁 :이 주문을 암기하고 수동으로 시행 할 필요가 없습니다. IDE를 사용하여 정확하게 정렬되지 않은 요구 사항을보고 할 수 있습니다. </p>
                    <p>긴 별칭이나 모듈 이름으로 인해 한 줄이 80 열 제한을 초과하게되면 줄 바꿈을 해서는 안됩니다 . goog.require lines은 80 열 제한의 예외입니다.</p>
                    <p class="example">예 : </p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">const MyClass = goog . require ( 'some.package.MyClass' ); const NsMyClass = goog . require ( 'other.ns.MyClass' ); const googAsserts = goog . require ( 'goog.asserts' ); const testingAsserts = goog . require ( 'goog.testing.asserts' ); const than80columns = goog . require ( 'pretend.this.is.longer.than80columns'



); const { clear , forEach , map } = goog . require ( 'goog.array' ); / ** @suppress {extraRequire} MyFramework를 초기화합니다. * /
goog . require ( 'my.framework.initialization' );
                        </code></pre>
                    </div>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const randomName = goog.require('something.else'); // name must match

const {clear, forEach, map} = // don't break lines
    goog.require('goog.array');

function someFunction() {
  const alias = goog.require('my.long.name.alias'); // must be at top level
  // …
}</code></pre>
                    </div>
                    <h4>3.4.1 <code>goog.forwardDeclare</code></h4>
                    <p><code>goog.forwardDeclare</code>매우 자주 필요하지는 않지만 원형 의존성을 깨거나 늦게로드 된 코드를 참조하는 데 유용한 도구입니다. 이 명령문은
                        함께
                        그룹화되고 모든 <code>goog.require</code>명령문 바로 뒤에 옵니다. <code>goog.forwardDeclare</code>문은 같은 스타일 규칙을
                        따라야합니다
                        <code>goog.require</code>문을.</p>
                </div>
            </div>
            <h3 id="title3-5">3.5 파일의 구현</h3>
            <div class="content">
                <p>실제 구현은 모든 종속성 정보가 선언 된 후에 수행됩니다 (하나 이상의 빈 줄로 구분).</p>
                <p>이것은 모든 모듈 로컬 선언 (상수, 변수, 클래스, 함수 등) 및 내 보낸 기호로 구성 될 수 있습니다.</p>
            </div>
            <h2 id="title4">서식 지정</h2>
            <div class="content">
                <p>용어 참고 : 블록과 유사한 구조 는 클래스, 함수, 메서드 또는 중괄호로 구분 된 코드 블록의 본문을 참조합니다. 하여, 그 주 <a
                        href="https://google.github.io/styleguide/jsguide.html#features-array-literals">5.2 배열 상수</a> 및
                    <a
                            href="https://google.github.io/styleguide/jsguide.html#features-object-literals">5.3 개체
                        리터럴</a> 어떤
                    어레이 또는 그 블록 형 구조체 것처럼 선택적으로 치료 될 수있는 객체 리터럴.</p>

                <p class="tip">팁 : 사용하십시오 <code>clang-format</code>. JavaScript 커뮤니티는 clang 형식 <q>이</q> JavaScript 파일에서
                    올바른지
                    확인하기 위해
                    많은 노력을 기울였습니다 . <code>clang-format</code>여러 유명 편집자와 통합되어 있습니다.
                </p>

                <h3 id="title4-1">4.1 교정기</h3>
                <div class="content">
                    <h4>4.1.1 모든 제어 구조에 중괄호를 사용한다.</h4>
                    <p>교정기는 모든 제어 구조에 필요한 (즉 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>,
                        <code>while</code>,뿐만
                        아니라 다른 사람), 몸이 단 하나의 문이 포함 된 경우에도 마찬가지입니다. 비어 있지 않은 블록의 첫 번째 명령문은 자체 행에서 시작해야합니다.</p>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if ( someVeryLongCondition ())
  doSomething (); for ( let i = 0 ; i < foo . length ; i ++) bar ( foo [ i ]);
                        </code></pre>
                    </div>
                    <p class="exception">예외 : 랩핑없이 한 행에 완전히 맞을 수있는 간단한 if 문은 가독성을 높이기 위해 중괄호없이 한 줄에 유지 될 수 있습니다. 이것은 제어
                        구조가 중괄호와 개행을 생략 할 수있는 유일한 경우입니다.</p>
                    <div class="code-box-copy">
                <pre><code class="language-js">if ( shortCondition ()) return ;
                </code></pre>
                    </div>
                    <h4>4.1.2 비어 있지 않는 구획 : K &amp; R 작풍</h4>
                    <p>중괄호 는 비어 있지 않은 블록과 블록과 같은 구조를 위해 Kernighan and Ritchie 스타일 ( <q><a
                            href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">이집트 괄호</a></q>
                        )을 따릅니다 .
                    </p>
                    <ul class="list-unstyled">
                        <li>여는 중괄호 앞에 줄 바꿈이 없습니다.</li>
                        <li>여는 중괄호 뒤의 줄 바꿈</li>
                        <li>닫는 중괄호 앞에 줄 바꿈을하십시오.</li>
                        <li>해당 중괄호가 함수 또는 클래스 문의 본문이나 본문 또는 클래스 메서드를 종료하는 경우 닫는 중괄호 뒤의 줄 바꿈 구체적 없다 더 가 하였다 경우 브레이스 후
                            개행는 <code>else</code>, <code>catch</code>, <code>while</code>, 또는 콤마, 콜론, 또는 오른쪽 괄호.
                        </li>
                    </ul>
                    <p class="example">예 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
                        </code></pre>
                    </div>
                    <h4>4.1.3 빈 블록 : 간결함</h4>
                    <p>빈 블럭이나 블럭과 같은 구조체 는 블럭 이 여러 개있는 문장 (여러 블럭을 직접 포함하는 문장 이 아니라면<code>{}</code> )
                        사이에 문자, 공백 또는 줄 바꿈이없는 열린 직후에 닫을 수 있습니다 (예 :). : / 또는 / /
                        ).<code>if</code><code>else</code><code>try</code><code>catch</code><code>finally</code>
                    </p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">function doNothing () {}
                        </code></pre>
                    </div>
                    <p class="illegal">불법 :</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">if ( condition ) { // ... } else if ( otherCondition ) {} else { // ... } try { // ... } catch ( e ) {}
                        </code></pre>
                    </div>
                </div>

                <h3 id="title4-2">4.2 블록 들여 쓰기 : +2 공백</h3>
                <div class="content">
                    <p>새로운 블록이나 블록과 같은 구조가 열릴 때마다 들여 쓰기가 두 칸 증가합니다. 블록이 끝나면 들여 쓰기가 이전 들여 쓰기 수준으로 돌아갑니다. 들여 쓰기 수준은 블록
                        전체에서 코드와 주석 모두에 적용됩니다. ( <a
                                href="https://google.github.io/styleguide/jsguide.html#formatting-nonempty-blocks">4.1.2
                            비어 있지
                            않은 블록 : K &amp; R 스타일</a> 의 예 참조 ).</p>
                    <h4>4.2.1 배열 리터럴 : 선택적으로 <q>블록처럼</q></h4>
                    <p>". 블록 형 구조체"그것은 마치 모든 배열 리터럴 임의로 포맷 될 수있다 예를 들어, 다음의 (모든 유효 하지 전체 목록)</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const a = [ 0 , 1 , 2 , ]; const b = [ 0 , 1 , 2 ]; </code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const c = [ 0 , 1 , 2 ];
someMethod ( foo , [ 0 , 1 , 2 , ], bar );

                        </code></pre>
                    </div>
                    <p>특히 요소 간의 의미 그룹을 강조 할 때 다른 조합이 허용되지만 큰 배열의 수직 크기를 줄이기 위해서만 사용하면 안됩니다.</p>
                    <h4>4.2.2 객체 리터럴 : 선택적으로 <q>블록처럼</q></h4>
                    <p>모든 객체 리터럴은 "블록 유사 구조"처럼 선택적으로 형식화 될 수 있습니다. 동일한 예는 <a
                            href="https://google.github.io/styleguide/jsguide.html#formatting-array-literals">4.2.1 배열
                        리터럴
                        (선택적으로 블록과 유사)에</a> 적용됩니다 . 예를 들어, 다음 (모든 유효 하지 완전한 목록) :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const a = {
  a : 0 ,
                            b : 1 , }; const b = { a : 0 , b : 1 };   </code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const c = { a : 0 , b : 1 };
someMethod ( foo , {
  a : 0 , b : 1 , }, bar );
                        </code></pre>
                    </div>
                    <h4>4.2.3 클래스 리터럴</h4>
                    <p>클래스 리터럴 (선언 또는 표현식)은 블록으로 들여 쓰여집니다. 메소드 다음에 세미콜론을 추가하지 마십시오. 클래스 선언 의 닫는 중괄호 (클래스 표현식 을 포함하는 명령문
                        -
                        세미콜론으로
                        끝나야 함)이 추가되지 마십시오. 클래스가 템플릿 화 된 유형을 확장하지 않는 한 <code>extends</code>키워드는 사용 하지만
                        <code>@extends</code>JSDoc
                        어노테이션은 사용하지 마십시오.</p>
                    <p class="example">예 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>
                    </div>
                    <h4>4.2.4 함수 표현식</h4>
                    <p>함수 호출에 대한 인수 목록에서 익명 함수를 선언 할 때 함수 본문은 앞의 들여 쓰기 깊이보다 두 칸 더 들여 쓰여집니다.</p>
                    <p class="example">예:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">prefix.something.reallyLongFunctionName('whatever', (a1, a2) => {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) => {
      // Indent the function body +2 relative to the indentation depth
      // of the '.then()' call.
      if (result) {
        result.use();
      }
    });</code></pre>
                    </div>
                    <h4>4.2.5 스위치 문</h4>
                    <p>다른 블록과 마찬가지로 스위치 블록의 내용은 +2로 들여쓰기됩니다.</p>
                    <p>스위치 레이블 다음에 개행 문자가 나타나고 블록이 열리는 것처럼 들여 쓰기 레벨이 +2 증가합니다. 렉시 컬 스코핑 (lexical scoping)에 의해 요구되는 경우 명시
                        적
                        블록이 사용될 수 있습니다. 다음 스위치 레이블은 블록이 닫힌 것처럼 이전 들여 쓰기 수준으로 돌아갑니다.
                    </p>
                    <p>빈 줄은 a <code>break</code>와 다음 경우 사이에서 선택적 입니다.</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}</code></pre>
                    </div>
                </div>

                <h3 id="title4-3">4.3 진술</h3>
                <div class="content">
                    <h4>4.3.1 한 줄에 하나의 문장</h4>
                    <p>각 문 다음에 줄 바꿈이옵니다.</p>
                    <h4>4.3.2 세미콜론 필요</h4>
                    <p>모든 명령문은 세미콜론으로 끝나야합니다. 자동 세미콜론 삽입에 의존하는 것은 금지되어 있습니다.</p>
                </div>

                <h3 id="title4-4">4.4 칼럼 제한 : 80</h3>
                <div class="content">
                    <p>자바 스크립트 코드의 글자 수 제한은 80 자입니다. 아래에 명시된 경우를 제외하고,이 제한을 초과하는 모든 행은 <a
                            href="https://google.github.io/styleguide/jsguide.html#formatting-line-wrapping">4.5 줄
                        바꿈</a> 에서
                        설명한대로 줄 바꿈되어야합니다.</p>

                    <p class="exceptions">예외 :</p>
                    <ol class="ol-styled">
                        <li>열 한도를 준수하는 행은 불가능합니다 (예 : JSDoc의 긴 URL 또는 복사하여 붙여 넣을 예정인 셸 명령).</li>
                        <li><code>goog.module</code>및 <code>goog.require</code>명령문 ( <a
                                href="https://google.github.io/styleguide/jsguide.html#file-goog-module">3.3 goog.module
                            문</a> 및
                            <a href="https://google.github.io/styleguide/jsguide.html#file-goog-require">3.4
                                goog.require 문
                                참조</a> ).
                        </li>
                    </ol>
                </div>

                <h3 id="title4-5">4.5 줄 바꿈</h3>
                <div class="content">
                    <p>용어 참고 : 행 줄 바꿈 은 단일 표현식을 여러 행으로 나누는 것으로 정의됩니다.</p>
                    <p>모든 상황에서 정확히 줄 바꿈하는 방법을 정확하게 보여주는 포괄적이고 결정적인 공식은 없습니다 . 매우 자주 동일한 코드를 줄 바꿈하는 여러 가지 유효한 방법이
                        있습니다.</p>
                    <p class="note">참고 : 줄 바꿈의 일반적인 이유는 열 제한이 오버플로되는 것을 방지하기위한 것이지만 실제로 열 제한 내에 들어가는 코드조차도 작성자의 재량에 따라 줄
                        바꿈 될 수 있습니다.</p>
                    <p class="tip">팁 : 메서드 또는 로컬 변수를 추출하면 줄 바꿈없이 문제를 해결할 수 있습니다.</p>
                    <h4>4.5.1 중단 할 위치</h4>
                    <p>줄 바꿈의 주요한 지시문은 다음과 같습니다. 더 높은 통사론 수준 에서 깨는 것을 선호 합니다 .</p>
                    <p class="preferred">기본 설정 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">currentEstimate =
    calc ( currentEstimate + x * currentEstimate ) / 2.0f ;
                        </code></pre>
                    </div>
                    <p class="discouraged">실망한 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">currentEstimate = calc ( currentEstimate + x *
    currentEstimate ) / 2.0f ;
                        </code></pre>
                    </div>
                    <p>앞의 예에서 가장 높은 것부터 가장 낮은 것까지 구문 수준은 할당, 나누기, 함수 호출, 매개 변수, 숫자 상수와 같습니다.</p>
                    <p>연산자는 다음과 같이 래핑됩니다. </p>
                    <ol class="ol-styled">
                        <li>연산자가 줄을 끊으면 기호 뒤에 기호가옵니다. (이것은 Java 용 Google 스타일에서 사용 된 것과 동일하지 않습니다.)
                            <ol>
                                <li>이것은 실제로 연산자가 아닌 <q>dot</q> ( <code>.</code>) 에는 적용되지 않습니다.</li>
                            </ol>
                        </li>
                        <li>메서드 또는 생성자 이름은 뒤에 오는 여는 괄호 (<code>(</code>)에 첨부 된 상태로 유지 됩니다.</li>
                        <li>쉼표 (<code>,</code>)는 앞에 오는 토큰에 연결되어 있습니다.</li>
                    </ol>
                    <blockquote>
                        <p class="note">참고 : 행 줄 바꿈의 기본 목표는 명확한 코드를 갖는 것입니다. 가장 작은 수의 행에 들어갈 필요는 없습니다.</p>
                    </blockquote>
                    <h4>4.5.2 연속 선을 적어도 +4 공백으로 들여 씁니다.</h4>
                    <p>행 줄 바꿈의 경우 첫 번째 행 (각 연속 행 ) 이후의 각 행 은 블록 들여 쓰기 규 "에 해당하지 않는 한 원래 행에서 적어도 +4만큼 들여 쓰기됩니다.</p>
                    <p>연속 선이 여러 개인 경우 들여 쓰기가 +4 이상으로 적절하게 변경 될 수 있습니다. 일반적으로 더 깊은 통어론 수준의 연속 줄은 4의 큰 배수로 들여 쓰여지고 두 줄은 구문
                        상
                        병렬 요소로 시작하는 경우에만 동일한 들여 쓰기 수준을 사용합니다.</p>
                    <p><a href="https://google.github.io/styleguide/jsguide.html#formatting-horizontal-alignment">4.6.3
                        Horizontal alignment (수평 정렬) :</a> 다양한 토큰을 이전 선과 정렬하기 위해 다양한 수의 공백을 사용하는 것은 권장하지 않습니다.</p>
                </div>

                <h3 id="title4-6">4.6 공백</h3>
                <div class="content">
                    <h4>4.6.1 세로 공백</h4>
                    <p>하나의 빈 줄이 나타납니다.</p>
                    <ol class="ol-styled">
                        <li>클래스 또는 객체 리터럴의 연속 된 메소드 사이
                            <ol>
                                <li>예외 : 오브젝트 리터럴 (두 코드 사이에 다른 코드 없음)에있는 두 개의 연속적인 속성 정의 사이의 빈 줄은 선택 사항입니다. 이러한 공백 라인은
                                    필요에
                                    따라
                                    필드의 논리적 그룹 을 만드는 데 사용됩니다 .
                                </li>
                            </ol>
                        </li>
                        <li>메소드 본문 내에서 논리적 으로 명령문을 그룹화하십시오. 함수 본문의 시작 또는 끝에있는 공백은 허용되지 않습니다.</li>
                        <li>클래스 또는 객체 리터럴의 마지막 메소드 앞이나 뒤에 ( 선택 또는 권장하지 않음) 선택적으로.</li>
                        <li>이 문서의 다른 절 (예 : <a
                                href="https://google.github.io/styleguide/jsguide.html#file-goog-require">3.4
                            goog.require 문</a> )에서 요구하는대로
                        </li>
                    </ol>
                    <p>여러 개의 연속적인 공백 행은 허용되지만 절대 필요하지는 않습니다 (권장하지 않음).</p>
                    <h4>4.6.2 가로 공백</h4>
                    <p>가로 공백 사용은 위치에 따라 다르며 행간 (행의 시작 부분), 끝 부분 (행 끝 부분) 및 내부 영역의 세 가지 범주로 나뉩니다 . 선행 공백 (들여 쓰기)은 다른 곳에서
                        처리됩니다. 후행 공백은 금지됩니다.</p>
                    <p>언어 나 기타 스타일 규칙이 필요한 곳을 넘어서서 리터럴, 주석 및 JSDoc을 제외하고는 하나의 내부 ASCII 공간이 다음 장소 에만 나타납니다 .</p>
                    <ol class="ol-styled">
                        <li>어떤 예약어 (같은 분리 <code>if</code>, <code>for</code>또는 <code>catch</code>열린 괄호 ()에서
                            <code>(</code>그
                            행에서
                            다음).
                        </li>
                        <li>예약어 (예 : <code>else</code>or <code>catch</code>)는 <code>}</code>해당 줄 앞에 오는 중괄호 ( ) 와 분리하십시오.
                        </li>
                        <li><code>{</code>두 가지 예외가 있는 열린 중괄호 ( ) 전에 :
                            <ol class="ol-styled">
                                <li>함수의 첫 번째 인수 인 객체 리터럴 또는 배열 리터럴의 첫 번째 요소 앞에 (예 :) <code>foo({a: [{c: d}]})</code>.
                                </li>
                                <li>템플릿 확장에서는 언어에 의해 금지됩니다 (예 :) <code>abc${1 + 2}def</code>.</li>
                            </ol>
                        </li>
                        <li>임의의 2 항 또는 3 항 연산자의 양쪽 모두.</li>
                        <li>쉼표 ( <code>,</code>) 또는 세미콜론 ( <code>;</code>) 뒤에 . 이 문자 앞에는 공백을 사용할 수 없습니다.</li>
                        <li><code>:</code>객체 리터럴에서 콜론 ( ) 뒤에.</li>
                        <li><code>//</code>줄 끝 주석을 시작하는 이중 슬래시 ( ) 의 양면에 . 여기에는 여러 개의 공백이 허용되지만 필수는 아닙니다.</li>
                        <li>열린 JSDoc 주석 문자와 가까운 문자 양쪽에 (예 : 짧은 형식의 선언 또는 캐스트 : <code>this.foo = /** @type {number} */
                            (bar);</code>또는 <code>function(/** string */ foo) {</code>).
                        </li>
                    </ol>
                    <h4>4.6.3 가로 정렬 : 낙심</h4>
                    <p>용어 참고 : 가로 맞춤 은 이전 줄의 특정 토큰 아래에 특정 토큰을 직접 표시하려는 목적으로 코드에 가변 개수의 추가 공백을 추가하는 연습입니다.</p>
                    <p>이러한 관행은 허용되지만 일반적으로 Google 스타일에서는 권장하지 않습니다 . 이미 사용 된 위치에서 수평 정렬 을 유지할 필요가 없습니다 .</p>
                    <p>다음은 정렬이없는 예제입니다. 둘 다 허용되지만 후자는 권장하지 않습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};</code></pre>
                    </div>
                    <p class="tip">팁 : 정렬은 가독성을 높일 수 있지만 향후 유지 관리에 문제가됩니다. 한 줄을 만져야하는 미래의 변화를 고려하십시오. 이 변경으로 인해 이전에
                        기쁘게하는
                        서식이
                        엉망으로 남을 수 있으며 이는 허용됩니다. 더 자주 그것은 코더 (아마도 당신)에게 주변 선상의 공백을 조정할 것을 촉구합니다. 아마도 계단식 재 포맷을 유발할 수
                        있습니다. 그 한 줄의 변화는 이제 <q>폭발적인 반경을 가지고 있습니다. </q>이것은 최악의 경우 혼잡을 일으킬 수 있지만 결과적으로 여전히 버전 기록 정보가 손상되고
                        검토자가
                        느려지고 충돌을 악화시킵니다.</p>

                    <h4>4.6.4 함수 인자</h4>
                    <p>모든 함수 인수를 함수 이름과 같은 행에 두는 것을 선호합니다. 이렇게하면 80 열 한도를 초과 할 것이므로 인수는 읽을 수있는 방식으로 줄 바꿈되어야합니다. 공간을 절약하기
                        위해
                        가능한
                        한 80에 가까운 값으로 줄이거 나 가독성을 높이기 위해 각 인수를 자체 줄에 넣을 수 있습니다. 들여 쓰기는 네 칸 여야합니다. 괄호에 맞추는 것은 허용되지만 권장하지
                        않습니다.
                        다음은
                        인수 랩핑의 가장 일반적인 패턴입니다.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">// Arguments start on a new line, indented four spaces. Preferred when the
// arguments don't fit on the same line with the function name (or the keyword
// "function") but fit entirely on the second line. Works with very long
// function names, survives renaming without reindenting, low on space.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // …
}

// If the argument list is longer, wrap at 80. Uses less vertical space,
// but violates the rectangle rule and is thus not recommended.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // …
}

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // …
}
</code></pre>
                    </div>
                </div>

                <h3 id="title4-7">4.7 그룹 괄호 : 권장</h3>
                <div class="content">
                    <p>선택적 그룹 괄호는 작성자와 검토자가 코드가 잘못 해석 될 가능성이 없으며 코드를 더 읽기 쉽게 만들지 않을 것이라는 점에 동의 할 때만 생략됩니다. 이다 없는
                        모든 독자가 기억 전체 연산자 우선 순위 테이블이 있다고 가정하는 것이 합리적.</p>
                    <p>다음 전체 표현식 주위에 불필요한 괄호를 사용하지 마십시오 <code>delete</code>, <code>typeof</code>, <code>void</code>,
                        <code>return</code>,
                        <code>throw</code>, <code>case</code>, <code>in</code>, <code>of</code>, 또는 <code>yield</code>.
                    </p>
                    <p>형식 괄호에는 괄호가 필요합니다 <code>/** @type {!Foo} */ (foo)</code>.</p>
                </div>

                <h3 id="title4-8">4.8 코멘트</h3>
                <div class="content">
                    <p>이 섹션에서는 구현 주석을 다룹니다 . JSDoc은 <a
                            href="https://google.github.io/styleguide/jsguide.html#jsdoc">7
                        JSDoc</a>
                        에서 별도로 다루어 <a href="https://google.github.io/styleguide/jsguide.html#jsdoc">진다</a> .</p>

                    <h4>4.8.1 블록 주석 스타일</h4>
                    <p>블록 코멘트는 주변 코드와 같은 레벨로 들여 쓰기됩니다. 그들은 <code>/* … */</code>또는 <code>//</code>스타일 일 수 있습니다 . 여러 줄
                        <code>/*
                            …
                            */</code>주석의 경우 후속 줄은 <code>*</code>주석없이 * 추가 ​​문맥없이 명백하게하기 위해 *로 시작해야합니다 . 값과 메소드 이름이
                        의미를 충분히 전달하지
                        못할
                        때마다 "매개 변수 이름"주석이 값 뒤에 표시되어야합니다.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
                        </code></pre>
                    </div>
                    <p>주석은 별표 또는 기타 문자로 그려진 상자에 포함되지 않습니다.</p>
                    <p><code>/** … */</code>위의 구현 주석에 대해 JSDoc ( )을 사용하지 마십시오 .</p>
                </div>
            </div>

            <h2 id="title5">언어 기능</h2>
            <div class="content">
                <p>자바 스크립트에는 많은 모호한 (심지어 위험한) 기능이 포함되어 있습니다. 이 섹션에서는 어떤 기능을 사용할지 여부와 사용상의 추가 제약 조건을 설명합니다. </p>

                <h3 id="title5-1">5.1 지역 변수 선언</h3>
                <div class="content">
                    <h4>5.1.1 사용 <code>const</code>및<code>let</code></h4>
                    <p><code>const</code>또는로 모든 로컬 변수를 선언하십시오 <code>let</code>. 변수를 재 할당해야하는 경우가 아니면 const를 사용하십시오.
                        <code
                                class="badcode">var</code> 키워드는 사용할 수 없습니다.</p>
                    <h4>5.1.2 선언 당 하나의 변수</h4>
                    <p>모든 지역 변수 선언은 하나의 변수 만 선언합니다. 선언 <code class="badcode">let a = 1, b = 2;</code>은 사용되지 않는 것과
                        같습니다.
                    </p>
                    <h4>5.1.3 필요할 때 선언하고, 가능한 한 빨리 초기화한다.</h4>
                    <p>지역 변수는 포함하는 블록이나 블록과 같은 구조의 시작에서 습관적으로 선언 되지 않습니다. 대신 로컬 변수는 범위를 최소화하기 위해 처음 사용 된 시점(이유 내에서)
                        가까이에 선언됩니다.</p>
                    <h4>5.1.4 필요에 따라 타입 선언</h4>
                    <p>JSDoc 유형 주석은 선언 위의 행에 추가하거나 변수 이름 앞에 인라인으로 추가 할 수 있습니다.</p>
                    <p class="example">예 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const /** !Array&lt;number&gt; */ data = [];

/** @type {!Array&lt;number&gt;} */
const data = [];
                        </code></pre>
                    </div>
                    <p class="tip">팁 : 컴파일러가 템플릿 화 된 유형을 유추 할 수는 있지만 매개 변수는 유추하지 않는 경우가 많습니다. 이는 리터럴 또는 생성자 호출을 초기화
                        할 때 템플릿 매개 변수 유형의 값 (예 : 빈 배열, 객체, <code>Map</code>s 또는 <code>Set</code>s)이 없거나 변수가 클로저에서 수정
                        된 경우에
                        특히 그렇습니다. 지역 변수 유형 주석은 컴파일러가 템플릿 매개 변수를 알 수없는 것으로 유추 할 것이므로 이러한 경우 특히 유용합니다.</p>
                </div>

                <h3 id="title5-2">5.2 배열 리터럴</h3>
                <div class="content">
                    <h4>5.2.1 후행 쉼표 사용</h4>
                    <p>마지막 요소와 닫는 대괄호 사이에 줄 바꿈이있을 때마다 후행 쉼표를 포함하십시오.</p>
                    <p class="example">예 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const values = [
  'first value',
  'second value',
];
                        </code></pre>
                    </div>
                    <h4>5.2.2 가변 <code>Array</code>생성자를 사용하지 말라.</h4>
                    <p>인수가 추가되거나 제거되면 생성자는 오류가 발생하기 쉽습니다. 대신 리터럴을 사용하십시오.</p>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
                        </code></pre>
                    </div>
                    <p>세 번째 경우를 제외하고는 예상대로 작동합니다. if <code>x1</code>는 정수 이고 모든 요소가있는 <code>a3</code>크기의
                        배열입니다 . 경우 다른 번호는 다음 예외가 발생되고, 그것이 다른 어떤 경우 그것은 단일 요소 배열 될
                        것입니다.<code>x1</code><code>undefined</code><code>x1</code></p>
                    <p>대신,</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
                        </code></pre>
                    </div>
                    <p><code>new Array(length)</code>적절할 때 주어진 길이의 배열을 명시 적으로 할당하는 것이 허용됩니다.</p>
                    <h4>5.2.3 숫자가 아닌 속성</h4>
                    <p>배열에서 (이외의 <code>length</code>) 숫자가 아닌 속성을 정의하거나 사용하지 마십시오. 용도 <code>Map</code>(또는
                        <code>Object</code>) 대신.</p>
                    <h4>5.2.4 Destructuring</h4>
                    <p>배열 리터럴은 할당의 왼쪽에서 단일 배열이나 반복 가능 연산자에서 여러 값을 언팩하는 경우와 같이 구조화를 수행하는 데 사용될 수 있습니다.
                        최종 <q>나머지</q> 요소가 포함될 수 있습니다 ( <code>...</code>변수 이름과 사이에 공백이 없어야 함 ). 요소는 사용하지
                        않을 경우 생략해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;

                        </code></pre>
                    </div>
                    <p>소멸은 함수 매개 변수에도 사용될 수 있습니다 (매개 변수 이름은 필요하지만 무시됩니다).
                        <code>[]</code>destructured 배열 매개 변수가 선택 사항 인 경우 항상 기본값으로 지정 하고 왼쪽에 기본값을
                        제공하십시오.
                    </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { … };</code></pre>
                    </div>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">function badDestructuring([a, b] = [4, 2]) { … };</code></pre>
                    </div>
                    <p class="tip">팁 : 함수의 매개 변수 나 반환 값에 여러 값을 채우려면 가능한 경우 배열 소멸에 대한 객체 소멸을
                        선호하십시오. 개별 요소의 이름을 지정하고 각기 다른 유형을 지정할 수 있습니다. *</p>
                    <h4>5.2.5 스프레드 연산자</h4>
                    <p>배열 리터럴에는 확산 연산자 ( <code>...</code>) 가 포함되어 하나 이상의 다른 반복 가능 요소에서 요소를 병합 할 수 있습니다. 확산 연산자는보다 어색한 구문
                        대신 사용되어야합니다 <code>Array.prototype</code>. 뒤에 공백이 없습니다<code>...</code>.</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">[...foo]   // preferred over Array.prototype.slice.call(foo)
[...foo, ...bar]   // preferred over foo.concat(bar)</code></pre>
                    </div>
                </div>

                <h3 id="title5-3">5.3 객체 리터럴</h3>
                <div class="content">
                    <h4>5.3.1 후행 쉼표 사용</h4>
                    <p>최종 속성과 닫는 중괄호 사이에 줄 바꿈이있을 때마다 후행 쉼표를 포함시킵니다.</p>
                    <h4>5.3.2 <code>Object</code>생성자를 사용하지 않는다.</h4>
                    <p>반면 <code>Object</code>에 같은 문제 <code>Array</code>는 없지만 여전히 일관성을 이유로 허용되지 않습니다. 대신 개체 리터럴 ( <code>{}</code>또는
                        <code>{a: 0, b: 1, c: 2}</code>)을 사용하십시오.</p>
                    <h4>5.3.3 따옴표 붙은 키와 인용되지 않은 키를 섞지 마십시오.</h4>
                    <p>객체 리터럴은 구조체 (따옴표없는 키 및 / 또는 기호) 또는 dicts (인용 및 / 또는 계산 된 키 포함)를 나타낼 수 있습니다. 이러한 키 유형을 단일 객체 리터럴에
                        혼합하지 마십시오.</p>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">{
  a: 42, // struct-style unquoted key
  'b': 43, // dict-style quoted key
}
                        </code></pre>
                    </div>
                    <h4>5.3.4 계산 된 속성 이름</h4>
                    <p><code>{['key' + foo()]: 42}</code>계산 속성이 기호 (예 :)가 아니면 계산 된 속성 이름 (예 :) 은 허용되고 dict 스타일 (따옴표) 키로
                        간주됩니다 (즉, 인용 부호가없는 키와 섞어서는 안 됨<code>[Symbol.iterator]</code>). Enum 값은 계산 된 키에도 사용될 수 있지만 같은
                        리터럴의 비 enum 키와 섞어서는 안됩니다.</p>
                    <h4>5.3.5 방법 단축</h4>
                    <p>메소드는 <code>{method() {… }}</code>콜론 대신에 shorthand ( ) 메소드를 사용하여 오브젝트 리터럴에 정의 할 수 있습니다. 바로 뒤에 a
                        <code>function</code>또는 arrow 함수 리터럴이옵니다.</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
       </code></pre>
                    </div>
                    <p>그 주 <code>this</code>방법 속기 또는 <code>function</code>반면 대물
                        문자 자체를 의미 <code>this</code>화살표 함수 리터럴 객체 외부 범위를
                        의미한다.</p>
                    <p class="example">예 : </p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () => this.stuff,  // Returns 'fruit'
    };
  }
}

     </code></pre>
                    </div>
                    <h4>5.3.6 속기 속성</h4>
                    <p>속기 속성은 객체 리터럴에서 허용됩니다.</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method()); </code></pre>
                    </div>
                    <h4>5.3.7 Destructuring</h4>
                    <p>객체 구조 패턴은 할당의 왼쪽에서 단일 객체에서 여러 값을 파기하고 구조화를 수행하는 데
                        사용될 수 있습니다.</p>
                    <p>Destructuring 된 객체는 함수 매개 변수로 사용될 수도 있지만 가능한 한 단순하게 유지해야합니다.
                        따옴표로 묶지 않은 속기 속성입니다. 중첩 수준과 계산 속성은 매개 변수 소멸에
                        사용되지 않을 수
                        있습니다. 소멸 된 매개 변수의 왼쪽에 기본값을 지정하고 ( <code>{str =
                            'some default'} = {}</code>이 아니라 <code
                                class="badcode">{str}
                            = {str: 'some default'}</code>), 소멸 된 개체 자체는
                        선택 사항 인 경우 기본값으로 지정해야합니다 <code>{}</code>.
                        destructured
                        매개 변수의 JSDoc에는 이름이 지정 될 수 있습니다 (이름은 사용되지 않지만
                        컴파일러에서 필요합니다).</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {})

    </code></pre>
                    </div>
                    <p class="illegal">불법 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};

     </code></pre>
                    </div>
                    <p>Destructuring은 <code>goog.require</code>명령문 에도 사용될 수 있으며 ,이 경우 랩핑해서는 안됩니다. 전체 명령문은 길이에 관계없이 한 행을
                        차지합니다 ( <a href="https://google.github.io/styleguide/jsguide.html#file-goog-require">3.4
                            goog.require 문</a> 참조 ).</p>

                    <h4>5.3.8 열거 형</h4>
                    <p>열거 형은 <code>@enum</code>주석을 객체 리터럴 에 추가하여 정의됩니다 . 추가 속성은 정의 된 후에 열거 형에 추가되지 않을 수 있습니다. 열거 형은 상수
                        여야하며 모든 열거 형 값은 매우 불변이어야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Supported temperature scales.
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * An enum with two options.
 * @enum {number}
 */
const Option = {
  /** The option used shall have been the first. */
  FIRST_OPTION: 1,
  /** The second among two options. */
  SECOND_OPTION: 2,
};
   </code></pre>
                    </div>
                </div>

                <h3 id="title5-4">5.4 클래스</h3>
                <div class="content">
                    <h4>5.4.1 생성자</h4>
                    <p>생성자는 구체적인 클래스에서 선택 사항입니다. 서브 클래스 생성자는<code>super()</code>필드를 설정하거나 액세스하기 전에
                        호출해야합니다<code>this</code>. 인터페이스는 생성자를 정의하지 않아야합니다.</p>

                    <h4>5.4.2 필드</h4>
                    <p>생성자의 모든 구체적인 객체의 필드 (즉, 메소드 이외의 모든 속성)를 설정합니다. 재 할당되지 않은 필드에 주석을 달아라<code>@const</code>. 비공개 필드에는
                        주석을 달고<code>@private</code>그 이름은 뒷부분의 밑줄로 끝나야합니다. 필드는 결코 구체적인 클래스에 설정되지
                        않습니다<code>prototype</code>. '</p>
                    <p class="example">예: </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();
  }
}
   </code></pre>
                        <p class="tip">팁 : VM의 최적화 기능을 크게 방해하기 때문에 생성자가 완료된 후 속성을 인스턴스에 추가하거나 인스턴스에서 제거하면 안됩니다.<code>undefined</code>나중에
                            모양이 변경되지 않도록 나중에 초기화 된 필드를 생성자에 명시 적으로 설정해야합니다 .<code>@struct</code>객체에 추가하면 선언되지 않은 속성이 추가
                            / 액세스되지 않았는지 확인됩니다. 클래스에는 기본적으로이 클래스가 추가되었습니다.</p>
                        <h4>5.4.3 계산 된 속성</h4>
                        <p>계산 된 속성은 속성이 심볼 일 때만 클래스에서 사용할 수 있습니다. Dict 스타일 속성 (즉, <a
                                href="https://google.github.io/styleguide/jsguide.html#features-objects-mixing-keys">5.3.3
                            따옴표 붙은 키와 인용되지 않은 키를 함께 사용하지 않음)에</a>정의 된대로 따옴표가 있거나 계산 된 비 기호 키 는 사용할 수 없습니다.<code>[Symbol.iterator]</code>방법은
                            논리적으로 반복 가능한있는 모든 클래스를 정의해야합니다. 이 외에도<code>Symbol</code>가급적 사용해야합니다.</p>
                        <p class="tip">팁 :<code>Symbol.isConcatSpreadable</code>컴파일러에서 polyfilled되지 않으므로 다른 내장 기호 (예 :)
                            를 사용하지 않도록 조심하십시오. 따라서 이전 브라우저에서는 작동하지 않습니다.</p>
                        <h4>5.4.4 정적 메소드</h4>
                        <p>가독성을 저해하지 않는 곳에서는 개인 정적 메서드보다 모듈 로컬 함수를 선호합니다.</p>
                        <p>정적 메서드는 기본 클래스 자체에서만 호출해야합니다. 정적 메서드는 생성자 또는 하위 클래스 생성자가 될 수있는 동적 인스턴스를 포함하는 변수에서 호출되어서는 안되며
                            (<code>@nocollapse</code>이 작업이 완료되면 정의해야합니다. ) 메서드를 정의하지 않은 하위 클래스에서 직접 호출하면 안됩니다. 그 자체.</p>
                        <p class="illegal">불법 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // discouraged: don't call static methods dynamically
Sub.foo();  // illegal: don't call static methods on subclasses that don't define it themselves
    </code></pre>
                        </div>
                        <h4>5.4.5 구식 클래스 선언</h4>
                        <p>ES6 클래스가 선호되는 반면, ES6 클래스가 실현되지 않을 수도 있습니다. 예 :</p>
                        <ol class="ol-styled">
                            <li><p>서브 클래스를 생성하는 프레임 워크를 포함하여 서브 클래스가 존재하거나 존재할 경우, 즉시 변경하여 ES6 클래스 구문을 사용할 수 없습니다. 이러한
                                클래스가 ES6 구문을 사용하는 경우 ES6 클래스 구문을 사용하지 않는 모든 다운 스트림 하위 클래스를 수정해야합니다.</p></li>
                            <li><p><code>this</code>수퍼 클래스 생성자를 호출하기 전에 알려진 값 을 필요로하는 프레임 워크는 ES6 수퍼 클래스가있는 생성자가<code>this</code>호출이<code>super</code>반환
                                될 때까지 인스턴스 값에 액세스 할 수 없으므로 사용할 수 없습니다 .</p></li>
                        </ol>
                        <p>스타일 가이드는 여전히이 코드에 적용됩니다 다른 모든면에서 : <code>let</code>,<code>const</code>, 기본 매개 변수, 휴식, 화살표 기능을
                            모두 적절한 때 사용되어야한다.</p>
                        <p><code>goog.defineClass</code>ES6 클래스 구문과 비슷한 클래스 정의를 허용합니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">let C = goog.defineClass(S, {
  /**
   * @param {string} value
   */
  constructor(value) {
    S.call(this, 2);
    /** @const */
    this.prop = value;
  },

  /**
   * @param {string} param
   * @return {number}
   */
  method(param) {
    return 0;
  },
});</code></pre>
                        </div>
                        <p>또는<code>goog.defineClass</code>모든 새 코드에 대해 선호해야 하지만 더 일반적인 구문도 허용됩니다.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
  * @constructor @extends {S}
  * @param {string} value
  */
function C(value) {
  S.call(this, 2);
  /** @const */
  this.prop = value;
}
goog.inherits(C, S);

/**
 * @param {string} param
 * @return {number}
 */
C.prototype.method = function(param) {
  return 0;
};
</code></pre>
                        </div>
                        <p>수퍼 클래스가있는 경우 수퍼 클래스 생성자에 대한 호출 후에 인스턴스별로 속성을 생성자에 정의해야합니다. 메서드는 생성자의 프로토 타입에 정의해야합니다. </p>
                        <p>생성자 프로토 타입 계층 구조를 올바르게 정의하는 것이 처음 나타나는 것보다 어렵습니다! <a
                                href="http://code.google.com/closure/library/">따라서 Closure Library</a><code>goog.inherits</code>에서
                            사용하는 것이 가장 좋습니다 .<a href="http://code.google.com/closure/library/"></a></p>
                        <h4>5.4.6 <code>prototype</code>직접
                            조작하지 마라.</h4>
                        <p><code>class</code>키워드는 정의보다 더 명확하고 더 읽기 클래스 정의 할 수 있습니다<code>prototype</code>속성을. 보통의 구현 코드는
                            <a href="https://google.github.io/styleguide/jsguide.html#features-classes-old-style">5.4.5
                                구식 클래스 선언에</a><code>@record</code>정의 된대로 인터페이스와 클래스를 정의 하는 데 여전히 유용하지만 이러한 객체를 조작하는
                            비즈니스는 없습니다. 믹스 인과 내장 객체의 프로토 타입 수정은 명시 적으로 금지되어 있습니다.<a
                                    href="https://google.github.io/styleguide/jsguide.html#features-classes-old-style"></a>
                        </p>
                        <p class="exception">예외 : 프레임 워크 코드 (예 : Polymer 또는 Angular)는 <code>prototype</code> 를 사용해야 할 수
                            있으므로 그렇게하지 않으려면 최악의 해결 방법을 사용하지 않아야합니다.</p>
                        <p class="exception">예외 : 인터페이스에서 필드 정의 ( <a
                                href="https://google.github.io/styleguide/jsguide.html#features-classes-interfaces">5.4.9
                            인터페이스</a> 참조 ).</p>
                        <h4>5.4.7 게터와 세터</h4>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">JavaScript
                            getter 및 setter 속성을</a> 사용하지 마십시오 . 그들은 잠재적으로 놀랄만하고 추론하기가 어렵고 컴파일러에서 제한된 지원을합니다. 대신에 일반적인
                            방법을 제공하십시오.</p>
                        <p class="exception">예외 : 데이터 바인딩 프레임 워크 (예 : 각도 및 고분자)로
                            작업 할 때 getter 및 setter는 아껴서 사용할 수 있습니다. 그러나 컴파일러 지원에는 제한이
                            있습니다. 그것들을 사용할 때, 그것들은 클래스 나 객체 리터럴 <code>get
                                foo()</code>과 함께 정의되어야한다. 재산 개명을 방해하는 사용하지 마십시오. Getter 는 관찰 가능한 상태를 변경하면 안됩니다 .<code>set
                                foo(value)</code><code>Object.defineProperties</code><code>Object.defineProperty</code>
                        </p>
                        <p class="illegal">불법 :</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">class Foo {
  get next() { return this.nextId++; }
}
                            </code></pre>
                        </div>
                        <h4> 5.4.8 toString 재정의</h4>
                        <p>이 <code>toString</code>메서드는 재정의 될 수 있지만 항상 성공해야하며 부작용이 눈에 보이지 않아야합니다.</p>
                        <p class="tip">팁 : 예외적 인 조건은 무한 루프로 이어질 수 있으므로 특히 toString에서 다른 메서드를 호출하는 경우주의하십시오.</p>
                        <h4>5.4.9 인터페이스</h4>
                        <p>인터페이스는 <code>@interface</code>또는 로 선언 할 수 있습니다 <code>@record</code>.
                            와 함께 선언 된 인터페이스는 클래스 또는 객체 리터럴에 의해 <code>@record</code>명시 적으로 (즉, 경유로
                            <code>@implements</code>)
                            또는 암시 적으로 구현 될 수 있습니다.
                        </p>
                        <p>인터페이스의 모든 비 정적 메서드 본문은 빈 블록이어야합니다. 필드는 인터페이스 본문 다음에 스텁으로 정의해야합니다 <code>prototype</code>.</p>
                        <p class="example">예:</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

/** @type {number} The number of attempts before giving up. */
Frobnicator.prototype.attempts;</code></pre>
                        </div>
                    </div>

                    <h3 id="title5-5">5.5 함수</h3>
                    <div class="content">
                        <h4>5.5.1 최상위 함수</h4>
                        <p>내 보낸 함수는<code>exports</code>오브젝트에 직접 정의 되거나 로컬로 선언되고 별도로 익스포트 될 수 있습니다. 수출되지 않은 기능은 권장되며
                            신고해서는 안됩니다<code>@private</code>.</p>
                        <p class="examples">예 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/** @return {number} */
function helperFunction() {
  return 42;
}
/** @return {number} */
function exportedFunction() {
  return helperFunction() * 2;
}
/**
 * @param {string} arg
 * @return {number}
 */
function anotherExportedFunction(arg) {
  return helperFunction() / arg.length;
}
/** @const */
exports = {exportedFunction, anotherExportedFunction};
 </code></pre>
                        </div>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/** @param {string} arg */
exports.foo = (arg) => {
  // do some stuff ...
};

  </code></pre>
                        </div>
                        <h4>5.5.2 중첩 된 함수와 클로저</h4>
                        <p>함수는 중첩 된 함수 정의를 포함 할 수 있습니다. 함수에 이름을 부여하는 것이 유용한 경우에는 해당 함수를 로컬에 할당해야합니다<code>const</code>.
                        </p>
                        <h4>5.5.3 화살표 기능</h4>
                        <p>화살표 함수는 간결한 구문을 제공하고 여러 가지 문제를 해결합니다.<code>this</code>.<code>function</code>특히 중첩 된 함수에 대해서는
                            키워드에 대해 화살표 함수를 사용하십시오 (단,<a
                                    href="https://google.github.io/styleguide/jsguide.html#features-objects-method-shorthand">5.3.5
                                메소드 단축</a>참조 ).</p>
                        <p>화살표 함수를 사용<code>f.bind(this)</code>하는 것이 <code>goog.bind(f, this)</code>좋습니다. 쓰는 것을
                            피하십시오<code>const self = this</code>. 화살표 함수는 특히 예기치 않은 추가 인수를 전달하는 콜백에 특히 유용합니다.</p>
                        <p>화살표의 오른쪽은 단일 표현식 또는 블록 일 수 있습니다. 단일 비 구조 인수가있는 경우 인수 주변의} 호는 선택적입니다.</p>
                        <p class="tip">팁 : 단일 인수 화살표에도 괄호를 사용하는 것이 좋습니다. 추가 인수가 추가 될 때 괄호를 잊어 버리면 코드가 여전히 합리적으로 (그러나 잘못)
                            구문 분석 될 수 있기 때문입니다.</p>
                        <h4>5.5.4 발전기</h4>
                        <p>생성자는 여러 가지 유용한 추상화를 가능하게하고 필요에 따라 사용될 수 있습니다.</p>
                        <p>생성자 함수를 정의 할 때 키워드가있는 경우<code>*</code>이를<code>function</code>키워드에 첨부하고 함수 의 이름과 공백으로 구분하십시오.
                            위임 수율을 사용하는<code>*</code>경우<code>yield</code>키워드에 to를 첨부하십시오 .</p>

                        <p class="example">예 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
                        </code></pre>
                        </div>

                        <h4>5.5.5 매개 변수</h4>
                        <p><code>@override</code>모든 유형이 생략 된 동일한 서명 의 경우를 제외하고, 함수 매개 변수는 함수 정의 앞에 JSDoc 주석으로 JSDoc 주석을
                            입력해야합니다 .</p>
                        <p>매개 변수 유형 은 매개 변수 이름 바로 앞에 인라인으로 지정할 수 있습니다. (in과 같이 <code>(/** number */ foo, /** string */
                            bar) =&gt;foo + bar</code>). 인라인 및<code>@param</code>유형 주석은 동일한 함수 정의에서 혼합되어서 는 안됩니다 .</p>

                        <h5>5.5.5.1 기본 매개 변수</h5>
                        <p>선택적 매개 변수는 매개 변수 목록에서 equals 연산자를 사용하여 허용됩니다. 선택적 매개 변수는 equals 연산자 양쪽에 공백을 포함해야하며 접두어가 붙지 않는
                            필수 매개 변수와 똑같은 이름을 지정 하고 JSDoc 유형에 접미사를<code>opt_</code>사용하고<code>=</code>필수 매개 변수를 사용하고 관찰
                            가능한 부작용을 생성하는 초기화 도구를 사용하지 않아야합니다. 모든 선택적 매개 변수는 해당 값이더라도 함수 선언에 기본값을
                            가져야합니다<code>undefined</code>.</p>

                        <p class="example">예 : </p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * @param {string} required This parameter is always needed.
 * @param {string=} optional This parameter can be omitted.
 * @param {!Node=} node Another optional parameter.
 */
function maybeDoSomething(required, optional = '', node = undefined) {}
   </code></pre>
                        </div>

                        <p>기본 매개 변수를 조금씩 사용하십시오. 자연 순서가없는 소수의 선택적 매개 변수가있을 때 읽을 수있는 API를 만들려면 구조 해제 ( <a
                                href="https://google.github.io/styleguide/jsguide.html#features-objects-destructuring">5.3.7</a>에서와
                            같이 )를 선호 합니다.</p>

                        <p class="note">참고 : 파이썬의 기본 매개 변수와 달리 기본값이 사용될 때마다 이니셜 라이저가 평가되기 때문에 새로운 변경 가능 객체 (예
                            :<code>{}</code>또는<code>[]</code>) 를 반환하는 이니셜 라이저를 사용할 수 있으므로 단일 객체가 호출간에 공유되지 않습니다.</p>

                        <p class="tip">팁 : 함수 호출을 포함한 임의의 표현식을 이니셜 라이저로 사용할 수 있지만 가능한 한 간단하게 유지해야합니다. 함수 호출간에 의도하지 않은
                            결합이 쉽게 생길 수 있으므로 공유 된 가변 상태를 노출하는 초기화 프로그램을 사용하지 마십시오.</p>

                        <h5>5.5.5.2 휴식 매개 변수</h5>
                        <p>액세스하는 대신 rest 매개 변수를 사용하십시오<code>arguments</code>. 나머지 매개 변수는<code>...</code>JSDoc에 접두사 가있는
                            형식으로 입력됩니다 . 나머지 매개 변수는 목록의 마지막 매개 변수 여야합니다.<code>...</code>매개 변수 이름과 매개 변수 이름 사이에는 공백이 없습니다
                            . 나머지 매개 변수의 이름을 지정하지 마십시오<code>var_args</code>. 로컬 변수 나 매개 변수의 이름을 지정하지
                            마십시오<code>arguments</code>. 이는 내장 된 이름을 혼동스럽게 만듭니다.</p>

                        <p class="example">예: </p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">
                            /**
 * @param {!Array&lt;string&gt;} array This is an ordinary parameter.
 * @param {...number} numbers The remainder of arguments are all numbers.
 */
function variadic(array, ...numbers) {}
  </code></pre>
                        </div>

                        <h4>5.5.6 반품</h4>
                        <p>함수 반환 유형은<code>@override</code>모든 유형이 생략 된 동일한 서명 의 경우를 제외하고는 함수 정의 바로 위에있는 JSDoc에 지정되어야합니다 .
                        </p>
                        <h4>5.5.7 Generics</h4>
                        <p>필요에<code>@template TYPE</code>따라 클래스 정의 위의 JSDoc에서 일반 함수 및 메서드를 선언 하십시오.</p>
                        <h4>5.5.8 스프레드 연산자</h4>
                        <p>함수 호출은 스프레드 연산자 (<code>...</code>)를 사용할 수 있습니다 .<code>Function.prototype.apply</code>배열이나
                            iterable이 variadic 함수의 여러 매개 변수로 압축 해제 될 때 스프레드 연산자를 선호합니다. 뒤에 공백이 없습니다<code>...</code>.</p>
                        <p class="example">예: </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator()); </code></pre>
                        </div>
                    </div>

                    <h3 id="title5-6">5.6 문자열 리터럴</h3>
                    <div class="content">
                        <h4>5.6.1 작은 따옴표 사용</h4>
                        <p>일반 문자열 리터럴은<code>'</code>큰 따옴표 (<code>"</code>) 가 아닌 작은 따옴표 ( )로 구분됩니다.</p>
                        <p class="tip">팁 : 문자열에 작은 따옴표 문자가 포함되어 있으면 따옴표를 이스케이프하지 않아도되도록 템플릿 문자열을 사용하는 것이 좋습니다.</p>
                        <p>일반 문자열 리터럴은 여러 줄에 걸쳐있을 수 없습니다.</p>
                        <h4>5.6.2 템플릿 문자열</h4>
                        <p><code>`</code>특히 여러 문자열 리터럴이 관련된 경우 복잡한 문자열 연결에 대해 템플릿 문자열을 사용하십시오. 템플릿 문자열은 여러 줄에 걸쳐있을 수
                            있습니다.</p>
                        <p>템플릿 문자열이 여러 줄에 걸쳐있는 경우 추가하는 공백이 중요하지 않을지라도 둘러싸는 블럭의 들여 쓰기를 따를 필요가 없습니다.</p>
                        <p class="example">
                            예: </p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}</code></pre>
                        </div>

                        <h4>5.6.3 회선 계속 없음</h4>
                        <p>일반 또는 템플릿 문자열 리터럴에서 줄 연속을 사용하지 마십시오. 즉, 문자열 리터럴에서 백 슬래시로 줄을 끝냅니다. ES5에서는 이것을 허용하지만 슬래시 뒤에 오는
                            여백이 있으면 독자가 쉽게 알지 못하는 까다로운 오류가 발생할 수 있습니다.</p>

                        <p class="illegal"> 불법 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';</code></pre>
                        </div>
                        <p>대신,</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
     </code></pre>
                        </div>
                    </div>

                    <h3 id="title5-7">5.7 숫자 리터럴</h3>
                    <div class="content">
                        <p>숫자는 10 진수, 16 진수, 8 진수 또는 2 진수로 지정할 수 있습니다. 16 진수, 8 진수 및 2 진수 각각에 정확히<code>0x</code>,<code>0o</code>및<code>0b</code>접두사를
                            소문자로 사용하십시오 . 절대로은 그것이 바로 뒤에 않는 앞에 0을 포함하지 않습니다<code>x</code>,<code>o</code>또는<code>b</code>.
                        </p>
                    </div>

                    <h3 id="title5-8">5.8 제어 구조</h3>
                    <div class="content">
                        <h4>5.8.1 for 루프</h4>
                        <p>ES6을 사용하면 이제 언어에는 세 가지 종류의<code>for</code>루프가 있습니다. 모든하지만, 사용할 수 있습니다<code>for</code>-<code>of</code>루프는
                            가능하면 선호한다.</p>
                        <p><code>for</code>-<code>in</code>루프는 dict 스타일 객체에서만 사용할 수 있습니다 (<a
                                href="https://google.github.io/styleguide/jsguide.html#features-objects-mixing-keys">5.3.3
                            따옴표 붙은 키와 인용되지 않은 키를 함께 사용하지 않음</a>참조 ). 배열을 반복하는 데 사용해서는 안됩니다. 원하지 않는 프로토 타입 속성을 제외하기<code>Object.prototype.hasOwnProperty</code>위해
                            in<code>for</code>-<code>in</code>loops 에 사용해야합니다 .
                            선호<code>for</code>-<code>of</code>과<code>Object.keys</code>이상<code>for</code>-<code>in</code>가능한
                            경우.</p>
                        <h4>5.8.2 예외</h4>
                        <p>예외는 언어의 중요한 부분이며 예외적 인 경우가 발생할 때마다 사용해야합니다. 항상<code>Error</code>s 또는 하위
                            클래스를<code>Error</code>throw합니다. 문자열 리터럴이나 다른 객체를 throw하지 않습니다. .를<code>new</code>만들 때 항상 사용
                            하십시오<code>Error</code>.</p>
                        <p>사용자 정의 예외는 함수에서 추가 오류 정보를 전달할 수있는 좋은 방법을 제공합니다. 원시<code>Error</code>유형이 불충분 한 경우 정의되고
                            사용되어야합니다 .</p>
                        <p>일시적 오류 처리 접근법 (예 : 오류 컨테이너 참조 유형 전달 또는 오류 속성이있는 객체 반환)에 예외를 던지기를 선호하십시오.</p>
                        <h5>5.8.2.1 빈 캐치 블록</h5>
                        <p>잡힌 예외에 대한 응답으로 아무 것도하지 않는 것이 거의 없습니다. catch 블록에서 아무런 조치도 취하지 않는 것이 적절할 때, 이것이 정당화되는 이유는 주석에
                            설명되어 있습니다.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);

  </code></pre>
                        </div>
                        <p class="illegal">불법 :</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js"> try {
    shouldFail();
    fail('expected an error');
  }
  catch (expected) {}
  </code></pre>
                        </div>
                        <p class="tip">팁 : 다른 언어와 달리 위의 패턴은 단순히 던져진 오류를 잡아낼 수 없으므로 작동하지 않습니다<code>fail</code>.<code>assertThrows()</code>대신
                            사용하십시오 .</p>
                        <h4>5.8.3 스위치 문</h4>
                        <p>용어 참고 : 스위치 블록의 중괄호 안에 하나 이상의 명령문 그룹이 있습니다. 각 명령문 그룹은 하나 이상의 스위치 레이블 (<code>case FOO:</code>또는<code>default:</code>)과
                            하나 이상의 명령문으로 구성됩니다.</p>
                        <h5>5.8.3.1 추세 : 주석 처리 됨</h5>
                        <p>스위치 블록 내에서 각 문 그룹의 (a와 함께 돌연 종료하거나<code>break</code>,<code>return</code>또는<code>throw</code>n은
                            예외), 또는 또는 다음 명령문 그룹에 계속 한 것 실행을 나타 내기 위해 코멘트와 함께 표시됩니다. 폴스 스루 (fall-through)라는 아이디어를 전달하는
                            주석은 충분합니다 (일반적으로<code>// fall through</code>). 이 특수 주석은 스위치 블록의 마지막 명령문 그룹에 필요하지 않습니다.</p>
                        <p class="example">예: </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
} </code></pre>
                        </div>
                        <h5>5.8.3.2 <code>default</code>케이스가있다.</h5>
                        <p>각 switch 문에는 <code>default</code>코드가없는 경우에도 명령문 그룹이 포함됩니다.</p>
                    </div>

                    <h3 id="title5-9"> 5.9이</h3>
                    <div class="content">
                        <p><code>this</code>클래스 생성자 및 메서드 또는 클래스 생성자 및 메서드 내에 정의 된 화살표 함수 에서만 사용하십시오 . 의 다른 용도 는 즉시 둘러싸는
                            함수의 JSDoc에서<code>this</code>명시 적으로<code>@this</code>선언 되어야합니다 .</p>

                        <p> 사용하지 마십시오 <code>this</code>전역 객체,의 내용을 참조 <code>eval</code>, 이벤트의 대상, 또는 불필요
                            <code>call()</code>에드 또는 <code>apply()</code>에드 기능.
                        </p>
                    </div>

                    <h3 id="title5-10">5.10 허용되지 않는 기능</h3>
                    <div class="content">
                        <h4>5.10.1</h4>
                        <p><code>with</code>키워드를 사용하지 마십시오 . 그것은 당신의 코드를 이해하기 어렵게 만들고 ES5 이후 strict 모드에서 금지되었습니다.</p>
                        <h4>5.10.2 동적 코드 평가</h4>
                        <p><code>eval</code>또는<code>Function(...string)</code>생성자를 사용하지 마십시오 (코드 로더 제외). 이러한 기능은 잠재적으로
                            위험하며 단순히 CSP 환경에서 작동하지 않습니다.</p>
                        <h4>5.10.3 자동 세미콜론 삽입</h4>
                        <p>항상 세미콜론으로 문장을 종료하십시오 (위에서 언급 한 함수 및 클래스 선언 제외).</p>
                        <h4>5.10.4 비표준 특징</h4>
                        <p>비표준 기능을 사용하지 마십시오. 여기에는 제거 된 기존 기능 (예<code>WeakMap.clear</code>:), 아직 표준화되지 않은 새로운 기능 (예 : 현재
                            TC39 작업 초안, 모든 단계의 제안 또는 제안되었지만 아직 완료되지 않은 웹 표준) 또는 일부 브라우저에서만 구현됩니다. 현재 ECMA-262 또는 WHATWG
                            표준에 정의 된 기능 만 사용하십시오. Chrome 확장 또는 Node.js와 같은 특정 API에 대한 프로젝트는 분명히 해당 API를 사용할 수 있습니다. 비표준
                            언어 인 "extensions"(일부 외부 변환기에 의해 제공되는 것과 같은)는 금지됩니다.
                        </p>

                        <h4>5.10.5 원시 타입을 위한 래퍼 객체</h4>
                        <p> 절대로 사용하지 <code>new</code>원시 객체 래퍼 (에 <code>Boolean</code>, <code>Number</code>,
                            <code>String</code>, <code>Symbol</code>),도 유형 약어에 포함.
                        </p>
                        <p class="illegal"> 불법 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
   </code></pre>
                        </div>
                        <p>래퍼는 강제 변환 (<code>+</code>빈 문자열 을 사용 하거나 연결 하는 것보다 선호 됨 ) 또는 기호 만들기 와 같은 함수로 호출 될 수 있습니다 .</p>
                        <p class="example"> 예: </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected

   </code></pre>
                        </div>
                        <h4>5.10.6 기본 객체 수정</h4>
                        <p>생성자 또는 프로토 타입에 메서드를 추가하여 기본 형식을 수정하지 마십시오. 이를 수행하는 라이브러리에 의존하지 마십시오. JSCompiler의 런타임 라이브러리는
                            가능한 경우 표준 호환 폴리 필을 제공합니다. 어떤 것도 내장 객체를 수정할 수 없습니다.</p>
                        <p>
                            절대적으로 필요한 경우가 아니면 (예 : 타사 API에서 필요) 전역 개체에 심볼을 추가하지 마십시오.</p>
                    </div>
                </div>

                <h2 id="title6">이름 지정</h2>
                <div class="content">
                    <h3 id="title6-1">6.1 모든 식별자에 공통적인 규칙</h3>
                    <div class="content">
                        <p>식별자는 ASCII 문자와 숫자 만 사용하며, 아래에서 언급하는 소수의 경우에서 매우 드물지만 (각도와 같은 프레임 워크에서 요구하는 경우) 달러 기호가
                            강조됩니다.</p>
                        <p>가능한 이유를 설명하는 이름으로 제공하십시오. 새로운 독자가 코드를 즉시 이해할 수 있도록하기 위해 수평 공간을 절약하는 것에 대해 걱정하지 마십시오. 프로젝트 외부
                            독자에게
                            모호하거나 익숙하지 않은 약어는 사용하지 말고 단어 내의 문자를 삭제하여 약어를 사용하지 마십시오.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">priceCountReader      // No abbreviation.
numErrors             // "num" is a widespread convention.
numDnsConnections     // Most people know what "DNS" stands for.</code></pre>
                        </div>

                        <p class="illegal"> 불법 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">n                     // Meaningless.
nErr                  // Ambiguous abbreviation.
nCompConns            // Ambiguous abbreviation.
wgcConnections        // Only your group knows what this stands for.
pcReader              // Lots of things can be abbreviated "pc".
cstmrId               // Deletes internal letters.
kSecondsPerDay        // Do not use Hungarian notation.
</code></pre>
                        </div>
                    </div>

                    <h3 id="title6-2">6.2 식별자 유형별 규칙</h3>
                    <div class="content">
                        <h4>6.2.1 패키지 이름</h4>
                        <p>패키지 이름은 모두<code>lowerCamelCase</code>. 예를 들어, 또는<code>my.exampleCode.deepSpace</code>아닙니다
                            .<code>my.examplecode.deepspace</code><code>my.example_code.deep_space</code>
                        </p>
                        <h4>6.2.2 클래스 이름</h4>
                        <p>클래스, 인터페이스, 레코드 및 typedef 이름이 기록됩니다<code>UpperCamelCase</code>. unexported 클래스는 간단하게
                            locals입니다 : 그들은
                            표시되지<code>@private</code>않으므로 후행 밑줄로 이름을 지정하지 않습니다.</p>
                        <p>유형 이름은 일반적으로 명사 또는 명사구입니다. 예를
                            들어<code>Request</code>,<code>ImmutableList</code>또는<code>VisibilityMode</code>. 또한 인터페이스 이름은
                            때로는 형용사
                            또는 형용사가 될 수 있습니다 (예 :)<code>Readable</code>.</p>
                        <h4>6.2.3 메소드 이름</h4>
                        <p>메서드 이름은에 기록됩니다<code>lowerCamelCase</code>. private 메소드의 이름은 뒷부분의 밑줄로 끝나야합니다.</p>
                        <p>메소드 이름은 일반적으로 동사 또는 동사입니다. 예를 들어,<code>sendMessage</code>또는<code>stop_</code>. 속성에 대한 Getter
                            및 Setter 메서드는 절대로 필요하지 않지만 사용되는 경우<code>getFoo</code>(또는 선택적으로<code>isFoo</code>또는<code>hasFoo</code>부울
                            값 으로 지정해야 함 ) 또는<code>setFoo(value)</code>setter에 대해 지정해야합니다 .</p>
                        <p>밑줄은 JsUnit 테스트 메소드 이름에 나타나서 이름의 논리적 구성 요소를 구분할 수도 있습니다. 하나의 전형적인 패턴은<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>예를
                            들어있다<code>testPop_emptyStack</code>. 테스트 방법의 이름을 짓는 올바른 방법은 없습니다.</p>

                        <h4>6.2.4 열거 형 이름</h4>
                        <p>열거 형 이름은<code>UpperCamelCase</code>클래스와 유사하게 작성되며 일반적으로 단 수 명사 여야합니다. 열거 형 내의 개별 항목은에 이름이
                            지정됩니다<code>CONSTANT_CASE</code>.</p>
                        <h4>6.2.5 상수 이름</h4>
                        <p>상수 이름<code>CONSTANT_CASE</code>에는 밑줄로 구분 된 모든 대문자가 사용 됩니다. 개인용 정적 속성은 (암시 적으로 개인적인) 모듈 지역으로
                            대체 될 수 있기 때문에 상수에 후행 밑줄을 붙여 이름을 지정할 필요는 없습니다.</p>
                        <h5>6.2.5.1 "상수"의 정의</h5>
                        <p>모든 상수는<code>@const</code>정적 속성 또는 모듈 로컬<code>const</code>선언이지만 모든<code>@const</code>정적 속성과 모듈
                            로컬<code>const</code>이 상수는 아닙니다 . 상수 경우를 선택하기 전에, 필드가 정말로 불변의 불변의 정수로 느껴지는지를 고려 해주세요 . 예를 들어,
                            해당 인스턴스의 관찰 가능 상태가 변경 될 수 있다면 거의 확실하게 상수가 아닙니다. 개체를 돌연변이 시키려하지 않고 단지 일반적으로 충분하지 않습니다.</p>

                        <p class="examples">예 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">// Constants
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// Not constants
let letVariable = 'non-const';
class MyClass { constructor() { /** @const */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';
const /** Set&lt;String&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // mirrors imported name
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>
                        </div>

                        <p>상수의 이름은 일반적으로 명사 또는 명사구입니다.</p>
                        <h5>6.2.5.1 로컬 별칭</h5>
                        <p>로컬 별칭은 정규화 된 이름보다 가독성을 향상시킬 때마다 사용해야합니다. 별명이 지정된 이름의 마지막 부분을 유지하면서<code>goog.require</code>s
                            (<a href="https://google.github.io/styleguide/jsguide.html#file-goog-require">3.4
                                goog.require 문</a>) 와 동일한 규칙을 따르십시오 . 함수 내에서 별칭을 사용할 수도 있습니다. 별칭이
                            있어야합니다<code>const</code>.</p>
                        <p class="examples">예 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
 </code></pre>
                        </div>

                        <h4>6.2.6 상수가 아닌 필드 이름</h4>
                        <p>정적이 아닌 필드 이름 (정적 또는 기타)은<code>lowerCamelCase</code>개인 필드에 대한 후행 밑줄과 함께 쓰여집니다 .</p>
                        <p>이 이름은 일반적으로 명사 또는 명사구입니다. 예를 들어,<code>computedValues</code>또는<code>index_</code>.</p>

                        <h4>6.2.7 매개 변수 이름</h4>
                        <p>매개 변수 이름은에 기록됩니다<code>lowerCamelCase</code>. 매개 변수가 생성자를 예상하는 경우에도 적용됩니다.</p>
                        <p>한 문자 매개 변수 이름은 공용 메서드에서 사용하면 안됩니다.</p>
                        <p class="exception">예외 : 타사 프레임 워크에서 필요할 경우 매개 변수 이름은로 시작될 수 있습니다<code>$</code>. 이 예외는 다른 식별자
                            (예 : 지역 변수 또는 속성)에는 적용되지 않습니다.</p>
                        <h4>6.2.8 지역 변수 이름</h4>
                        <p><code>lowerCamelCase</code>위에 설명 된대로 모듈 로컬 (최상위 레벨) 상수를 제외하고 지역 변수 이름이 기록됩니다 . 함수 범위의 상수는 여전히
                            in에 명명됩니다<code>lowerCamelCase</code>. 변수에 생성자가있는 경우에도 lowerCamelCase가 적용됩니다.</p>

                        <h4>6.2.9 템플릿 매개 변수 이름</h4>
                        <p>템플릿 매개 변수 이름은 간결하고, 한 단어 또는 단일 문자 식별자해야하고, 같은 모든 모자,해야<code>TYPE</code>하거나<code>THIS</code>.
                        </p>
                    </div>

                    <h3 id="title6-3">6.3 카멜 표기법(Camel Case) : 정의 됨</h3>
                    <div class="content">
                        <p>영어 문구를 카멜 표기법으로 변환하는 합리적인 방법이 여러 가지 있습니다 (예 : 약어 또는<q>IPv6</q>또는<q>iOS</q>와 같은 비정상적인 구문 이있는
                            경우). 예측 가능성을 높이기 위해 Google 스타일은 다음과 같은 (거의) 결정 론적 계획을 지정합니다.</p>
                        <p>산문 형태의 이름으로 시작 :</p>
                        <ol class="ol-styled">
                            <li>
                                구문을 일반 ASCII로 변환하고 아포스트로피를 제거하십시오. 예를 들어,<q>Müller의 알고리즘</q>은<q>Muellers 알고리즘</q>이 될 수
                                있습니다.
                            </li>
                            <li>이 결과를 단어, 공백 및 나머지 구두점 (일반적으로 하이픈)으로 나눕니다.
                                <ol>
                                    <li>권장 단어 : 일반적인 단어로 된 기존의 카멜표기법 사례가 이미있는 경우이를 구성 요소로 나눕니다 (예 :<q>애드워즈</q>는<q>광고
                                        단어가됩니다</q>).<q>iOS</q>와 같은 단어 는 실제 카멜표기법이 아닙니다. 어떠한 대회에도 위배되므로이 권장 사항은 적용되지
                                        않습니다.
                                    </li>
                                </ol>
                            </li>
                            <li>이제는 모든 것을 소문자로 바꾸고 (대문자 포함), 다음의 첫 문자 만 대문자로 만드십시오.
                                <ol>
                                    <li>... 각 단어, 위 카멜 표기법 산출하기 위해, 또는</li>
                                    <li>... 첫 번째 단어를 제외한 각 단어는 더 낮은 카멜 표기법을 산출합니다.</li>
                                </ol>
                            </li>
                            <li>마지막으로 모든 단어를 하나의 식별자로 결합하십시오.</li>
                        </ol>
                        <p>원래 단어의 대소 문자는 거의 전적으로 무시됩니다.</p>
                        <p class="examples">예 : </p>
                        <table class="table table-styled">
                            <thead>
                            <tr>
                                <th>
                                    산문
                                    형태
                                </th>
                                <th>
                                    옳은
                                </th>
                                <th>
                                    잘못된
                                </th>
                            </tr>
                            </thead>

                            <tbody>
                            <tr>
                                <td>
                                    <q>XML
                                        HTTP
                                        요청</q>
                                </td>
                                <td>
                                    XmlHttpRequest
                                </td>
                                <td>
                                    XMLHTTPRequest
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <q>새
                                        고객
                                        ID</q>
                                </td>
                                <td>
                                    newCustomerId
                                </td>
                                <td>
                                    newCustomerID
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <q>내부
                                        초시계</q>
                                </td>
                                <td>
                                    innerStopwatch
                                </td>
                                <td>
                                    innerStopWatch
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <q>iOS에서
                                        IPv6을
                                        지원합니까?</q>
                                </td>
                                <td>
                                    supportsIpv6OnIos
                                </td>
                                <td>
                                    IPv6OnIOS를
                                    지원합니다.
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <q>YouTube
                                        Imports</q>
                                </td>
                                <td>
                                    YouTubeImporter
                                </td>
                                <td>
                                    YoutubeImporter
                                    *
                                </td>
                            </tr>
                            </tbody>
                        </table>

                        <p>* 허용되지만 권장하지는 않습니다. </p>

                        <p class="note">참고 : 일부 단어는 영어로 모호 하이픈 있습니다 : 예에 대한<q>비어 있지 않은</q>및<q>비어 있지 않은가</q>모두 올바른지 때문에
                            메소드 이름 checkNonempty 및 checkNonEmpty 마찬가지로 모두 정확합니다.</p>
                    </div>
                </div>

                <h2 id="title7">JSDoc</h2>
                <div class="content">
                    <p><a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">JSDoc</a>은 모든
                        클래스, 필드 및 메서드에 사용됩니다.</p>

                    <h3 id="title7-1">7.1 일반 서식</h3>
                    <div class="content">
                        <p>JSDoc 블록의 기본 형식은 다음 예제와 같습니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Multiple lines of JSDoc text are written here,
 * wrapped normally.
 * @param {number} arg A number to do something to.
 */
function doSomething(arg) { … }
   </code></pre>
                        </div>
                        <p>또는이 한 줄짜리 예제에서 :</p>
                        <div class="code-box-copy">
                            <pre><code class="language-js">/** @const @private {!Foo} A short bit of JSDoc. */
this.foo_ = foo;
</code></pre>
                        </div>
                        <p>한 줄 주석이 여러 행으로 오버 플로우 경우와 멀티 라인 스타일을 사용해야<code>/**</code>하고<code>*/</code>자신의 라인에.</p>
                        <p>많은 도구가 JSDoc 주석에서 메타 데이터를 추출하여 코드 유효성 검사 및 최적화를 수행합니다. 따라서 이러한 Comments는 올바른 형식 이어야합니다 .</p>
                    </div>

                    <h3 id="title7-2">7.2 Markdown</h3>
                    <div class="content">
                        <p>JSDoc은 필요한 경우 HTML을 포함 할 수 있지만 Markdown에 작성됩니다.</p>
                        <p>JSDoc (예 :<a href="https://github.com/jleyba/js-dossier">JsDossier</a>) 를 자동으로 추출하는 도구 는 일반
                            텍스트
                            형식을 무시하는 경우가 있으므로 참고하면됩니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code></pre>
                        </div>
                        <p>그것은 다음과 같이 나올 것입니다 : </p>
                        <div class="code-box-copy">
                        <pre><code
                                class="language-js">Computes weight based on three factors: items sent items received last timestamp</code></pre>
                        </div>
                        <p>대신 Markdown 목록을 작성하십시오.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Computes weight based on three factors:
 *  - items sent
 *  - items received
 *  - last timestamp
 */
</code></pre>
                        </div>
                    </div>

                    <h3 id="title7-3">7.3 JSDoc 태그</h3>
                    <div class="content">
                        <p>Google 스타일은 JSDoc 태그의 하위 집합을 허용합니다. 전체 목록 은<a
                                href="https://google.github.io/styleguide/jsguide.html#appendices-jsdoc-tag-reference">9.1
                            JSDoc 태그 참조</a>를<a
                                href="https://google.github.io/styleguide/jsguide.html#appendices-jsdoc-tag-reference">참조</a>하십시오.
                            대부분의 태그는 줄의 시작 부분에 태그가있는 자체 줄을 차지해야합니다.</p>
                        <p class="illegal">불법 : </p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
   </code></pre>
                        </div>
                        <p>추가 데이터를 필요로하지 않는 간단한 태그
                            (예는<code>@private</code>,<code>@const</code>,<code>@final</code>,<code>@export</code>)
                            적절한 때 옵션 형과 함께 같은 라인에 결합 될 수있다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Place more complex annotations (like "implements" and "template")
 * on their own lines.  Multiple simple tags (like "export" and "final")
 * may be combined in one line.
 * @export @final
 * @implements {Iterable&lt;TYPE&gt;}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Some object.
   * @param {number=} num An optional number.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array<!ObjType|number>} */
    this.data_ = [obj, num];
  }
}
    </code></pre>
                        </div>
                        <p>태그를 결합 할시기 또는 순서는 엄격하지만 일관성있는 규칙은 없습니다.</p>

                        <p>자바 스크립트에서 주석 달기에 대한 일반적인 정보<a
                                href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">는
                            클로저 컴파일러에 대한</a>JavaScript<a
                                href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">주석</a>및<a
                                href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">클로저
                            유형 시스템의 유형을</a>참조하십시오 .</p>
                    </div>

                    <h3 id="title7-4">7.4 줄 바꿈</h3>
                    <div class="content">
                        <p>줄 바꿈 된 블록 태그는 4 칸 들여 쓰기됩니다. 래핑 된 설명 텍스트는 이전 행에 대한 설명과 나란히 표시 될 수 있지만이 수평 정렬은 권장되지 않습니다.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
exports.method = function(foo) {
  return 5;
};
   </code></pre>
                            <p><code>@fileoverview</code>설명을 줄 때 들여 쓰기를하지 마십시오 .</p>
                        </div>
                    </div>

                    <h3 id="title7-5">7.5 상위 / 파일 수준 주석</h3>
                    <div class="content">
                        <p>파일에는 최상위 파일 개요가있을 수 있습니다. 저작권 공지, 작성자 정보 및 기본<a
                                href="https://google.github.io/styleguide/jsguide.html#jsdoc-visibility-annotations">표시
                            수준</a>은 선택 사항입니다. 파일 개요는 파일이 두 개 이상의 클래스 정의로 구성 될 때마다 일반적으로 권장됩니다. 최상위 레벨 주석은 코드에 익숙하지
                            않은 독자가이 파일에있는 내용을 향하도록하기위한 것입니다. 파일이있는 경우 파일 내용 및 모든 종속성 또는 호환성 정보에 대한 설명을 제공 할 수 있습니다.
                            감싸 인 선은 들여 쓰이지 않습니다.</p>
                        <p class="example"> 예 : </p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @package
 */</code></pre>
                        </div>
                    </div>

                    <h3 id="title7-6">7.6 클래스 코멘트</h3>
                    <div class="content">
                        <p>클래스, 인터페이스 및 레코드는 설명과 템플릿 매개 변수, 구현 된 인터페이스, 가시성 또는 기타 적절한 태그를 사용하여 문서화해야합니다. 클래스 설명은 클래스을
                            올바르게 사용하는 데 필요한 추가 고려 사항뿐만 아니라 클래스을 언제 어떻게 사용하는지 알 수있는 충분한 정보를 독자에게 제공해야합니다. 텍스트 설명은
                            생성자에서 생략 될 수 있습니다.<code>@constructor</code>그리고<code>@extends</code>주석이 사용되지
                            않습니다<code>class</code>클래스가
                            선언을 사용하지 않는 키워드<code>@interface</code>또는 제네릭 클래스를 확장합니다.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * A fancier event target that does cool things.
 * @implements {Iterable&lt;string&gt;}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 An argument that makes this more interesting.
   * @param {!Array&lt;number&gt;} arg2 List of numbers to be processed.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Records are also helpful.
 * @extends {Iterator&lt;TYPE&gt;}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} The next item in line to be returned. */
  next() {}
}
                            </code></pre>
                        </div>
                    </div>

                    <h3 id="title7-7">7.7 열거 형 및 typedef 주석</h3>
                    <div class="content">
                        <p>열거 형 및 typedef는 문서화되어야합니다. 공개 열거 형 및 typedef에는 비어 있지 않은 설명이 있어야합니다. 개별 열거 형 항목은 앞 줄에
                            JSDoc 주석으로 문서화 될 수 있습니다.</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * A useful type union, which is reused often.
 * @typedef {!Bandersnatch|!BandersnatchType}
 */
let CoolUnionType;


/**
 * Types of bandersnatches.
 * @enum {string}
 */
const BandersnatchType = {
  /** This kind is really frumious. */
  FRUMIOUS: 'frumious',
  /** The less-frumious kind. */
  MANXOME: 'manxome',
};

   </code></pre>
                        </div>

                        <p>typedef는 짧은 레코드 유형이나 공용체, 복합 함수 또는 제네릭 형식의 별칭을 정의 할 때 유용합니다. 개별 필드를 문서화하거나 템플릿이나 재귀 참조를
                            사용할 수 없으므로 많은 필드가있는 레코드 유형에서는 typedef를 피해야합니다. 큰 레코드 유형의 경우 선호합니다<code>@record</code>.
                        </p>
                    </div>

                    <h3 id="title7-8">7.8 메소드와 함수 주석</h3>
                    <div class="content">
                        <p>매개 변수 및 반환 유형을 문서화해야합니다.<code>this</code>유형은 필요한 경우 문서화되어야한다. 메서드, 매개 변수 및 반환 설명 (형식 아님)은
                            메서드의 나머지 JSDoc 또는 서명에서 명백한 경우 생략 될 수 있습니다. 메소드 설명은 3 인칭 선언문으로 작성된 문장으로 시작해야합니다. 메소드가 수퍼
                            클래스 메소드를 겹쳐 쓰면<code>@override</code>주석이 포함되어야합니다. 오버라이드 된 메서드는 모든 유형이 정제 된 경우
                            all<code>@param</code>및<code>@return</code>주석을
                            포함해야 하지만 유형이 모두 동일한 경우 주석을 생략해야합니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/** This is a class. */
class SomeClass extends SomeBaseClass {
  /**
   * Operates on an instance of MyClass and returns something.
   * @param {!MyClass} obj An object that for some reason needs detailed
   *     explanation that spans multiple lines.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Whether something occurred.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /** @override */
  overriddenMethod(param) { ... }
}

/**
 * Demonstrates how top-level functions follow the same rules.  This one
 * makes an array.
 * @param {TYPE} arg
 * @return {!Array&lt;TYPE&gt;}
 * @template TYPE
 */
function makeArray(arg) { ... }
   </code></pre>
                        </div>

                        <p>익명 함수는 JSDoc을 필요로하지 않지만 자동 유형 유추가 불충분 할 경우 매개 변수 유형이 인라인으로 지정 될 수 있습니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">promise.then(
    (/** !Array&lt;number|string&gt; */ items) => {
      doSomethingWith(items);
      return /** @type {string} */ (items[0]);
    });
      </code></pre>
                        </div>
                    </div>

                    <h3 id="title7-9">7.9 Property comments </h3>
                    <div class="content">
                        <p>Property 유형을 문서화해야합니다. 이름과 유형이 코드를 이해하기에 충분한 문서를 제공하는 경우 개인 속성에 대한 설명을 생략 할 수 있습니다. </p>
                        <p>공개적으로 내 보낸 상수는 속성과 동일한 방식으로 주석 처리됩니다. 명시 적으로<code>@const</code>알려진 유형의 표현식으로 초기화 된 속성의 경우
                            명시 적 유형을 생략 할 수 있습니다.</p>
                        <p class="tip">팁 :<code>@const</code>속성 유형이 선언 된 유형의 생성자 매개 변수에서 직접 할당되거나 선언 된 반환 유형이있는 함수
                            호출에서 직접 할당되는 경우 속성 유형을 "분명히 알 수있는"것으로 간주 할 수 있습니다. 보다 복잡한 표현식에서 할당 된 비 const 특성 및 특성은 명시
                            적으로 선언 된 유형을 가져야합니다.</p>
                        <div class="code-box-copy">
                        <pre><code class="language-js">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Maximum number of things per pane.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * The number of times we'll try before giving up.
 * @const
 */
MyClass.RETRY_COUNT = 33;
 </code></pre>
                        </div>
                    </div>

                    <h3 id="title7-10">7.10 유형 주석</h3>
                    <div class="content">
                        <p>주석이 발견되어 입력<code>@param</code>,<code>@return</code>,<code>@this</code>,
                            및<code>@type</code>태그, 선택적에<code>@const</code>,<code>@export</code>, 및 가시성 태그입니다.
                            JSDoc
                            태그에 첨부 된 유형 주석은 항상 중괄호로 묶어야합니다.</p>
                        <h4>7.10.1 Nullability</h4>
                        <p>형식 시스템은 한정자를 정의<code>!</code>하고<code>?</code>각각 null이 아니거나 nullable 인 경우를 정의합니다 . 원시
                            유형
                            (<code>undefined</code>,<code>string</code>,<code>number</code>,<code>boolean</code>,<code>symbol</code>,과<code>function(...):
                                ...</code>) 기록 리터럴 (<code>{foo: string, bar: number}</code>) 기본적으로 비
                            null입니다.<code>!</code>이러한 유형에 명시 적으로 추가하지 마십시오 . 개체 유형
                            (<code>Array</code>,<code>Element</code>,<code>MyClass</code>, 등) 기본적으로 널
                            (NULL)하지만있는
                            이름에서 바로 구별 할 수 없습니다<code>@typedef</code>null이 아닌 별 기본 유형 'D. 따라서, 원시 기록 리터럴을 제외한 모든
                            유형 중
                            하나를 명시 적으로 주석을해야<code>?</code>하거나<code>!</code>그들이 널 (NULL)인지 아닌지를 나타냅니다.</p>
                        <h4>7.10.2 유형 캐스트</h4>
                        <p>유형 검사가 표현식의 유형을 정확하게 추론하지 못하는 경우 유형 주석 주석을 추가하고 표현식을 괄호로 묶어서 유형을 강화할 수 있습니다. 괄호는 필수
                            항목입니다.</p>
                        <div class="code-box-copy">
                            <pre><code class="language-js">/** @type {number} */ (x) </code></pre>
                        </div>

                        <h4> 7.10.3 템플릿 매개 변수 유형</h4>

                        <p>항상 템플릿 매개 변수를 지정하십시오. 이 방법은 컴파일러가 더 나은 작업을 수행 할 수 있으며 독자가 코드가하는 것을 이해하기 쉽게 만듭니다.</p>

                        <p class="bad">나쁜:</p>

                        <div class="code-box-copy">
                            <pre><code class="language-js">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;</code></pre>
                        </div>

                        <p class="good">좋은:</p>

                        <div class="code-box-copy">
                        <pre><code class="language-js">const /** !Object&lt;string, !User&gt; */ users = {};
const /** !Array&lt;string&gt; */ books = [];
const /** !Promise&lt;!Response&gt; */ response = ...;

const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object&lt;string, *&gt; */ mapOfEverything = {};
                            </code></pre>
                        </div>
                        <p>템플릿 매개 변수를 사용하지 않아야하는 경우 :</p>
                        <ul>
                            <li>
                                <code>Object</code>맵과 같은 구조가 아닌 유형 계층 구조에 사용됩니다.
                            </li>
                        </ul>
                    </div>

                    <h3 id="title7-11"> 7.11 가시성 주석</h3>
                    <div class="content">
                        <p>가시성 주석은 (<code>@private</code>,<code>@package</code>,<code>@protected</code>)이 지정 될 수있다<code>@fileoverview</code>블록
                            또는 반출 심볼 또는 구내. 함수 내에서 또는 모듈의 최상위에서 로컬 변수에 대한 가시성을 지정하지 마십시오. 모든<code>@private</code>이름은 밑줄로
                            끝나야합니다.</p>
                    </div>
                </div>
            </div>

            <h2 id="title8">정책</h2>
            <div class="content">
                <h3 id="title8-1">8.1 Google 스타일에 명시되지 않은 문제 : 일관성을 유지하십시오!</h3>
                <div class="content">
                    <p>이 사양에 의해 결정적으로 해결되지 않는 스타일 질문의 경우 동일한 파일의 다른 코드가 이미 수행하고있는 작업을 수행하는 것이 좋습니다. 그래도 문제가
                        해결되지
                        않으면 같은 패키지에있는 다른 파일을 에뮬레이션하는 것이 좋습니다.</p>
                </div>

                <h3 id="title8-2">8.2 컴파일러 경고</h3>
                <div class="content">
                    <h4>8.2.1 표준 경고 세트 사용</h4>
                    <p>최대한 가능한 한 프로젝트를 사용해야합니다<code>--warning_level=VERBOSE</code>.</p>
                    <h4>8.2.2 경고 처리 방법</h4>
                    <p>어떤 일을하기 전에 경고가 무엇을 말하고 있는지 정확히 이해했는지 확인하십시오. 경고가 나타나는 이유가 확실하지 않은 경우 도움을 요청하십시오.</p>
                    <p>경고를 이해했으면 다음 해결책을 순서대로 시도하십시오.</p>
                    <ol class="ol-styled">
                        <li>먼저 수정하거나 해결하십시오. 실제적으로 경고를 다루는 강력한 시도를하거나 상황을 완전히 피하는 작업을 수행하는 다른 방법을 찾으십시오.
                        </li>
                        <li>그렇지 않으면 거짓 경보인지 확인하십시오. 경고가 유효하지 않고 코드가 실제로 안전하고 정확하다고 확신하는 경우 독자에게이
                            사실을<code>@suppress</code>알리고 주석을 적용하는 주석을 추가하십시오.
                        </li>
                        <li>그렇지 않으면 TODO 주석을 남겨 둡니다. 이것은 최후의 수단 입니다. 이 경우 경고를 표시하지 마십시오. 경고는 제대로 처리 될 때까지 볼
                            수
                            있어야합니다.
                        </li>
                    </ol>
                    <h4>8.2.3 가장 좁은 범위에서 경고를 억제한다.</h4>
                    <p>경고는 가장 좁은 합리적인 범위, 일반적으로 단일 로컬 변수 또는 매우 작은 메서드에서 억제됩니다. 종종 그 이유만으로 변수 또는 메소드가
                        추출됩니다.</p>
                    <p> 예</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">/** @suppress {uselessCode} Unrecognized 'use asm' declaration */
function fn() {
  'use asm';
  return 0;
}
  </code></pre>
                    </div>
                    <p>클래스 내에서 많은 수의 억압들조차도 이런 종류의 경고에 전체 클래스를 보지 못하는 것보다 낫습니다.</p>
                </div>

                <h3 id="title8-3"> 8.3 사용 중단</h3>
                <div class="content">
                    <p>사용되지 않는 메소드, 클래스 또는<code>@deprecated</code>주석이있는 인터페이스를 표시하십시오 . 사용 중단 코멘트에는 사람들이 전화
                        사이트를 수정하기위한 간단하고 명확한 안내가 포함되어야합니다.</p>
                </div>

                <h3 id="title8-4">8.4 Google 스타일에없는 코드</h3>
                <div class="content">
                    <p>코드베이스에서 적절한 Google 스타일이 아닌 파일을 때때로 만날 수 있습니다. 이들은 인수에서 왔을 수도 있고, Google 스타일이 어떤 문제에
                        대해 입장을 취하기 전에 작성되었을 수도 있고, 다른 이유로 Google 스타일이 아닐 수도 있습니다.</p>
                    <h4>8.4.1 기존 코드 재 포맷</h4>
                    <p>기존 코드의 스타일을 업데이트 할 때 다음 지침을 따르십시오.</p>
                    <ol class="ol-styled">
                        <li>현재 스타일 가이드 라인에 맞게 기존 코드를 모두 변경할 필요는 없습니다. 기존 코드를 다시 포맷하는 것은 코드 변경과 일관성 사이의
                            절충입니다. 스타일 규칙은 시간이 지남에 따라 발전하며 이러한 종류의 조정을 통해 규정 준수를 유지하면 불필요한 변동이 발생할 수 있습니다.
                            그러나 파일을 크게 변경하면 파일이 Google 스타일에 포함될 것으로 예상됩니다.
                        </li>
                        <li>기회 주의적 스타일 수정이 CL의 초점을 혼란시키지 않도록주의하십시오. CL의 중심 집중에 중요하지 않은 스타일 변경을 많이하는 경우, 이러한
                            변경 사항을 별도의 CL로 승격하십시오.
                        </li>
                    </ol>
                    <h4> 8.4.2 새로 추가 된 코드 : Google 스타일 사용</h4>
                    <p>새로운 파일은 같은 패키지에있는 다른 파일의 스타일 선택에 관계없이 Google 스타일을 사용합니다.</p>
                    <p>Google Style에없는 파일에 새 코드를 추가 할 때는 먼저<a
                            href="https://google.github.io/styleguide/jsguide.html#policies-reformatting-existing-code">8.4.1</a>기존
                        코드 다시 포맷의 지침에 따라 기존 코드를 다시 포맷하는 것이 좋습니다 .</p>
                    <p>이 형식을 다시 지정하지 않으면 새 코드는 가능한 한 동일한 파일의 기존 코드와 일치해야하지만 스타일 가이드를 위반해서는 안됩니다.</p>
                </div>

                <h3 id="title8-5">8.5 지역 스타일 규칙</h3>
                <div class="content">
                    <p>팀과 프로젝트는이 문서 이외의 스타일 규칙을 채택 할 수 있지만 추가 변경 사항이 이러한 추가 규칙을 준수하지 않을 수 있음을 인정해야하며 추가 규칙을
                        위반하여 정리 변경 사항을 차단해서는 안됩니다. 아무 목적도없는 과도한 규칙을 조심하십시오. 스타일 가이드는 가능한 모든 시나리오에서 스타일을
                        정의하려고하지 않으며 어느면에서도 스타일을 정의하려고하지 않습니다.</p>
                </div>

                <h3 id="title8-6"> 8.6 생성 된 코드 : 주로 면제 됨</h3>
                <div class="content">
                    <p>빌드 프로세스에 의해 생성 된 소스 코드는 Google 스타일에있을 필요가 없습니다. 그러나 직접 작성한 소스 코드에서 참조 할 생성 된 식별자는 모두
                        이름 지정 요구 사항을 따라야합니다. 예외적으로 이러한 식별자에는 밑줄이 포함될 수 있으므로 직접 작성한 식별자와의 충돌을 피할 수 있습니다.</p>
                </div>
            </div>

            <h2 id="title9">부록</h2>
            <div class="content">
                <h3 id="title9-1"> 9.1 JSDoc 태그 참조</h3>
                <div class="content">
                    <p>JSDoc은 JavaScript에서 다양한 용도로 사용됩니다. 문서 생성에 사용되는 것 외에도 툴링을 제어하는데도 사용됩니다. 가장 잘 알려진 클로저
                        컴파일러 유형 주석이 있습니다.</p>
                    <h4> 9.1.1 주석 및 기타 Closure Compiler 주석 입력</h4>
                    <p>폐쇄 컴파일러에서 사용되는 JSDoc에 대한 문서는 클로저 컴파일러에<a
                            href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">대한
                        JavaScript 주석</a>및<a
                            href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">클로저
                        유형 시스템에서의 유형에</a>설명되어 있습니다.</p>
                    <h4>9.1.2 문서 주석</h4>
                    <p>
                        <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">클로저
                            컴파일러에 대한 JavaScript 주석에</a>설명 된 JSDoc 외에도 다음 태그는 순수한 문서화를 위해 다양한 문서 생성 도구 (예 :<a
                            href="https://github.com/jleyba/js-dossier">JsDossier</a>)에서 일반적으로 잘 지원 됩니다.</p>
                    <table class="table table-styled">
                        <colgroup>
                            <col width="15%">
                            <col width="55%">
                            <col width="30%">
                        </colgroup>
                        <thead>
                        <tr>
                            <th>
                                꼬리표
                            </th>
                            <th>템플릿 및 예</th>
                            <th>
                                기술
                            </th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>
                                <code>@author</code>
                                또는
                                <code>@owner</code>
                            </td>
                            <td>
                                <code>@author
                                    username@google.com
                                    (First
                                    Last)</code>
                                <p>예 :</p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * @fileoverview Utilities for handling textareas.
 * @author kuth@google.com (Uthur Pendragon)
 */

</code></pre>
                                </div>
                            </td>
                            <td>일반적으로<code>@fileoverview</code>주석 에만 사용되는 파일 작성자 또는 테스트 소유자를 문서화하십시오 .
                                이<code>@owner</code>태그는 단위 테스트 대시 보드에서 테스트 결과를 소유 한 사람을 확인하는 데 사용됩니다.<p>권장하지
                                    않습니다.</p></td>
                        </tr>
                        <tr>
                            <td>
                                <code>@bug</code>
                            </td>
                            <td>
                                <code>@bug
                                    bugnumber</code>
                                <p>예 :</p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/** @bug 1234567 */
function testSomething() {
  // …
}

/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // …
}
</code></pre>
                                </div>
                            </td>
                            <td>주어진 테스트 함수 회귀 테스트에서 어떤 버그가 있는지 나타냅니다.<p><code>@bug</code>회귀 테스트를 가능한 한 쉽게 검색
                                할 수 있도록 여러 버그가 각각 고유 한 행을 가져야 합니다.</p></td>
                        </tr>
                        <tr>
                            <td>
                                <code>@code</code>
                            </td>
                            <td>
                                <code>{@code
                                    ...}</code>
                                <p> 예 : </p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Moves to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it
 * passes the end of the range.
 * @return {!Node} The node at the next position.
 */
goog.dom.RangeIterator.prototype.next = function() {
  // …
};
  </code></pre>
                                </div>
                            </td>
                            <td>JSDoc 설명의 용어가 코드이므로 생성 된 문서에서 올바르게 형식화 될 수 있음을 나타냅니다.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>@see</code>
                            </td>
                            <td>
                                <code>@see Link</code>
                                <p>예 : </p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */</code></pre>
                                </div>
                            </td>
                            <td>
                                다른
                                클래스
                                함수
                                또는
                                메서드에
                                대한
                                조회를
                                참조하십시오.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>@supported</code>
                            </td>
                            <td>
                                <code>@supported
                                    Description</code>
                                <p>
                                    예
                                    :
                                </p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the
 * browsers' event systems.
 * @supported IE10+, Chrome, Safari
 */</code></pre>
                                </div>
                            </td>
                            <td>fileoverview에서 파일에서 지원되는 브라우저를 나타내는 데 사용됩니다.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>@desc</code>
                            </td>
                            <td>
                                <code>@desc Message description</code>
                                <p>
                                    예
                                    :
                                </p>
                                <div class="code-box-copy">
                        <pre><code class="language-js">/** @desc Notifying a user that their account has been created. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Your account has been successfully created.');

</code></pre>
                                </div>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <p>타사 코드에서 다른 유형의 JSDoc 주석을 볼 수도 있습니다. 이 주석은<a
                            href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc 툴킷 태그
                        참조에</a>나타나지만 유효한 Google 스타일의 일부로 간주되지 않습니다.</p>
                    <h4>9.1.3 프레임 워크 별 주석</h4>
                    <p>다음 주석은 특정 프레임 워크에만 적용됩니다.</p>
                    <table class="table table-styled">
                        <thead>
                        <tr>
                            <th>뼈대</th>
                            <th>꼬리표</th>
                            <th>선적 서류 비치</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>각도 1</td>
                            <td>
                                <code>@ngInject</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                중합체
                            </td>
                            <td>
                                <code>@polymerBehavior</code>
                            </td>
                            <td>

                                <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass">https://github.com/google/closure-compiler/wiki/Polymer-Pass</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <h4> 9.1.4 표준 클로우저 컴파일러 주석에 대한 주석</h4>
                    <p>다음 태그는 표준 이었지만 지금은 사용되지 않습니다.</p>
                    <table class="table table-styled">
                        <thead>
                        <tr>
                            <th>
                                꼬리표
                            </th>
                            <th>
                                템플릿
                                및
                                예
                            </th>
                            <th>
                                기술
                            </th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>
                                <code>@expose</code>
                            </td>
                            <td>
                                <code>@expose</code>
                            </td>
                            <td>지원되지 않습니다. 사용하지 마세요. 대신<code>@export</code>및 / 또는를 사용하십시오<code>@nocollapse</code>.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>@inheritDoc</code>
                            </td>
                            <td>
                                <code>@inheritDoc</code>
                            </td>
                            <td>지원되지 않습니다. 사용하지 마세요.<code>@override</code>대신 사용하십시오 .</td>
                        </tr>
                        </tbody>
                    </table>
                </div>

                <h3 id="title9-2">9.2 일반적으로 오해 된 스타일 규칙</h3>
                <div class="content">
                    <p>JavaScript 용 Google 스타일에 대해 잘 알려지지 않았거나 일반적으로 오해 된 사실을 모아 놓은 것입니다. (다음은 진술이다; 이것은<q>
                        신화</q>의 목록이 아니다<q>.</q>)</p>
                    <ul class="list-unstyled">
                        <li>
                            <code>@author</code>원본 파일 에는 저작권 진술이나 신용 정보가 필요 하지 않습니다 . (어느 쪽도 명시 적으로 권장하지 않습니다.)
                        </li>
                        <li>먼저 생성자 (<a
                                href="https://google.github.io/styleguide/jsguide.html#features-classes-constructors">5.4.1
                            생성자</a>) 와는 별도로 클래스 구성원을 정렬하는 방법을 제어하는 ​​엄격<q>하고 빠른</q>규칙 은 없습니다 (<a
                                href="https://google.github.io/styleguide/jsguide.html#features-classes">5.4
                            클래스</a>).
                        </li>
                        <li>빈 블록은 일반적으로<code>{}</code>(<a
                                href="https://google.github.io/styleguide/jsguide.html#formatting-empty-blocks">4.1.3
                            빈 블록 : 간결함</a>) 에서와 같이 간결하게 나타낼<a
                                href="https://google.github.io/styleguide/jsguide.html#formatting-empty-blocks">수
                            있습니다</a>.
                        </li>
                        <li>줄 바꿈의 가장 중요한 지침은 다음과 같습니다. 더 높은 구문 수준에서 중단하는 것이 좋습니다 (<a
                                href="https://google.github.io/styleguide/jsguide.html#formatting-where-to-break">4.5.1
                            중단 위치</a>).
                        </li>
                        <li>비 ASCII 문자는 문자열 리터럴, 주석 및 Javadoc에서 사용할 수 있으며 실제로 동일한 유니 코드 이스케이프 (<a
                                href="https://google.github.io/styleguide/jsguide.html#non-ascii-characters">2.3.3
                            비 ASCII 문자</a>) 보다 코드를 읽기 쉽게 만들 때 권장됩니다 .
                        </li>
                    </ul>
                </div>

                <h3 id="title9-3">9.3 스타일 관련 도구</h3>
                <div class="content">
                    <p>다음 도구는 Google 스타일의 다양한 측면을 지원합니다.</p>
                    <h4>9.3.1 클로저 컴파일러</h4>
                    <p>이 프로그램은 유형 검사 및 기타 검사, 최적화 및 기타 변환 (예 : ECMAScript 6에서 ECMAScript 5로 코드 낮추기)을 수행합니다.</p>
                    <h4>9.3.2<code>clang-format</code></h4>
                    <p>이 프로그램은 자바 스크립트 소스 코드를 Google 스타일로 다시 포맷하며, 필수는 아니지만 가독성을 높이는 여러 가지 서식 지정 방법을 따릅니다.</p>
                    <p><code>clang-format</code>필요하지 않습니다. 저자는 출력물을 변경할 수 있으며, 검토자는 그러한 변경을 요청할 수 있습니다. 분쟁은 일반적인
                        방법으로 해결됩니다. 그러나 하위 트리는 로컬에서 그러한 적용을 선택하도록 선택할 수 있습니다.</p>
                    <h4>9.3.3 클로저 컴파일러 linter</h4>
                    <p>이 프로그램은 다양한 실수 및 반 패턴을 확인합니다.</p>
                    <h4> 9.3.4 적합성 프레임 워크</h4>
                    <p>JS Conformance Framework는 Closure Compiler의 일부인 도구로서 개발자는 표준 검사보다 코드 기반에 대해 실행할 추가 검사 집합을
                        지정할 수있는 간단한 방법을 제공합니다. 예를 들어, 적합성 검사는 특정 속성에 대한 액세스 또는 특정 기능에 대한 호출 또는 누락 된 유형 정보 (알 수
                        없음)를 금지 할 수 있습니다.</p>
                    <p>이러한 규칙은 일반적으로 코드베이스를 손상시킬 수있는 전역 정의, 사용<code>eval</code>또는 할당 과 같은 보안
                        패턴<code>innerHTML</code>또는 코드 품질을 향상시키기위한 느슨한 제한과 같은 중요한 제한 사항을 적용하는 데 사용됩니다 .</p>

                    <p>추가 정보는<a href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework">JS
                        준수 프레임 워크</a>의 공식 문서를 참조하십시오 .</p>
                </div>

                <h3 id="title9-4"> 9.4 기존 플랫폼의 예외</h3>
                <div class="content">
                    <h4>9.4.1 개요</h4>
                    <p>이 절에서는 현대 ECMAScript 6 구문을 코드 작성자가 사용할 수없는 경우 따라야 할 예외 및 추가 규칙에 대해 설명합니다. 권장 스타일에 대한 예외는
                        ECMAScript 6 구문이 불가능하고 여기에 설명되어있을 때 필요합니다.</p>
                    <ul class="list-unstyled">
                        <li><code>var</code>선언의 사용 이 허용됩니다.</li>
                        <li>사용<code>arguments</code>이 허용됨</li>
                        <li>기본값이없는 선택적 매개 변수는 허용됩니다.</li>
                    </ul>
                    <h4>9.4.2 사용<code>var</code></h4>
                    <h5> 9.4.2.1<code>var</code>선언은 블록 범위가 아닙니다.</h5>
                    <p><code>var</code>선언은 가장 가까운 둘러싸는 함수, 스크립트 또는 모듈의 시작 부분으로 범위가 지정됩니다. 특히<code>var</code>루프
                        내부에서 선언 을 참조하는 함수 클로저에서 예기치 않은 동작이 발생할 수 있습니다 . 다음 코드는 예제를 제공합니다.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">for (var i = 0; i < 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// logs 2, 2, 2 -- NOT 0, 1, 2
// because `iteration` is function-scoped, not local to the loop.
</code></pre>
                    </div>
                    <h5>9.4.2.2 첫 번째 사용에 가능한 한 가깝게 변수 선언</h5>
                    <p><code>var</code>선언의 범위가 둘러싸는 함수의 시작 부분에 있더라도 선언은<code>var</code>가독성을 위해 처음 사용할 때 가능한 한
                        가깝게해야합니다. 그러나<code>var</code>변수가 블록 외부에서 참조되는 경우에는 블록 안에 선언을 두지 마십시오 . 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" could be declared here, but don't do that.
    count++;
  }
  console.log(count + ' items in y');
}
</code></pre>
                    </div>
                    <h5>9.4.2.3 상수 변수에 @const 사용</h5>
                    <p><code>const</code>키워드가 사용되는 전역 선언의 경우 사용할 수있는 경우<code>var</code>대신 @const를 사용 하여 선언에 주석을
                        추가하십시오 (로컬 변수의 경우 선택적 임).</p>
                    <h4> 9.4.3 블록 범위 함수 선언을 사용하지 않는다.</h4>

                    <p>이것을 하지 마십시오 :</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">if (x) {
  function foo() {}
} </code></pre>
                    </div>
                    <p>ECMAScript 6가 블록 내에서 함수 선언을 지원하기 전에 구현 된 대부분의 JavaScript VM은 표준화되지 않았습니다. 구현은 서로 그리고 블록
                        범위 함수 선언을위한 표준 ECMAScript 6 동작과 서로 일치하지 않았습니다. ECMAScript 5 이전 버전에서는 스크립트 또는 함수의 루트 문
                        목록에 함수 선언을 허용하고 엄격 모드에서 블록 범위에서 명시 적으로 금지합니다.</p>

                    <p>일관된 동작을 얻으려면<code>var</code>함수 표현식으로 초기화 된 함수를 사용하여 블록 내에서 함수를 정의하십시오.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">if (x) {
  var foo = function() {};
}</code></pre>
                    </div>
                    <h4> 9.4.4<code>goog.provide</code>/<code>goog.require</code></h4>

                    <p><code>goog.provide</code>사용되지 않습니다.<code>goog.module</code>기존의<code>goog.provide</code>사용법이
                        있는 프로젝트에서도 모든 새 파일을 사용해야 합니다. 다음 규칙은 사전에 존재하는 goog.provide 파일에만 적용됩니다.</p>

                    <h5>9.4.4.1 요약</h5>

                    <ul class="list-unstyled">
                        <li><code>goog.provide</code>처음부터 모든 것을 놓으십시오<code>goog.require</code>. 빈 줄과 함께 제공해야합니다.
                        </li>
                        <li>알파벳 순서로 항목을 정렬합니다 (먼저 대문자).</li>
                        <li>포장<code>goog.provide</code>및<code>goog.require</code>진술 하지 마십시오 . 필요한 경우 80 열을
                            초과하십시오.
                        </li>
                        <li>최상위 기호 만 제공하십시오.</li>
                    </ul>

                    <p>2016 년 10 월 현재<code>goog.provide</code>/<code>goog.require</code>dependency management는 더
                        이상 사용되지 않습니다 .<code>goog.provide</code>이전 파일을 사용 하는 프로젝트에서도 새 파일은 모두 사용해야합니다<a
                                href="https://google.github.io/styleguide/jsguide.html#source-file-structure"><code>goog.module</code></a>.
                    </p>

                    <p><code>goog.provide</code>문장은 함께 그룹화되어 가장 먼저 배치되어야합니다. 모든<code>goog.require</code>진술을
                        따라야합니다. 두 목록은 빈 줄로 구분해야합니다.</p>

                    <p>다른 언어의 import 문과 유사<code>goog.provide</code>하며<code>goog.require</code>문이 80 열 길이 제한을
                        초과하더라도 단일 행으로 작성되어야합니다.</p>

                    <p>줄은 대문자가 먼저 오는 영문자 순으로 정렬해야합니다.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');</code></pre>
                    </div>
                    <p>한 클래스에 정의 된 모든 멤버는 같은 파일에 있어야합니다. 동일한 클래스 (예 : 열거 형, 내부 클래스 등)에 정의 된 여러 멤버가 포함 된 파일에는 최상위 클래스
                        만 제공해야합니다.</p>
                    <p>이 작업을 수행:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.provide('namespace.MyClass');</code></pre>
                    </div>
                    <p>이거 말고:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code></pre>
                    </div>
                    <p>네임 스페이스의 멤버도 제공 될 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');</code></pre>
                    </div>
                    <h5>9.4.4.2 앨리어싱<code>goog.scope</code></h5>
                    <p><code>goog.scope</code>사용되지 않습니다. 새로운 파일은<code>goog.scope</code>기존 goog.scope 사용법이있는 프로젝트에서도
                        사용해서는 안됩니다 .</p>
                    <p><code>goog.scope</code><code>goog.provide</code>/<code>goog.require</code>의존성 관리를 사용하여 코드에서
                        네임 스페이스 기호에 대한 참조를 단축하는 데 사용할 수 있습니다 .</p>
                    <p><code>goog.scope</code>파일 당 하나의 호출 만 추가 될 수 있습니다. 항상 전역 범위에 배치하십시오.</p>
                    <p>개구부<code>goog.scope(function() {</code>호출에는 정확히 하나의 공백
                        행이오고<code>goog.provide</code>서술문,<code>goog.require</code>명령문 또는 최상위 레벨 주석을 따라야합니다 . 호출은 파일의
                        마지막 행에서 닫혀 야합니다.<code>// goog.scope</code>범위의 종료 문에 추가 하십시오. 두 개의 공백으로 세미콜론과 주석을 구분하십시오.</p>
                    <p>C ++ 네임 스페이스와 마찬가지로<code>goog.scope</code>선언에서 들여 쓰지 마십시오 . 대신 0 열에서 계속하십시오.</p>
                    <p>다른 객체 (예 : 대부분의 생성자, 열거 형 및 네임 스페이스)에 다시 할당되지 않을 이름에 대해서만 별칭을 지정합니다. 이 작업을 수행하지 마십시오 (생성자의
                        별칭을 지정하는 방법은 아래 참조).</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...</code></pre>
                    </div>
                    <p>이름은 별명이있는 글로 z의 마지막 특성과 동일해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Alias new types after the constructor declaration.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Declare methods on the prototype as usual:
SomeType.prototype.findButton = function() {
  // Button as aliased above.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code></pre>
                    </div>
                </div>
            </div>
            <!-- 최상단 이동 btn -->
            <div>
                    <span id="topBtn"> <i class="glyphicon glyphicon-menu-up"></i><span
                            class="sr-only">top</span></span>
            </div>

        </div>
        <!-- END container -->

    </main>
    <!-- END main -->

</div>
<!-- END wrap -->

<!-- Include script -->
<script>
    w3.includeHTML();
</script>
</body>
</html>