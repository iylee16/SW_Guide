<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SW개발 품질가이드</title>
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/lightbox.css">
    <!-- For Include -->
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <!-- HTML5SHIV -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <![endif]-->
    <script src="../../../js/jquery-3.3.1.min.js"></script>
    <script src="../../../js/common.js"></script>
    <script src="../../../js/lightbox-plus-jquery.js"></script>
    <!-- Code Box Copy begin -->
    <link href="../../../css/code-box-copy.css" rel="stylesheet">
    <script src="../../../js/prism.min.js"></script>
    <script src="../../../js/code-box-copy.js"></script>
    <!-- Code Box Copy end -->
</head>
<body>
<!-- START wrap -->
<div id="wrap">

    <!-- START header -->
    <div id="header">
        <!-- tablet에서만 나타나는 버튼 -->
        <div class="menu-toggle-btn">
            <span class="sr-only">메뉴버튼</span>
        </div>
        <span class="logo">
            <a href="../../../index.html">
                <img src="../../../img/posco-logo.png" alt="withPOSCO 로고">
            </a>
            <span class="logo-text point">swBasic</span><span class="logo-text">SW개발 품질가이드</span>
        </span>

        <!-- site-map -->
        <div class="right-menu site-map">
            <div class="site-map-btn">
                <span class="sr-only">사이트 맵</span>
            </div>

            <div class="site-map-wrapper">
                <div class="site-map-wrapper">
                    <div class="btn close">
                        <span class="sr-only">닫기</span>
                    </div>
                    <ul>
                        <li class="title">INTRO                             <ul class="sub-menu">                                 <li><a href="../../intro/intro/intro.html">Intro</a></li>                             </ul>                         </li>

                        <li class="title">SW개발을 위한 방법론
                            <ul class="sub-menu">
                                <li>swBasic 개발방법론
                                    <ul>
                                        <li><a href="../../methodology/development/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/development/process00.html">프로세스(단계)</a></li>
                                    </ul>
                                </li>
                                <li>swBasic 테스트방법론
                                    <ul>
                                        <li><a href="../../methodology/test/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/test/process01.html">프로세스(단계)</a></li>
                                    </ul>
                                </li>
                                <li>swBasic Agile 방법
                                    <ul>
                                        <li><a href="../../methodology/agile/summary01.html">개요</a></li>
                                        <li><a href="../../methodology/agile/process01.html">프로세스(&프랙티스)</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">개발 가이드
                            <ul class="sub-menu">
                                <li><a href="../../guide/summary/summary01.html">개요</a></li>
                                <li>개발 기법
                                    <ul>
                                        <li><a href="../../guide/technique/summary01.html">요구사항 도출</a></li>
                                        <li><a href="../../guide/technique/summary02.html">요구사항 분석</a></li>
                                        <li><a href="../../guide/technique/summary03.html">요구사항 명세</a></li>
                                        <li><a href="../../guide/technique/summary04.html">요구사항 검증</a></li>
                                        <li><a href="../../guide/technique/architecture_plan.html">아키텍처 설계</a></li>
                                        <li><a href="http://ux.posco.net:7091/html/main.html">UI/UX 표준 가이드</a></li>
                                        <li><a href="../../guide/technique/teststrategy_guide.html">테스트 계획</a></li>
                                        <li><a href="../../guide/technique/testcase_guide00.html">테스트 설계</a></li>
                                        <li><a href="../../guide/technique/unittest.html">테스트 수행</a></li>
                                    </ul>
                                </li>
                                <li>개발 Coding 가이드
                                    <ul>
                                        <li><a href="../../guide/coding_guide/java.html">Coding Style Guide<br/>(convention)</a></li>
                                        <li><a href="../../guide/coding_guide/hardcoding_guide.html">HardCoding 적용 Guide</a></li>
                                        <li><a href="../../guide/coding_guide/security_weaknesses.html">Secure Coding
                                            Guide</a></li>
                                        <li><a href="../../guide/coding_guide/open_source.html">오픈소스 개발 가이드</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">개발도구
                            <ul class="sub-menu">
                                <li>개요
                                    <ul>
                                        <li><a href="../../tool/summary/summary01.html">개발 도구란</a></li>
                                    </ul>
                                </li>
                                <li>프로젝트 관리
                                    <ul>
                                        <li><a href="../../tool/all/redmine.html">Redmine</a></li>
                                    </ul>
                                </li>
                                <li>요구사항 관리
                                    <ul>
                                        <li><a href="../../tool/all/osrmt.html">OSRMT</a></li>
                                    </ul>
                                </li>
                                <li>설계/모델링
                                    <ul>
                                        <li><a href="../../tool/all/startuml.html">StarUML</a></li>
                                    </ul>
                                </li>
                                <li>형상관리
                                    <ul>
                                        <li><a href="../../tool/all/git.html">Git</a></li>
                                        <li><a href="../../tool/all/nexus.html">Nexus</a></li>
                                    </ul>
                                </li>
                                <li>빌드
                                    <ul>
                                        <li><a href="../../tool/all/maven.html">Maven</a></li>
                                    </ul>
                                </li>
                                <li>소스진단
                                    <ul>
                                        <li><a href="../../tool/all/sonarqube.html">SonarQube</a></li>
                                    </ul>
                                </li>
                                <li>단위테스트
                                    <ul>
                                        <li><a href="../../tool/all/junit.html">Junit</a></li>
                                    </ul>
                                </li>
                                <li>통합테스트
                                    <ul>
                                        <li><a href="../../tool/all/fitnesse.html">Fitness</a></li>
                                    </ul>
                                </li>
                                <li>부하테스트
                                    <ul>
                                        <li><a href="../../tool/all/jmeter.html">Jmeter</a></li>
                                    </ul>
                                </li>
                                <li>지속통합/배포
                                    <ul>
                                        <li><a href="../../tool/all/jenkins.html">Jenkins</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">품질관리
                            <ul class="sub-menu">

                                <li><a href="../../quality/guide/guide.html">품질관리 가이드</a></li>
                                <li>품질점검
                                    <ul>
                                        <li><a href="../../quality/assurance/testinspection_standard02.html">요구사항 체크리스트</a> </li> <li><a href="../../quality/assurance/testinspection_standard01.html">테스트 체크리스트</a> </li>
                                    </ul>
                                </li>
                                <li>품질지표
                                    <ul>
                                        <li><a href="../../quality/indicator/quality_indicator01.html">프로세스 품질지표</a></li>
                                        <li><a href="../../quality/indicator/quality_indicator02.html">프로덕트 품질지표</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>

                        <li class="title">다운로드
                            <ul class="sub-menu">
                                <li>SW개발을 위한 방법론
                                    <ul>
                                        <li><a href="../../download/methodology/development_template.html">swBasic 개발방법론</a></li>
                                        <li><a href="../../download/methodology/test_template.html">swBasic 테스트방법론</a></li>
                                        <li><a href="../../download/methodology/agile_template.html">swBasic Agile 방법</a></li>
                                    </ul>
                                </li>

                                <li>사내 보유 방법론
                                    <ul>
                                        <li><a href="../../download/company/our_development.html">자체개발방법론</a></li>
                                        <li><a href="../../download/company/international_development.html">대외SW개발방법론</a></li>
                                        <li><a href="../../download/company/eic_development.html">EIC 전산개발방법론</a></li>
                                        <li><a href="../../download/company/solution_development.html">솔루션개발방법론</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <!-- END header -->

    <!-- START nav -->
    <div id="nav">
        <ul class="menu-list accordion active">
            <!-- Intro -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">Intro</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../intro/intro/intro.html">Intro</a>
            </ul>

            <!-- 방법론 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">SW개발을 위한 방법론</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../methodology/development/summary01.html">swBasic 개발방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/development/summary01.html">개요</a></li>
                        <li><a href="../../methodology/development/process00.html">프로세스(절차)</a>
                            <ul class="sub-inner depth3">
                                <li><a href="../../methodology/development/process00.html">요구정의</a>
                                <li><a href="../../methodology/development/process01.html">분석</a>
                                <li><a href="../../methodology/development/process02.html">아키텍처 설계</a>
                                <li><a href="../../methodology/development/process03.html">설계</a>
                                <li><a href="../../methodology/development/process04.html">구현</a>
                                <li><a href="../../methodology/development/process05.html">테스트</a>
                                <li><a href="../../methodology/development/process06.html">인도</a>
                                <li><a href="../../methodology/development/process06.html">반복주기 관리</a>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="../../methodology/test/summary01.html">swBasic 테스트방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/test/summary01.html">개요</a></li>
                        <li><a href="../../methodology/test/process01.html">프로세스(절차)</a>
                            <ul class="sub-inner depth3">
                                <li><a href="../../methodology/test/process01.html">테스트 계획</a></li>
                                <li><a href="../../methodology/test/process02.html">테스트 설계</a></li>
                                <li><a href="../../methodology/test/process03.html">테스트 실행</a></li>
                                <li><a href="../../methodology/test/process04.html">테스트 평가</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="../../methodology/agile/process01.html">swBasic Agile 방법</a>
                    <ul class="sub-inner">
                        <li><a href="../../methodology/agile/process01.html">프로세스 (&프랙티스)</a></li>
                        <li><a href="../../methodology/agile/summary02.html">적용가이드</a></li>
                        <li><a href="../../methodology/agile/summary01.html">Agile Manifesto</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 개발 가이드 -->
            <li class="toggle accordion-toggle active-tab">
                <a class="menu-link active" href="javascript:;">개발 가이드</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu open" style="display: block">
                <li><a href="../../guide/summary/summary01.html">개요</a></li>
                <li><a href="../../guide/technique/summary01.html">개발 기법</a>
                    <ul class="sub-inner">
                        <li><a href="../../guide/technique/summary01.html">요구사항 도출</a></li>
                        <li><a href="../../guide/technique/summary02.html">요구사항 분석</a></li>
                        <li><a href="../../guide/technique/summary03.html">요구사항 명세</a></li>
                        <li><a href="../../guide/technique/summary04.html">요구사항 검증</a></li>
                        <li><a href="../../guide/technique/architecture_plan.html">아키텍처 설계</a></li>
                        <li><a href="http://ux.posco.net:7091/html/main.html">UI/UX 표준 가이드</a></li>
                        <li><a href="../../guide/technique/teststrategy_guide.html">테스트 계획</a></li>
                        <li><a href="../../guide/technique/testcase_guide00.html">테스트 설계</a></li>
                        <li><a href="../../guide/technique/unittest.html">테스트 수행</a></li>
                    </ul>
                </li>
                <li><a class="active on" href="../../guide/coding_guide/java.html">개발 Coding 가이드</a>
                    <ul class="sub-inner">
                        <li><a class="active on" href="../../guide/coding_guide/java.html">Coding Style
                            Guide(convention)</a></li>
                        <li><a href="../../guide/coding_guide/hardcoding_guide.html">HardCoding 적용 Guide</a></li>
                        <li><a href="../../guide/coding_guide/security_weaknesses.html">Secure Coding Guide</a></li>
                        <li><a href="../../guide/coding_guide/open_source.html">오픈소스 개발 가이드</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 개발도구 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">개발도구</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../tool/summary/summary01.html">개요</a><li>
                <li><a href="../../tool/all/redmine.html">프로젝트 관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/redmine.html">Redmine</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/osrmt.html">요구사항 관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/osrmt.html">OSRMT</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/startuml.html">설계/모델링</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/startuml.html">StarUML</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/git.html">형상관리</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/git.html">Git</a></li>
                        <li><a href="../../tool/all/nexus.html">Nexus</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/maven.html">빌드</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/maven.html">Maven</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/sonarqube.html">소스 진단</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/sonarqube.html">SonarQube</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/junit.html">단위테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/junit.html">Junit</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/fitnesse.html">통합테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/fitnesse.html">Fitness</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/jmeter.html">부하테스트</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/jmeter.html">Jmeter</a></li>
                    </ul>
                </li>
                <li><a href="../../tool/all/jenkins.html">지속통합/배포</a>
                    <ul class="sub-inner">
                        <li><a href="../../tool/all/jenkins.html">Jenkins</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 품질관리 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">품질관리</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">

                <li><a href="../../quality/guide/guide.html">품질관리 가이드</a></li>
                <li><a href="../../quality/assurance/testinspection_standard02.html">품질점검</a>
                    <ul class="sub-inner">
                        <li><a href="../../quality/assurance/testinspection_standard02.html">요구사항 체크리스트</a> </li> <li><a href="../../quality/assurance/testinspection_standard01.html">테스트 체크리스트</a> </li>
                    </ul>
                </li>
                <li><a href="../../quality/indicator/quality_indicator01.html">품질지표</a>
                    <ul class="sub-inner">
                        <li><a href="../../quality/indicator/quality_indicator01.html">프로젝트 품질지표</a></li>
                        <li><a href="../../quality/indicator/quality_indicator02.html">프로덕트 품질지표</a></li>
                    </ul>
                </li>
            </ul>

            <!-- 다운로드 -->
            <li class="toggle accordion-toggle">
                <a class="menu-link" href="javascript:;">다운로드</a>
            </li>
            <!-- accordion-content -->
            <ul class=" accordion-content sub-menu">
                <li><a href="../../download/methodology/development_template.html">SW개발을 위한 방법론</a>
                    <ul class="sub-inner">
                        <li><a href="../../download/methodology/development_template.html">swBasic 개발방법론</a></li>
                        <li><a href="../../download/methodology/test_template.html">swBasic 테스트방법론</a></li>
                        <li><a href="../../download/methodology/agile_template.html">swBasic Agile 방법</a></li>
                    </ul>
                </li>

                <li><a href="../../download/company/our_development.html">사내 보유 방법론</a></li>
            </ul>
        </ul>
    </div>
    <!-- END nav -->

    <!-- START main -->
    <main id="main">
        <header class="page-header-wrap">
            <div class="page-header">
                <h1>Coding Style Guide(convention)</h1>
                <!-- breadcrumb -->
                <ol class="breadcrumb">
                    <li><a href="../../intro/intro/intro.html"><span class="sr-only">Home</span></a></li>
                    <li><a href="../../download/guide/technique.html">개발 가이드</a></li>
                    <li><a href="../../guide/coding_guide/java.html">개발 Coding 가이드</a></li>
                    <li><a href="../../guide/coding_guide/java.html">Coding Style Guide(convention)</a></li>
                    <li class="active">C++</li>
                </ol>

                <ul class="top-nav-menu">
                    <li><a href="java.html">Java</a></li>
                    <li><a href="jsp.html">JSP</a></li>
                    <li><a href="javascript.html">JavaScript</a></li>
                    <li><a href="python.html">Python</a></li>
                    <li class="active"><a href="c.html">C++</a></li>
                </ul>
            </div>
        </header>

        <!-- START container -->
        <div class="container">
            <div id="accordian" class="links well">
                <dl>
                    <dt><a href="#title1">C ++ 버전</a></dt>
                    <div></div>
                </dl>
                <dl>
                    <dt>헤더 파일</dt>
                    <div class="content">
                        <dd><a href="#title2-1">독립형 헤더</a></dd>
                        <dd><a href="#title2-2">#define Guard</a></dd>
                        <dd><a href="#title2-3">전달 선언</a></dd>
                        <dd><a href="#title2-4">인라인 함수</a></dd>
                        <dd><a href="#title2-5">Includes의 이름과 순서</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt><a href="#title3">범위 지정</a></dt>
                    <div class="content">
                        <dd><a href="#title3-1">네임 스페이스</a></dd>
                        <dd><a href="#title3-2">네임 스페이스와 정적 변수</a></dd>
                        <dd><a href="#title3-3">비회원, 정적 멤버 및 전역 함수</a></dd>
                        <dd><a href="#title3-4">지역 변수</a></dd>
                        <dd><a href="#title3-5">정적 변수와 전역 변수</a></dd>
                        <dd><a href="#title3-6">thread_local 변수</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>수업</dt>
                    <div class="content">
                        <dd><a href="#title4-1">생성자에서 작업하기</a></dd>
                        <dd><a href="#title4-2">암시 적 변환</a></dd>
                        <dd><a href="#title4-3">복사 및 이동 가능 유형</a></dd>
                        <dd><a href="#title4-4">구조 대 클래스</a></dd>
                        <dd><a href="#title4-5">계승</a></dd>
                        <dd><a href="#title4-6">연산자 오버로딩</a></dd>
                        <dd><a href="#title4-7">액세스 제어</a></dd>
                        <dd><a href="#title4-8">선언 명령</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>기능들</dt>
                    <div class="content">
                        <dd><a href="#title5-1">출력 매개 변수</a></dd>
                        <dd><a href="#title5-2">짧은 함수 쓰기</a></dd>
                        <dd><a href="#title5-3">참조 인수</a></dd>
                        <dd><a href="#title5-4">함수 오버로딩</a></dd>
                        <dd><a href="#title5-5">기본 인수</a></dd>
                        <dd><a href="#title5-6">후행 반환 형식 구문</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>Google 특정 매직</dt>
                    <div class="content">
                        <dd><a href="#title6-1">소유권 및 스마트 포인터</a></dd>
                        <dd><a href="#title6-2">웃음 소리</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>기타 C ++ 기능</dt>
                    <div class="content">
                        <dd><a href="#title7-1">Rvalue References</a></dd>
                        <dd><a href="#title7-2">친구</a></dd>
                        <dd><a href="#title7-3">예외</a></dd>
                        <dd><a href="#title7-4">noexcept</a></dd>
                        <dd><a href="#title7-5">런타임 유형 정보 (RTTI)</a></dd>
                        <dd><a href="#title7-6">주조</a></dd>
                        <dd><a href="#title7-7">스트림</a></dd>
                        <dd><a href="#title7-8">사전 증가 및 예지 </a></dd>
                        <dd><a href="#title7-9">const 사용</a></dd>
                        <dd><a href="#title7-10">constexpr의 사용</a></dd>
                        <dd><a href="#title7-11">정수형</a></dd>
                        <dd><a href="#title7-12">64 비트 이식성</a></dd>
                        <dd><a href="#title7-13">전 처리기 매크로</a></dd>
                        <dd><a href="#title7-14">0 및 nullptr / NULL</a></dd>
                        <dd><a href="#title7-15">크기</a></dd>
                        <dd><a href="#title7-16">자동</a></dd>
                        <dd><a href="#title7-17">브레이스 드 이니셜 라이저 목록</a></dd>
                        <dd><a href="#title7-18">람다 식</a></dd>
                        <dd><a href="#title7-19">템플릿 메타 프로그래밍</a></dd>
                        <dd><a href="#title7-20">후원</a></dd>
                        <dd><a href="#title7-21">std :: hash</a></dd>
                        <dd><a href="#title7-22">C ++ 11 </a></dd>
                        <dd><a href="#title7-23">비표준 확장 </a></dd>
                        <dd><a href="#title7-24">별칭</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt><a href="#title8">이름 지정</a></dt>
                    <div class="content">
                        <dd><a href="#title8-1">일반 이름 지정 규칙</a></dd>
                        <dd><a href="#title8-2">파일 이름</a></dd>
                        <dd><a href="#title8-3">유형 이름</a></dd>
                        <dd><a href="#title8-4">변수 이름</a></dd>
                        <dd><a href="#title8-5">상수</a></dd>
                        <dd><a href="#title8-6">함수 이름</a></dd>
                        <dd><a href="#title8-7">네임 스페이스 이름</a></dd>
                        <dd><a href="#title8-8">열거 자 이름</a></dd>
                        <dd><a href="#title8-9">매크로 이름</a></dd>
                        <dd><a href="#title8-10">이름 지정 규칙의 예외</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>코멘트</dt>
                    <div class="content">
                        <dd><a href="#title9-1">댓글 스타일</a></dd>
                        <dd><a href="#title9-2">파일 설명</a></dd>
                        <dd><a href="#title9-3">클래스 주석</a></dd>
                        <dd><a href="#title9-4">함수 설명</a></dd>
                        <dd><a href="#title9-5">변수 설명 </a></dd>
                        <dd><a href="#title9-6">구현 코멘트 </a></dd>
                        <dd><a href="#title9-7">구두점, 철자법 및 문법 </a></dd>
                        <dd><a href="#title9-8">TODO 댓글 </a></dd>
                        <dd><a href="#title9-9">지원 중단 의견 </a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>서식 지정</dt>
                    <div class="content">
                        <dd><a href="#title10-1">선 길이</a></dd>
                        <dd><a href="#title10-2">비 ASCII 문자</a></dd>
                        <dd><a href="#title10-3">공백 대 탭</a></dd>
                        <dd><a href="#title10-4">기능 선언 및 정의</a></dd>
                        <dd><a href="#title10-5">람다 식</a></dd>
                        <dd><a href="#title10-6">함수 호출</a></dd>
                        <dd><a href="#title10-7">브레이스 드 이니셜 라이저 목록 형식</a></dd>
                        <dd><a href="#title10-8">조건부</a></dd>
                        <dd><a href="#title10-9">루프 및 스위치 문</a></dd>
                        <dd><a href="#title10-10">포인터 및 참조식</a></dd>
                        <dd><a href="#title10-11">부울 표현식</a></dd>
                        <dd><a href="#title10-12">반환 값</a></dd>
                        <dd><a href="#title10-13">변수 및 배열 초기화</a></dd>
                        <dd><a href="#title10-14">전 처리기 지시문</a></dd>
                        <dd><a href="#title10-15">클래스 형식</a></dd>
                        <dd><a href="#title10-16">생성자 이니셜 라이저 목록</a></dd>
                        <dd><a href="#title10-17">네임 스페이스 서식</a></dd>
                        <dd><a href="#title10-18">가로 공백</a></dd>
                        <dd><a href="#title10-19">세로 공백</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt>규칙 예외</dt>
                    <div class="content">
                        <dd><a href="#title11-1">기존의 부적합 코드</a></dd>
                        <dd><a href="#title11-2">Windows 코드</a></dd>
                    </div>
                </dl>
                <dl>
                    <dt><a href="#title12">분리 단어</a></dt>
                    <div></div>
                </dl>
            </div>

            <h2>소개</h2>

            <p> 본 문서는 C++ 프로그래밍 언어의 소스 코드에 대한 POSCOICT의 코딩 가이드를 정의한 것입니다.

            </p>
            <p>프로젝트가 점점 복잡해지고 규모가 커지면서 개발자가 혼자 코드를 작성하기 보다는 여러 개발자들이 함께 작업하면서 서로 협업하여 시스템을 만들어 나가는 것이 일반화되었습니다

                이러한 상호간의 공동작업이 중요해지면서 자신의 코드뿐만 아니라 타 개발자의 코드도 함께 분석하고 리뷰하여 문제점을 함께 파악하고 공동으로 해결해 나가는 경우가 많아지고 있는 추세입니다.

            </p>
            <p>이러한 개발환경에서 코드 스타일을 통일하는 것은 소스코드의 가독성을 높이고 오류의 가능성을 줄이며 개발의 생산성을 높이는데 중요한 역할을 담당하고 있습니다.

            </p>
            <p>본 가이드는 Google 스타일 가이드 기반으로 작성이 되어졌으므로 일반적 C++ 프로그래밍의 소스 코드 개발에 문제가 없으며 통상적인 C++ Coding 의 표준을 준수한다라고 볼 수가
                있습니다.

            </p>
            <p>다만, 포스코ICT 의 특정 개발시 필요한 코딩 가이드 부분은 프로젝트별 요구 사항과 환경을 고려하여 별도 표기로 추가 관리할 예정에 있습니다.

            </p>
            <p>가이드에 기술된 내용은 POSCOICT 각 사업부에서 정보시스템 구현 시 개발자들이 숙독하고 코딩 시 적용할 것을 권고합니다

                개발 프로젝트의 경우에 따라 해당 프로젝트에서 요구되어 지는 별도의 코딩 가이드가 있으면 요구되는 코딩 가이드를 우선 적용하며 본 코딩 가이드는 참조 또는 보완용으로 적용하면
                됩니다. </p>


            <h2 id="title1">C ++ 버전</h2>
            <div class="content">
                <p>현재 코드는 C ++ 11을 대상으로해야합니다. 즉, C ++ 14 또는 C ++ 17 기능을 사용하지 않아야합니다. 이 가이드의 대상 C ++ 버전은 시간이 지남에 따라
                    (공격적으로)
                    발전 할 것입니다.</p>
                <p>코드는 최신 언어 버전 (현재 C ++ 17)에서 제거 된 기능과 최신 버전의 코드가 다른 의미를 갖는 드문 경우를 피해야합니다. 일부 C ++ 기능의 사용은 제한되거나 허용되지
                    않습니다.
                    <a href="https://google.github.io/styleguide/cppguide.html#Nonstandard_Extensions">비표준 확장명을</a> 사용하지
                    마십시오 .</p>
            </div>

            <h2 id="title2">헤더 파일</h2>
            <div class="content">
                <p>일반적으로 모든 <code>.cc</code>파일에는 연관된 <code>.h</code>파일 이 있어야 합니다. unittest와 함수가 <code>.cc</code>포함 된 작은
                    파일 과
                    같은 몇 가지 일반적인 예외 가<code>main()</code>있습니다.</p>
                <p>헤더 파일을 올바르게 사용하면 코드의 가독성, 크기 및 성능에 큰 차이가 발생할 수 있습니다.</p>
                <p>다음 규칙은 헤더 파일 사용의 여러 가지 함정을 안내합니다.</p>

                <h3 id="title2-1">독립형 헤더</h3>
                <div class="content">
                    <p>헤더 파일은 자체적으로 컴파일하고 (자체적으로
                        컴파일해야합니다 <code>.h</code>. ) 끝나야 합니다. 포함시키지 않는 비 헤더
                        파일은 끝내야 <code>.inc</code>하고 아껴서 사용해야합니다 .</p>
                    <p>모든 헤더 파일은 자체
                        포함되어야합니다. 사용자와 리팩토링 도구는 헤더를 포함하기 위해 특별한 조건을 고쳐서는
                        안됩니다. 특히 헤더에는 <a
                                href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">헤더 가드</a> 가
                        있어야
                        하며 필요한 다른 모든 헤더가 포함 되어야 합니다.</p>

                    <p>템플리트 및 인라인 함수에 대한 정의를 선언과 동일한 파일에 배치하는 것이 좋습니다. 이러한 구문의 정의는이 <code>.cc</code>를 사용하는 모든 파일에 포함되어야
                        합니다. 그렇지
                        않으면 프로그램이 일부 빌드 구성에서 링크하지 못할 수 있습니다. 선언과 정의가 다른 파일에있는 경우 전자를 포함하여 후자를 포함해야합니다. 이러한 정의를 개별적으로 포함
                        된 헤더 파일
                        ( <code>-inl.h</code>) 로 이동하지 마십시오 . 이 관습은 과거에는 흔했으나 더 이상 허용되지 않았습니다.</p>
                    <p>예외적으로 모든 관련 템플릿 인수 집합에 대해 명시 적으로 인스턴스화 된 템플릿 또는 클래스의 개인 구현 세부 사항은 <code>.cc</code>템플릿을 인스턴스화하는
                        유일한 파일에 정의
                        할 수 있습니다. </p>
                    <p>드물게 포함되도록 고안된 파일이 자체 포함되지 않은 경우가 있습니다. 이들은 일반적으로 다른 파일의 중간과 같이 비정상적인 위치에 포함되도록 고안되었습니다.
                        그들은 <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">헤더 가드를</a>
                        사용하지
                        않을 수도 있고, 그들의 전제 조건을 포함하지 않을 수도 있습니다. <code>.inc</code>확장자 가있는 파일의 이름을 지정하십시오.
                        드물게 사용하고 가능한 경우 자체 포함 헤더를 선호합니다.
                    </p>
                </div>

                <h3 id="title2-2">#define Guard</h3>
                <div class="content">
                    <p><code>#define</code>여러 헤더가 포함되지 않도록 모든 헤더 파일에 가드가 있어야합니다. 심볼 이름의 형식은 다음과 같아야합니다.
                        <code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code></p>
                    <p>고유성을 보장하려면 프로젝트의 소스 트리에서 전체 경로를 기반으로해야합니다. 예를 들어 <code>foo/src/bar/baz.h</code>프로젝트 의
                        파일 <code>foo</code>에는 다음과 같은 가드가 있어야합니다.</p>
                    <pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif // FOO_BAR_BAZ_H_
</pre>
                </div>

                <h3 id="title2-3">전달 선언</h3>
                <div class="content">
                    <p>가능한 경우 앞으로 선언문을 사용하지
                        마십시오. <code>#include</code>필요한 헤더 만 있으면됩니다.</p>

                    <p>"전달 선언"은 연관된 정의가없는 클래스, 함수 또는 템플릿의 선언입니다.</p>
                    <ul class="list-unstyled">
                        <li>전달 선언은 <code>#include</code>컴파일러가 더 많은 파일을 열고 더 많은 입력을 처리하도록 강제하므로 컴파일 시간을 절약 할 수 있습니다.</li>
                        <li>전달 선언은 불필요한 재 컴파일을 줄일 수 있습니다. <code>#include</code>s는 헤더의 무관 한 변경으로 인해 코드를 더 자주 다시 컴파일하도록 강제
                            할 수 있습니다.
                        </li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>정방향 선언은 종속성을 숨길 수 있으므로 헤더가 변경 될 때 사용자 코드가 필요한 재 컴파일을 건너 뛸 수 있습니다.
                        </li>
                        <li>라이브러리에 대한 후속 변경으로 인해 앞으로 선언이 중단 될 수 있습니다. 함수 및 템플릿의 선언을 전달하면 헤더 소유자가 매개 변수 유형을 확장하거나,
                            기본값이있는 템플릿 매개 변수를 추가하거나, 새 네임 스페이스로 마이그레이션하는 등의 API에 대해 달리 호환되지 않는 변경을 할 수 없습니다.
                        </li>
                        <li>네임 스페이스에서 심볼을 전달 <code>std::</code>하면 정의되지 않은 동작이 발생합니다.
                        </li>
                        <li>전방 선언 또는 전체 <code>#include</code>가 필요한지 여부를 판별하기가 어려울 수 있습니다.
                            an <code>#include</code>을 for 선언문으로 바꾸면 코드의 의미를 조용히 바꿀 수 있습니다.
                            <div class="code-box-copy">
                                <pre><code class="language-js">      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
      </code></pre>
                            </div>
                            만일 <code>#include</code>for가 forward로 for <code>B</code>와 대치 하면 and <code>D</code>,
                            <code>test()</code>호출 <code>f(void*)</code>합니다.
                        </li>
                        <li>헤더에서 여러 기호를 선언하는 것은 머리글을 보내는 것보다 더 장황 할 수 있습니다 <code>#include</code>.</li>
                        <li>객체 멤버 대신 포인터 멤버를 사용하는 등 전달 선언을 사용하도록 코드를 구성하면 코드가 느리고 복잡해질 수 있습니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>다른 프로젝트에 정의 된 엔티티의 전달 선언을 피하십시오.</li>
                        <li>헤더 파일에 선언 된 함수를 사용할 때, 항상 <code>#include</code>그 헤더.</li>
                        <li>클래스 템플릿을 사용하는 경우 <code>#include</code>해당 헤더 파일을 사용하십시오.</li>
                    </ul>
                    <p># 헤더를 # <a href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">포함
                        할시기에</a> 대한 규칙은 <a
                            href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">Includes의
                        이름 및 순서를</a> 참조하십시오.
                    </p>
                </div>

                <h3 id="title2-4">인라인 함수</h3>
                <div class="content">
                    <p>기능이 10 줄 또는 그보다 작은 경우에만 함수를 인라인으로 정의하십시오.</p>
                    <p>컴파일러가 일반적인 함수 호출 메커니즘을 통해 호출하지 않고 인라인으로 확장 할 수 있도록 함수를 선언 할 수 있습니다.</p>
                    <p>함수를 인라이닝하면 인라인 함수가 작은 경우보다 효율적인 객체 코드를 생성 할 수 있습니다.
                        인라인 액세서, 뮤 테이터 및 기타 짧고 성능이 중요한 기능을 자유롭게 사용할 수 있습니다.</p>
                    <p>인라인을 과도하게 사용하면 실제로 프로그램이 느려질 수 있습니다. 함수의 크기에 따라 인라인하면 코드 크기가 증가하거나 감소 할 수 있습니다.
                        아주 작은 접근 자 함수를 인라인하면 대개 코드 크기가 감소하지만 매우 큰 함수를 인라인하면 코드 크기가 크게 증가 할 수 있습니다.
                        현대의 프로세서에서는 명령어 캐시를 잘 사용하기 때문에 작은 코드가 더 빠르게 실행됩니다.</p>
                    <p>괜찮은 규칙은 길이가 10 줄 이상인 경우 함수를 인라인하지 않는 것입니다. 암시적 멤버 및 기본 소멸자 호출로 인해 나타나는 것보다 종종 더 길어진 소멸자를
                        조심하십시오!</p>
                    <p>또 다른 유용한 규칙 : 일반적으로 루프 또는 switch 문을 사용하여 함수를 인라인하는 것이 비용 효과적이지 않습니다 (일반적으로 루프 또는 switch 문을 실행하지
                        않는 한).</p>
                    <p>함수가 선언 된 경우에도 항상 인라인되지는 않습니다. 예를 들어, 가상 함수와 재귀 함수는 일반적으로 인라인되지 않습니다.
                        보통 재귀 함수는 인라인이어서는 안됩니다. 가상 \함수를 인라인으로 만드는 주된 이유는 편의상 또는 접근 자 및 변경자와 같은 동작을 문서화하기 위해 클래스에 정의를
                        배치하는 것입니다.</p>
                </div>

                <h3 id="title2-5">Includes의 이름과 순서</h3>
                <div class="content">
                    <p>가독성을 높이고 숨겨진 의존성을 피하기 위해 표준
                        순서를 사용하십시오 : 관련 머리글, C 라이브러리, C ++ 라이브러리, 기타 라이브러리 '
                        <code>.h</code>,
                        프로젝트 <code>.h</code>.</p>
                    <p>
                        프로젝트의 헤더 파일은 모두 UNIX 디렉토리 바로 가기 <code>.</code>(현재 디렉토리) 또는 <code>..</code>
                        (상위 디렉토리) 를 사용하지 않고 프로젝트의 소스 디렉토리의 자손으로 나열되어야합니다
                        . 예를 들어, 다음

                        <code>google-awesome-project/src/base/logging.h</code>
                        과 같이 포함되어야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">#include "base / logging.h"</code></pre>
                    </div>
                    <p>에서 <code><var>dir/foo</var>.cc</code>또는 <code><var>dir/foo_test</var>.cc</code>, 누구의 주요 목적은 구현 또는
                        물건을 테스트하는 것입니다
                        <code><var>dir2/foo2</var>.h</code>, 다음과 같이 포함 주문 :</p>
                    <ol class="ol-styled">
                        <li><code><var>dir2/foo2</var>.h</code>.</li>
                        <li>빈 줄</li>
                        <li>C 시스템 파일.</li>
                        <li>C ++ 시스템 파일.</li>
                        <li>빈 줄</li>
                        <li>다른 라이브러리 <code>.h</code> 파일들.</li>
                        <li>프로젝트 <code>.h</code> 파일.</li>
                    </ol>
                    <p>인접한 공백 행은 모두 축소해야합니다.</p>
                    <p>우선 순위 지정을 사용하면 <code><var>dir2/foo2</var>.h</code>필요한 포함을 생략하면 빌드가 완료 <code><var>dir/foo</var>.cc</code>
                        되거나 <code><var>dir/foo</var>_test.cc</code>중단됩니다. 따라서이 규칙은 다른 패키지에있는 무고한 사람이 아닌이 파일에서 작업하는 사람들에게
                        처음으로 빌드 중단이 표시되도록합니다.</p>
                    <p><code><var>dir/foo</var>.cc</code>와 <code><var>dir2/foo2</var>.h</code>같은 디렉토리에 일반적으로 (예를 들어 있습니다
                        <code>base/basictypes_test.cc</code>과 <code>base/basictypes.h</code>),하지만 때로는 너무 다른 디렉토리에있을 수
                        있습니다.</p>
                    <p>C 호환성 헤더 <code>stddef.h</code> 는 본질적으로 C ++ 대응 <code>cstddef</code>코드와 호환 될 수 있습니다 ( ) 어느 스타일이든
                        허용되지만 기존 코드와의 일관성을 선호합니다.</p>
                    <p>각 섹션 내에서 포함 사항은 사전 순으로 정렬해야합니다. 이전 코드는이 규칙을 따르지 않을 수 있으므로 편리 할 때 수정해야합니다.</p>
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Forward_Declarations">전달 선언</a> 의
                        예외적인 경우를 제외하고는 의존하는 심볼을 정의하는 모든 헤더를 포함해야합니다 . 당신의 문자에 의존하는 경우 <code>bar.h</code>, 당신이 포함되어 있다는
                        사실에 포함되지 않습니다 <code>foo.h</code>(현재) 포함 <code>bar.h</code>포함 <code>bar.h</code> 하지 않는, 자신을
                        <code>foo.h</code>명시 적으로 당신의 기호를 제공하기 위해 의도를 보여줍니다 <code>bar.h</code>. 그러나 관련 헤더에있는 현재 포함 항목은 관련
                        항목에 다시 포함 할 필요가 없습니다 <code>cc</code>(즉, 포함 <code>foo.cc</code>에 의존 할 수 있음 <code>foo.h</code>).
                    </p>
                    <p>예를 들어, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 다음과 같이 포함 할 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"</code></pre>
                    </div>

                    <p class="exception">경우에 따라 시스템 특정 코드에는 조건부 포함이 필요합니다. 이러한 코드는 다른 포함 후에 조건부 포함을 넣을 수 있습니다. 물론 시스템 고유
                        코드는 작고 현지화 된 상태로 유지하십시오. 예:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11</code></pre>
                    </div>
                </div>
            </div>

            <h2>범위 지정</h2>
            <div class="content">
                <h3 id="title3-1">네임 스페이스</h3>
                <div class="content">
                    <p>몇 가지 예외를 제외하고는 네임 스페이스에 코드를 배치하십시오. 네임 스페이스는 프로젝트 이름과 경로에 따라 고유 한 이름을 가져야합니다.
                        <i>사용 지시어</i> (예 <i>:)를</i> 사용하지 마십시오 <code>using namespace foo</code>. 인라인 네임 스페이스를 사용하지 마십시오.
                        이름없는 네임 스페이스의 경우 이름없는 네임 <a
                                href="https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables">스페이스
                            및 정적 변수를</a> 참조하십시오.
                    </p>
                    <p>네임 스페이스는 전역 범위를 고유 한 명명 된 범위로 세분하므로 전역 범위에서 이름 충돌을 방지하는 데 유용합니다.</p>
                    <p>네임 스페이스는 대용량 프로그램에서 이름 충돌을 방지하는 방법을 제공하지만 대부분의 코드에서 합리적으로 짧은 이름을 사용할 수 있습니다.</p>
                    <p>예를 들어 두 개의 서로 다른 프로젝트가 <code>Foo</code>전역 범위에 클래스 를 갖고있는 경우 이러한 기호는 컴파일 타임이나 런타임에 충돌 할 수 있습니다. 각
                        프로젝트는 네임 스페이스에 자신의 코드를 배치, 경우 <code>project1::Foo</code> 및 <code>project2::Foo</code>각 프로젝트의 네임
                        스페이스 내에서 이제 별개의 충돌하지 않는 기호 및 코드입니다 계속 참조 할 수 있습니다 <code>Foo</code>접두사없이.</p>
                    <p>인라인 네임 스페이스는 자동으로 엔 클로징 범위에 이름을 배치합니다. 다음 스 니펫을 예로 들어 보겠습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer</code></pre>
                    </div>
                    <p>표현 <code>outer::inner::foo()</code>과
                        <code>outer::foo()</code>는 서로 바꿔 사용할 수 있습니다. 인라인 네임 스페이스는 기본적으로 버전 간 ABI 호환성을위한 것입니다.</p>
                    <p>네임 스페이스는 이름 정의가 무엇인지를 파악하는 메커니즘을 복잡하게하기 때문에 혼란 스러울 수 있습니다.</p>
                    <p>특히 이름이 선언 된 네임 스페이스로 제한되지 않기 때문에 인라인 네임 스페이스는 혼란 스러울 수 있습니다. 그것들은 더 큰 버전 관리 정책의 일부로서 만 유용합니다.</p>
                    <p>일부 상황에서는 심볼을 완전히 정규화 된 이름으로 반복적으로 참조해야합니다. 깊이 중첩 된 네임 스페이스의 경우 많은 혼란을 야기 할 수 있습니다.</p>
                    <p>네임 스페이스는 다음과 같이 사용해야합니다.</p>
                    <ul class="list-unstyled">
                        <li><a href="https://google.github.io/styleguide/cppguide.html#Namespace_Names">이름 공간 이름</a> 에
                            대한 규칙을 따르십시오 .
                        </li>
                        <li>주어진 예제와 같이 주석으로 네임 스페이스를 종료하십시오.</li>
                        <li>
                            <p>네임 스페이스는 include, <a href="https://gflags.github.io/gflags/">gflags</a> 정의 / 선언 다음에 전체 소스
                                파일을 래핑하고 다른 네임 스페이스에있는 클래스의 선언을 전달합니다.</p>

                            <div class="code-box-copy">
                                <pre><code class="language-js">// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace</code></pre>
                            </div>
                            <div class="code-box-copy">
                                <pre><code class="language-js">// In the .cc file
namespace mynamespace {

// Definition of functions is within scope of the namespace.
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace</code></pre>
                            </div>

                            <p>보다 복잡한 <code>.cc</code>파일에는 플래그 또는 사용 선언과 같은 추가 세부 사항이있을 수 있습니다.</p>

                            <div class="code-box-copy">
                                <pre><code class="language-js">#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace mynamespace {

using ::foo::bar;

...code for mynamespace...    // Code goes against the left margin.

}  // namespace mynamespace</code></pre>
                            </div>
                        </li>

                        <li>생성 된 프로토콜 메시지 코드를 네임 스페이스에 배치하려면 파일 에서 <code>package</code>지정자를 사용<code>.proto</code>하십시오.
                            자세한 내용은<a
                                    href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">프로토콜
                                버퍼 패키지</a>를 참조하십시오.
                        </li>
                        <li><code>std</code>표준 라이브러리 클래스의 forward 선언을 포함하여 네임 스페이스 에서 아무 것도 선언하지 마십시오 . 네임 스페이스의 엔티티 선언
                            <code>std</code>은 정의되지 않은 동작입니다 (예 : 이식 가능하지 않음). 엔티티를 표준 라이브러리에서 선언하려면 적절한 헤더 파일을 포함시킵니다.
                        </li>
                        <li><p>당신은 사용할 수 없습니다 <i>사용-지시를</i>네임 스페이스에서 모든 이름을 사용할 수 있도록 할 수 있습니다.</p>
                            <div class="code-box-copy">
                                <pre><code class="language-js">// Forbidden -- This pollutes the namespace.
using namespace foo;</code></pre>
                            </div>
                        </li>

                        <li><p>명시 적으로 표시된 내부
                            전용 네임 스페이스를 제외하고 헤더 파일의 네임 스페이스 범위에서 네임 <i>스페이스 별칭</i> 을 사용하지 마십시오. 헤더
                            파일의 네임 스페이스로 가져온 항목은 모두 해당 파일에서 내 보낸 공용 API의 일부가되기 때문입니다.</p>

                            <div class="code-box-copy">
                                <pre><code class="language-js">// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;</code></pre>
                            </div>

                            <div class="code-box-copy">
                                <pre><code class="language-js">// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</code></pre>
                            </div>
                        </li>
                        <li>인라인 네임 스페이스를 사용하지 마십시오.</li>
                    </ul>
                </div>

                <h3 id="title3-2">네임 스페이스와 정적 변수</h3>
                <div class="content">
                    <p><code>.cc</code>파일의 정의를 해당 파일 외부에서 참조 할 필요가없는 경우, 이름없는 네임 스페이스에 넣거나 선언하십시오 <code>static</code>.
                        <code>.h</code>파일 에서 이러한 구조 중 하나를 사용하지 마십시오 .</p>
                    <p>모든 선언은 이름없는 네임 스페이스에 배치하여 내부 연결을 부여 할 수 있습니다. 함수와 변수는 선언하여 내부 연결을 부여 할 수도 있습니다
                        <code>static</code>. 즉, 선언 한 내용에 다른 파일에서 액세스 할 수 없습니다. 다른 파일이 같은 이름의 파일을 선언하면 두 엔티티는 완전히 독립적입니다.
                    </p>
                    <p><code>.cc</code>파일 에서 내부 연결을 사용 하는 것은 다른 곳에서 참조 할 필요가없는 모든 코드에 권장됩니다. <code>.h</code>파일에 내부 연결을
                        사용하지 마십시오 .</p>
                    <p>명명 된 네임 스페이스와 같은 이름없는 네임 스페이스를 포맷합니다. 종결 주석에서 네임 스페이스 이름을 비워 둡니다.</p>

                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace {
...
}  // namespace</code></pre>
                    </div>
                </div>

                <h3 id="title3-3">비회원, 정적 멤버 및 전역 함수</h3>
                <div class="content">
                    <p>네임 스페이스에 비회원 함수를 배치하는 것이 좋습니다. 거의 전역 기능을 사용하지 마십시오. 단순히 정적 함수를 그룹화하기 위해 클래스를 사용하지 마십시오.
                        클래스의 정적 메소드는 일반적으로 클래스의 인스턴스 또는 클래스의 정적 데이터와 밀접하게 관련되어야합니다.</p>
                    <p>비회원 및 정적 멤버 함수는 일부 상황에서 유용 할 수 있습니다. 비 멤버 함수를 네임 스페이스에두면 전역 네임 스페이스를 오염시키지 않아도됩니다.</p>
                    <p>비회원 및 정적 멤버 함수는 특히 외부 리소스에 액세스하거나 중요한 종속성이있는 경우 새 클래스의 멤버로서 더 이해할 수 있습니다.</p>
                    <p>때로는 클래스 인스턴스에 바인딩되지 않은 함수를 정의하는 것이 유용합니다. 이러한 함수는 정적 멤버이거나 비 멤버 멤버 일 수 있습니다.
                        비회원 함수는 외부 변수에 의존해서는 안되며 거의 항상 네임 스페이스에 있어야합니다. 정적 멤버 함수를 그룹화하기 위해서만 클래스를 생성하지 마십시오.
                        이것은 함수 이름에 공통 접두사를 부여하는 것만 큼 다르지 않습니다. 그런 그룹화는 대개 불필요합니다.</p>
                    <p>비회원 함수를 정의하고 <code>.cc</code>파일에 필요하다면 <a
                            href="https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables">내부
                        링크</a> 를 사용 하여 범위를 제한하십시오.</p>
                </div>

                <h3 id="title3-4">지역 변수</h3>
                <div class="content">
                    <p>가능한 가장 좁은 범위에 함수의 변수를 배치하고 선언에서 변수를 초기화합니다.</p>
                    <p>C ++을 사용하면 함수에서 변수를 선언 할 수
                        있습니다. 가능한 한 지역 범위 내에서, 가능한 한 처음 사용에 가깝게 선언하도록
                        권장합니다. 이렇게하면 독자가 선언을 찾고 변수의 유형과 초기화 된 것을 쉽게 알 수
                        있습니다. 특히 선언과 할당 대신 초기화를 사용해야합니다. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int i;
i = f();      // Bad -- initialization separate from declaration.</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code
                                class="language-js">int j = g();  // Good -- declaration has initialization.</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.</code></pre>
                    </div>
                    <p>필요한 변수 <code>if</code>, <code>while</code>
                        그리고 <code>for</code>이러한 변수는 그 범위에 한정되도록 문은 일반적으로 그 문 내에서 선언해야합니다. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code
                                class="language-js">while (const char* p = strchr(str, '/')) str = p + 1;</code></pre>
                    </div>
                    <p>하나의 경고가 있습니다 : 변수가 객체 인 경우 해당 생성자는 범위에 들어가고 만들어 질 때마다 호출되며 범위를 벗어날 때마다 소멸자가 호출됩니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}</code></pre>
                    </div>
                    <p>루프 외부에서 사용되는 변수를 선언하는 것이 더 효율적일 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}</code></pre>
                    </div>
                </div>

                <h3 id="title3-5">정적 변수와 전역 변수</h3>
                <div class="content">
                    <p><a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">정적 저장
                        기간을</a> 가진 객체 는 <a href="http://en.cppreference.com/w/cpp/types/is_destructible">쉽게 파괴</a> 할 수없는
                        한 금지됩니다.
                        비공식적으로 이것은 소멸자가 구성원 및 기본 소멸자를 고려해도 아무 것도하지 않는다는 것을 의미합니다.
                        보다 공식적으로는 형식에 사용자 정의 또는 가상 소멸자가없고 모든 기본 멤버 및 비 정적 멤버가 쉽게 파괴 가능하다는 것을 의미합니다.
                        정적 함수 로컬 변수는 동적 초기화를 사용할 수 있습니다.
                        네임 스페이스 범위에서 정적 클래스 멤버 변수 또는 변수에 동적 초기화를 사용하는 것은 권장되지 않지만 제한된 경우 허용됩니다.
                        자세한 내용은 아래를 참조하십시오.</p>
                    <p>일반적으로 글로벌 변수는 선언문을 독립적으로 고려하면 이러한 요구 사항을 충족시킵니다 <code>constexpr</code>.</p>
                    <p>모든 객체에는 <dfn>저장 기간이</dfn> 있으며 이는 수명과 관련이 있습니다. 정적 저장 기간을 갖는 객체는 초기화 시점에서부터 프로그램이 끝날 때까지 생깁니다.
                        이러한 객체는 네임 스페이스 범위 ( "전역 변수")에서 변수로, 클래스의 정적 데이터 멤버로 또는 <code>static</code>지정자 로 선언 된 함수 로컬 변수로
                        나타납니다 . 함수 - 로컬 정적 변수는 컨트롤이 처음 선언을 통과 할 때 초기화됩니다. 정적 저장 기간을 가진 다른 모든 객체는 프로그램 시작의 일부로 초기화됩니다. 정적
                        저장 기간을 가진 모든
                        오브젝트는 프로그램 종료시 결합되지 않습니다 (결합되지 않은 스레드가 종료되기 전에 발생 함).</p>
                    <p>초기화는 <dfn>동적</dfn> 일 수 있습니다. 즉, 초기화하는 동안 중요한 일이 발생하지 않습니다. (예를 들어, 메모리를 할당하는 생성자 또는 현재 프로세스 ID로
                        초기화되는 변수를 고려하십시오.) 다른 종류의 초기화는 <dfn>정적</dfn>초기화입니다. 그러나 정적 초기화는 항상 정적 저장 기간 (객체가 지정된 상수 또는 0으로
                        설정된 모든 바이트로 구성된 표현으로 초기화 됨)을 갖는 객체에 발생하지만 동적 초기화는 그 이후에 발생합니다. if 필수.</p>
                    <p>전역 변수와 정적 변수는 명명 된 상수, 일부 번역 단위 내부의 보조 데이터 구조, 명령 행 플래그, 로깅, 등록 메커니즘, 백그라운드 인프라 등 많은 응용 프로그램에
                        매우유용합니다.</p>
                    <p>동적 초기화를 사용하거나 중요하지 않은 소멸자가있는 전역 변수와 정적 변수는 찾기 힘든 버그로 쉽게 이어질 수있는 복잡성을 만듭니다.
                        동적 초기화는 번역 단위 전반에 걸쳐 정렬되지 않으며, 둘 다 삭제되지 않습니다 (초기화의 역순으로 파기되는 경우 제외).
                        한 초기화가 정적 저장 기간을 가진 다른 변수를 참조 할 때, 수명주기가 시작되기 전에 (또는 수명이 끝난 후에) 객체에 액세스하게 할 수 있습니다.
                        또한, 프로그램이 종료시에 결합되지 않은 스레드를 시작하면 소멸자가 이미 실행 된 경우 해당 스레드는 수명이 끝난 후에도 객체에 액세스하려고 시도 할 수 있습니다.</p>
                    <h4>파괴 결정</h4>
                    <p>소멸자가 사소한 경우, 그들의 실행은 전혀 명령을받지 않습니다 (효과적으로 "실행"되지 않습니다).
                        그렇지 않으면 수명이 끝난 후 개체에 액세스 할 위험에 노출됩니다. 따라서 우리는 정적 저장 기간이있는 객체 만 쉽게 파괴 할 수있는 경우에만 객체를 허용합니다. 기본 유형
                        (예 : 포인터 및 <code>int</code>)은 파괴적으로 파괴 가능하며, 파괴 가능한 유형의 배열이기도합니다. 표시된 변수 <code>constexpr</code>는
                        쉽게 파손될 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">const int kNum = 10;  // allowed

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // allowed

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // allowed
}

// allowed: constexpr guarantees trivial destructor
constexpr std::array&lt;int, 3&gt; kArray = {{1, 2, 3}};</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// bad: non-trivial destructor
const string kFoo = "foo";

// bad for the same reason, even though kBar is a reference (the
// rule also applies to lifetime-extended temporary objects)
const string& kBar = StrCat("a", "b", "c");

void bar() {
  // bad: non-trivial destructor
  static std::map&lt;int, int&lt; kData = {{1, 0}, {2, 0}, {3, 0}};
}</code></pre>
                    </div>
                    <p>참조는 객체가 아니므로 파괴성에 대한 제약을받지 않습니다. 동적 초기화에 대한 제약 조건은 여전히 ​​적용됩니다. 특히, 양식의 함수 로컬 정적 참조<code>static T&amp;
                        t = *new T;</code>가 허용됩니다.</p>
                    <h4>초기화 결정</h4>
                    <p>초기화는보다 복잡한 주제입니다. 클래스 생성자가 실행되는지 여부 만 고려하면 안되기 때문에 이니셜 라이저의 평가도 고려해야하기 때문입니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int n = 5;    // fine
int m = f();  // ? (depends on f)
Foo x;        // ? (depends on Foo::Foo)
Bar y = g();  // ? (depends on g and on Bar::Bar)</code></pre>
                    </div>
                    <p>첫 번째 문장을 제외하고는 모두 우리에게 불확실한 초기화 순서가 표시됩니다.</p>
                    <p>우리가 찾고있는 개념 은 C ++ 표준의 공식 언어에서 상수 초기화 라고 합니다. 이것은 초기화 표현식이 상수 표현식이고 객체가 생성자 호출에 의해 초기화되면 생성자가로
                        지정되어야 함을 의미합니다
                        <code>constexpr</code>.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">struct Foo { constexpr Foo(int) {} };

int n = 5;  // fine, 5 is a constant expression
Foo x(2);   // fine, 2 is a constant expression and the chosen constructor is constexpr
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // fine
</code></pre>
                    </div>
                    <p>상수 초기화는 항상 허용됩니다. 정적 저장 기간 변수의 지속적인 초기화 <code>constexpr</code> 에는 가능한 속성 또는
                        속성을 표시해야 합니다. 이렇게 표시되지 않은 모든 로컬이 아닌 정적 저장 기간 변수는 동적 초기화가 있다고 가정해야하며 매우 신중하게
                        검토해야합니다.<a
                                href="https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h#L540">
                            <code>ABSL_CONST_INIT</code></a></p>

                    <p>반대로 다음과 같은 초기화 작업은 문제가됩니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Some declarations used below.
time_t time(time_t*);      // not constexpr!
int f();                   // not constexpr!
struct Bar { Bar() {} };

// Problematic initializations.
time_t m = time(nullptr);  // initializing expression not a constant expression
Foo y(f());                // ditto
Bar b;                     // chosen constructor Bar::Bar() not constexpr</code></pre>
                    </div>
                    <p>비 지역 변수의 동적 초기화는 권장되지 않으며 일반적으로 금지되어 있습니다. 그러나 프로그램 초기화가 다른 모든 초기화와 관련하여이 초기화 순서에 의존하지 않는다면이를
                        허용합니다. 이러한 제한 사항 하에서 초기화의 순서는 눈에 띄는 차이를 만들어 내지 않습니다. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int p = getpid();  // allowed, as long as no other static variable
                   // uses p in its own initialization</code></pre>
                    </div>
                    <p>정적 로컬 변수의 동적 초기화가 허용됩니다 (공통적).</p>
                    <h4>공통 패턴</h4>
                    <ul class="list-unstyled">
                        <li>전역 문자열 : 전역 또는 정적 문자열 상수가 필요한 경우 간단한 문자 배열 또는 문자열 리터럴의 첫 번째 요소에 대한 char 포인터를 사용하는 것이 좋습니다.
                            문자열 리터럴은 정적 저장 기간이 이미 있으며 일반적으로 충분합니다.
                        </li>
                        <li>지도, 세트 및 기타 동적 컨테이너 :
                            검색 대상 세트 또는 조회 테이블과 같이 고정 된 고정 콜렉션이 필요한 경우 표준 라이브러리의 동적 컨테이너를 정적 변수로 사용할 수 없습니다. 하찮은
                            소멸자. 대신 간단한 배열을 고려해보십시오. 예를 들어 int 배열 ( "int에서 int 로의 맵") 또는 쌍 (예 : <code>int</code>and 의
                            쌍)의 배열을 생각해보십시오 <code>const char*</code>. 소규모 컬렉션의 경우 선형 검색으로는 충분하고 (메모리 지역으로 인해 효율적입니다.)
                            필요한 경우 모음을 정렬 된 순서로 유지하고 이진 검색 알고리즘을 사용합니다. 표준 라이브러리에서 동적 컨테이너를 정말로 선호하는 경우,
                            아래에 설명 된대로 함수 로컬 정적 포인터를 사용해보십시오.
                        </li>
                        <li>스마트 포인터
                            ( <code>unique_ptr</code>, <code>shared_ptr</code>) : 스마트 포인터는 파기 중에 정리를
                            실행하므로 금지됩니다. 사용 사례가이 섹션에 설명 된 다른 패턴 중 하나에 맞는지
                            고려하십시오. 하나의 간단한 해결책은 동적으로 할당 된 객체에 대한 일반 포인터를 사용하고 절대
                            삭제하지 않는 것입니다 (마지막 항목 참조).
                        </li>
                        <li>사용자 정의 유형의 정적 변수 : 자신을
                            정의해야하는 유형의 정적 인 상수 데이터가 필요한 경우 유형에 사소한 소멸자와 <code>constexpr</code>생성자를
                            지정하십시오.
                        </li>
                        <li>다른 모든 방법이 실패 할 경우 포인터를
                            함수 로컬 정적 포인터 변수에 바인딩하여 개체를 동적으로 만들고 삭제할 수 없습니다.
                            <code>static const auto* const impl = new T(args...);</code>(초기화가 더 복잡한 경우 함수 또는 람다
                            식으로 이동할 수 있습니다.)
                        </li>
                    </ul>
                </div>

                <h3 id="title3-6">thread_local 변수</h3>
                <div class="content">
                    <p><code>thread_local</code>함수 내에서 선언되지 않은 변수는 컴파일 타임 상수로 초기화되어야하며이 속성 을 사용하여 강제해야 합니다. 스레드 로컬 데이터를
                        정의하는 다른 방법보다 선호하십시오.<a
                                href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
                            <code>ABSL_CONST_INIT</code></a><code>thread_local</code></p>

                    <p>C ++ 11부터는 다음과 같이 변수를 선언 할 수 있습니다 <code>thread_local</code>.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">thread_local Foo foo = ...;</code></pre>
                    </div>
                    <p>그러한 변수는 사실 객체 컬렉션이므로 다른 스레드가 액세스 할 때 실제로 다른 객체에 액세스합니다.
                        <code>thread_local</code>변수는 여러면에서 <a
                                href="https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables">정적
                            저장 기간 변수</a> 와 매우 유사 합니다. 예를 들어, 네임 스페이스 범위, 함수 내부 또는 정적 클래스 멤버로 선언 할 수 있지만 일반 클래스 멤버는 선언 할
                        수 없습니다.</p>
                    <p><code>thread_local</code>변수 인스턴스는 프로그램 시작시 한 번이 아니라 각 스레드에 대해 개별적으로 초기화되어야한다는 점을 제외하고는
                        정적 변수와 매우 비슷하게 초기화됩니다. 즉 <code>thread_local</code>, 함수 내에서 선언 된 변수는 안전하지만 다른
                        <code>thread_local</code>변수는 정적 변수와 동일한 초기화 순서 문제의 영향을받습니다 (그 외에도).</p>
                    <p><code>thread_local</code> 변수 인스턴스는 스레드가 종료되면 파괴되므로 정적 변수의 파기 순서 문제가 발생하지
                        않습니다.</p>
                    <ul class="list-unstyled">
                        <li>스레드 로컬 데이터는 기본적으로 하나의 스레드 만 액세스 할 수 있기 때문에 근본적으로 안전 <code>thread_local</code>합니다. 이는 동시
                            프로그래밍에
                            유용합니다.
                        </li>
                        <li><code>thread_local</code> 스레드 로컬 데이터를 만드는 유일한 표준 지원 방식입니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li><code>thread_local</code>변수에 액세스 하면 예측할 수없고 제어 할 수없는 양의 다른 코드가 실행될 수 있습니다.</li>
                        <li><code>thread_local</code> 변수는 효과적으로 전역 변수이며 thread-safety의 부족 이외의 전역 변수의 단점을 모두 가지고
                            있습니다.
                        </li>
                        <li><code>thread_local</code>변수에 의해 소비되는 메모리 는 실행중인 스레드의 수 (최악의 경우)에 비례하며, 이는 프로그램에서 상당히 클 수
                            있습니다.
                        </li>
                        <li>평범한 반원은 그렇게 할 수 없다 <code>thread_local</code>.</li>
                        <li><code>thread_local</code> 특정 컴파일러 내장 함수만큼 효율적이지 않을 수 있습니다.</li>
                    </ul>
                    <p><code>thread_local</code>함수 내부의 변수에는 안전성에 대한 고려 사항이 없으므로 제한없이 사용할 수 있습니다. function-scope
                        <code>thread_local</code>를 사용하여 클래스 또는 네임 스페이스 범위 를 시뮬레이션 <code>thread_local</code>하는 함수 또는 정적
                        메서드를 정의하여 이를 시뮬레이트 할 수 있습니다 .</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">Foo& MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}</code></pre>
                    </div>
                    <p><code>thread_local</code>클래스 또는 네임 스페이스 범위의 변수는 실제 컴파일 타임 상수로 초기화해야합니다 (즉, 동적 초기화가 없어야
                        함). 이를 적용하려면,
                        <code>thread_local</code>클래스 또는 네임 스페이스 범위에서 변수로 주석되어야합니다
                        (또는 ,하지만 그건 드문해야한다) :<a
                                href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
                            <code>ABSL_CONST_INIT</code></a><code>constexpr</code></p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">ABSL_CONST_INIT thread_local Foo foo = ...;</code></pre>
                    </div>
                    <p><code>thread_local</code> 스레드 로컬 데이터를 정의하는 다른 메커니즘보다 우선해야합니다.</p>
                </div>
            </div>

            <h2>클래스</h2>
            <div class="content">
                <p>클래스는 C ++의 기본 코드 단위입니다. 당연히, 우리는 광범위하게 사용합니다. 이 단락에는 클래스을 작성할 때 따라야 할 주요 사항과주의 사항이 나와 있습니다.</p>
                <h3 id="title4-1">생성자에서 작업하기</h3>
                <div class="content">
                    <p>생성자에서 가상 메서드 호출을 피하고 오류를 신호 할 수없는 경우 실패 할 수있는 초기화를 방지하십시오.</p>
                    <p>생성자 본문에서 임의의 초기화를 수행 할 수 있습니다.</p>
                    <ul class="list-unstyled">
                        <li>클래스가 초기화되었는지 여부에 대해 걱정할 필요가 없습니다.</li>
                        <li>생성자 호출에 의해 완전히 초기화 된 객체는 <code>const</code>표준 컨테이너 또는 알고리즘에서 사용하기 쉽고 사용하기가 쉽습니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>작품이 가상 함수를 호출하면 이러한 호출은 하위 클래스 구현으로 전달되지 않습니다. 나중에 클래스를 수정하면 클래스가 현재 서브 클래 싱되지 않아서 혼란을
                            야기하더라도 조용히이 문제를 일으킬 수 있습니다.
                        </li>
                        <li>생성자가 프로그램에 오류가 발생하거나 (항상 적절하지는 않음) 또는 예외 ( <a
                                href="https://google.github.io/styleguide/cppguide.html#Exceptions">금지됨</a> )를 사용하지 않고
                            오류를 알리는 쉬운 방법은 없습니다.
                        </li>
                        <li>작업이 실패하면 초기화 코드가 실패한 객체가 생겨서 <code>bool IsValid()</code>전화를 잊어 버리기 쉬운 상태 검사 메커니즘 (또는 유사)이
                            필요한 비정상적인 상태가 될 수 있습니다 .
                        </li>
                        <li>생성자의 주소를 가져올 수 없으므로 생성자에서 수행되는 작업이 다른 스레드와 같이 쉽게 전달 될 수 없습니다.</li>
                    </ul>
                    <p>생성자는 절대로 가상 함수를 호출해서는 안됩니다. 코드에 적절한 경우 프로그램을 종료하면 적절한 오류 처리 응답이 될 수 있습니다. 그렇지 않으면 <a
                            href="https://abseil.io/tips/42">TotW # 42</a><code>Init()</code> 에서 설명한대로 공장 기능 또는 방법을
                        고려하십시오 .
                        어떤 공용 메소드가 호출 될 수 있는지에 영향을주는 다른 상태가없는 오브젝트에 대한 메소드를 피하십시오
                        (이 양식의 반 조립 오브젝트는 특히 올바르게 작동하기 어렵습니다).<a
                                href="https://abseil.io/tips/42"></a><code>Init()</code></p>
                </div>

                <h3 id="title4-2">Implicit Conversions</h3>
                <div class="content">
                    <p>암시적 변환을 정의하지 마십시오. <code>explicit</code> 변환 연산자 및 단일 인수 생성자에 키워드를 사용하십시오 .</p>
                    <p>암시적 변환을 사용 하면 매개 변수 를 사용하는 함수에 인수를 전달할 때와 같이 <dfn>대상 유형</dfn> 이라고하는 다른 유형 이 예상
                        되는 경우 한 유형의 객체 ( <dfn>소스 유형</dfn> 이라고 함 )를 사용할 수 있습니다
                        .<dfn></dfn><code>int</code><code>double</code>
                    </p>
                    <p>언어로 정의 된 암시적 변환 외에도 사용자는 소스 또는 대상 유형의 클래스 정의에 적절한 멤버를 추가하여 자체적으로 정의 할 수 있습니다. 소스 유형의 암시적 변환은 대상
                        유형 (예 :) 다음에 명명된 유형 변환 연산자로 정의됩니다 <code>operator bool()</code>. 대상 유형의 암시적 변환은 소스 유형을 유일한 인수로
                        사용할 수있는 생성자 (또는 기본값이없는 인수 만)로 정의됩니다.</p>
                    <p>이 <code>explicit</code>키워드는 생성자 나 (C ​​++ 11
                        이후) 변환 연산자에 적용되어 대상 유형이 사용 시점 (예 : 캐스트)에서 명시적일 때만 사용할 수 있습니다. 이는 암시적 변환뿐만 아니라 C ++ 11의 목록
                        초기화 구문에도 적용됩니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">Func({42, 3.14});  // Error</code></pre>
                    </div>
                    <p>이러한 종류의 코드는 기술적으로 Implicit Conversions이 아니지만 언어에서는 관련 코드를 최대한 취급합니다 <code>explicit</code>.</p>
                    <ul class="list-unstyled">
                        <li>Implicit Conversions은 형식이 명백 할 때 명시 적으로 이름을 지정하지 않아도 형식을보다 유용하고 표현력있게 만들 수 있습니다.</li>
                        <li>Implicit Conversions은 이러한 단일 기능하는 경우와 같이, 행 오버 간단한 대안이 될 수있는 <code>string_view</code>파라미터는
                            별도의 과부하의 발생
                            <code>string</code>과 <code>const char*</code>.
                        </li>
                        <li>목록 초기화 구문은 객체를 초기화하는 간결하고 표현적인 방법입니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>Implicit Conversions은 대상 유형이 사용자의 예상과 일치하지 않는 유형 불일치 버그를 숨기거나 사용자가 변환이 발생하지 않는다는 것을 알 수
                            있습니다.
                        </li>
                        <li>Implicit Conversions은 특히 과부하가 발생하는 경우 실제로 코드가 호출되는 것을 덜 명확하게 만들어 코드를 읽기가 어렵게 만듭니다.</li>
                        <li>단일 인수를 취하는 생성자는 의도하지 않더라도 Implicit Type Conversions으로 실수로 사용할 수 있습니다.</li>
                        <li>단일 인수 생성자가 표시되어 있지 않으면 <code>explicit</code>Implicit Conversions을 정의 할 것인지 또는 작성자가 단순히 표시하지
                            않았는지를 알 수있는
                            확실한 방법이 없습니다.
                        </li>
                        <li>변환을 제공해야하는 유형이 항상 명확하지는 않지만 둘 다 수행하면 코드가 모호 해집니다.</li>
                        <li>목록 초기화는 대상 유형이 내재적 인 경우, 특히 목록에 단일 요소 만있는 경우 동일한 문제로 어려움을 겪을 수 있습니다.</li>
                    </ul>
                    <p>형식 변환 연산자와 단일 인수로 호출 할 수있는 생성자 <code>explicit</code>는 클래스 정의에 표시해야합니다. 예외적으로 복사 및 이동 생성자는 <code>explicit</code>형식
                        변환을 수행하지 않으므로 복사해서는 안됩니다. Implicit Conversions은 다른 유형을 투명하게 래핑하도록 설계된 유형에 필요하고 적절할 수 있습니다. 이 경우
                        프로젝트
                        리드에게 문의하여이 규칙의 포기를 요청하십시오.</p>
                    <p>단일 인수로 호출 할 수없는 생성자는 생략 할 수 있습니다 <code>explicit</code>. 단일 <code>std::initializer_list</code>매개
                        변수 를 취하는 생성자는 <code>explicit</code>복사 초기화 (예 :)를 지원하기 위해 생략해야합니다 <code>MyType m = {1, 2};</code>.
                    </p>
                </div>
            </div>

            <h3 id="title4-3">복사 및 이동 가능 유형</h3>
            <div class="content">
                <p>클래스의 공용 API는 클래스가 복사 가능하고, 이동 전용인지, 복사 불가능인지, 이동 가능인지 명시해야합니다. 이러한 작업이 귀하의 유형에 대해
                    명확하고 의미가있는 경우 복사 및 이동을 지원하십시오.</p>
                <p>움직일 수있는 타입은 일시적으로 초기화되고 할당 될 수있는 타입입니다.</p>
                <p>복사 가능한 유형은 소스 유형의 값이 변경되지 않는다는 규정에 따라 동일한 유형의 다른 객체에서 초기화되거나 할당 될 수있는 유형입니다 (정의에 따라 이동 가능).
                    <code>std::unique_ptr&lt;int&gt;</code>이동 가능하지만 복사 할 수없는 유형의 예입니다 (
                    <code>std::unique_ptr&lt;int&gt;</code>대상에 할당하는 동안 소스 값을 수정해야하기 때문에). <code>int</code>그리고 <code>string</code>또한
                    복사 가능한 가동되어 유형의 예이다. ( <code>int</code>이동 및 복사 작업이 동일하기 때문에 복사 작업 <code>string</code>보다 비용이 적게 드는 이동
                    작업이 있습니다.)</p>
                <p>사용자 정의 유형의 경우 복사 동작은 복사 생성자 및 복사 할당 연산자에 의해 정의됩니다. 이동 동작은 이동 생성자와 이동 할당 연산자
                    (있는 경우) 또는 복사 생성자와 복사 할당 연산자에 의해 정의됩니다.</p>
                <p>복사 / 이동 생성자는 상황에 따라 컴파일러에서 암시적으로 호출 할 수 있습니다 (예 : 객체를 값으로 전달할 때).</p>
                <p>복사 가능 및 이동 가능 유형의 객체는 값에 의해 전달되고 반환 될 수 있으므로 API가 더 간단하고 안전하며 일반적입니다. 포인터 나
                    참조로 객체를 전달할 때와 달리 소유권, 수명, 변경 가능성 및 유사한 문제에 혼란을 초래할 위험이 없으며 계약에서 지정할 필요가 없습니다.
                    또한 클라이언트와 구현 간의 비 로컬 상호 작용을 방지하므로 컴파일러에서이를 쉽게 이해하고 유지 관리하며 최적화 할 수 있습니다.
                    또한, 이러한 객체는 대부분의 컨테이너와 같이 가치에 의한 전달을 필요로하는 일반 API와 함께 사용할 수 있으며, 유형 구성 등의 추가 유연성을 허용합니다.</p>
                <p>복사 / 이동 생성자와 대입 연산자는 일반적으로 같은 대안을보다 정확하게 정의하기 쉽게 <code>Clone()</code>, <code>CopyFrom()</code>또는
                    <code>Swap()</code>그들이 암시적으로 또는 함께, 컴파일러에 의해 생성 될 수 있기 때문에 <code>= default</code>. 이들은 간결하며 모든 데이터
                    멤버가 복사되도록합니다. 복사 및 이동 생성자는 힙 할당이나 별도의 초기화 및 할당 단계가 필요하지 않으며 일반적으로 <a
                            href="http://en.cppreference.com/w/cpp/language/copy_elision">복사 추출</a> 과 같은 최적화를받을 수 있으므로
                    일반적으로 더 효율적 입니다.</p>
                <p>이동 작업을 통해 rvalue 객체에서 자원을 암시적으로 효율적으로 전송할 수 있습니다. 이렇게하면 경우에 따라 더 명확한 코딩
                    스타일을 사용할 수 있습니다.</p>
                <p>일부 유형은 복사 할 필요가 없으며 이러한 유형의 복사 작업을 제공하는 것은 혼란 스럽거나 무의미하거나 잘못 될 수 있습니다. 싱글 톤 객체
                    ( <code>Registerer</code>)를 나타내는 유형 , 특정 범위 ( <code>Cleanup</code>)에 묶인 객체 또는 객체 ID (
                    <code>Mutex</code>) 와 밀접하게 결합 된 객체 는 의미있게 복사 할 수 없습니다. 다형 적으로 사용되는 기본 클래스 유형의 복사 작업은 <a
                            href="https://en.wikipedia.org/wiki/Object_slicing">객체 슬라이스로</a> 이어질 수 있으므로 위험
                    <a href="https://en.wikipedia.org/wiki/Object_slicing">합니다</a> . 기본 또는 부주의하게 구현 된 복사 작업은 올바르지 않을
                    수 있으며 그 결과 버그가 혼동을 일으키고 진단하기 어려울 수 있습니다.</p>
                <p>복사 생성자는 암시적으로 호출되므로 호출을 쉽게 놓칠 수 있습니다. 이것은 참조에 의한 통과가 일반적인 것이거나 필수 인 언어에
                    익숙한 프로그래머에게는 혼란을 야기 할 수 있습니다. 또한 과도한 복사가 발생하여 성능 문제가 발생할 수 있습니다.</p>
                <p>모든 클래스의 공용 인터페이스는 클래스가 지원하는 복사 및 이동 작업을 명시해야합니다. 이것은 일반적으로 선언 <code>public</code>
                    섹션 에서 적절한 연산을 명시 적으로 선언 및 / 또는 삭제하는 형태를 취해야합니다 .</p>
                <p>특히, 복사 가능한 클래스는 명시 적으로 복사 연산을 선언해야하고, 이동 전용 클래스는 명시 적으로 이동 연산을 선언해야하며,
                    복사 불가능 / 이동 가능 클래스는 명시 적으로 복사 연산을 삭제해야합니다. 네 가지 복사 / 이동 작업 모두를 명시 적으로 선언하거나 삭제하는 것은 허용되지만
                    필수는 아닙니다. 할당 연산자를 복사하거나 이동하는 경우 해당 생성자도 제공해야합니다.</p>
                <div class="code-box-copy">
                    <pre><code class="language-js">class Copyable {
 public:
  Copyable(const Copyable& rhs) = default;
  Copyable& operator=(const Copyable& rhs) = default;

  // The implicit move operations are suppressed by the declarations above.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&& rhs);
  MoveOnly& operator=(MoveOnly&& rhs);

  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&) = delete;
  MoveOnly& operator=(const MoveOnly&) = delete;
};

class NotCopyableOrMovable {
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
  NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
      = delete;

  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
  NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
      = delete;
};</code></pre>
                </div>
                <p>이러한 선언 / 삭제는 명백한 경우에만
                    생략 될 수 있습니다. 예를 들어 기본 클래스가 복사 가능하거나 이동 가능하지 않으면 파생 클래스가 자연스럽게되지 않습니다. 비슷하게 <a
                            href="https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes">구조체</a>
                    의 복사 가능성 / 이동성은 일반적으로 데이터 멤버의 복사 가능성 / 이동성에 의해 결정됩니다 (Google 코드에서는 데이터 멤버가 공개되지 않기 때문에 클래스에는 적용되지
                    않습니다). 복사 / 이동 작업을 명시 적으로 선언하거나 삭제하면 나머지는 명확하지 않으므로이 단락이 적용되지 않습니다
                    (특히이 단원의 "클래스"에 적용되는 규칙은 선언 된 구조체에도 적용됩니다 복사 / 이동 작업 삭제).</p>

                <p>평범한 사용자에게 복사 / 이동의 의미가
                    불분명하거나 예기치 않은 비용이 발생하는 경우 유형을 복사 / 이동하지 않아야합니다. 복사 가능한
                    유형의 이동 작업은 엄격하게 성능 최적화이며 버그 및 복잡성의 잠재적 소스이므로 해당 복사 작업보다 훨씬 효율적이지 않은 한 정의하지 마십시오. 유형이 복사 조작을
                    제공하는 경우, 해당 조작의 기본 구현이 올 Y 른대로 클래스를 설계하는 것이 Y 람직합니다. 다른 코드와 마찬가지로 기본값으로 설정된 작업의 정확성을 검토하는 것을 잊지
                    마십시오.</p>

                <p>슬라이싱의 위험 때문에 파생 될 클래스의 공개 할당 연산자 또는 복사 / 이동 생성자를 제공하는 것을 피하는 것이 좋으며 (그러한 멤버와 함께 클래스에서 파생되는 것을 피하는 것이
                    더 좋음) 기본 클래스가 복사 가능해야하는 경우 공개 가상 <code>Clone()</code> 메서드 및 파생 클래스가이를 구현하는 데 사용할 수있는 보호 된 복사본 생성자를
                    제공하십시오.</p>
            </div>

            <h3 id="title4-4">구조 대 클래스</h3>
            <div class="content">
                <p><code>struct</code>데이터를 운반하는 수동 객체에만 a를 사용하십시오. 그 밖의 모든 것은 a <code>class</code>이다.</p>
                <p>the <code>struct</code>및 <code>class</code> 키워드는 C ++에서 거의 동일하게 작동합니다. 각 키워드에 의미 론적 의미를 추가하므로 정의중인
                    데이터 유형에 적절한 키워드를 사용해야합니다.</p>
                <p><code>structs</code>데이터를 전달하는 패시브 객체에 사용해야하며 관련 상수가있을 수 있지만 데이터 멤버 액세스 / 설정 외의 기능은 없습니다. 필드의 액세스 /
                    설정은 메소드 호출보다는 필드에 직접 액세스하여 수행됩니다. 방법은 동작을 제공하지 말아야하지만, 데이터 멤버를 설정하는 데 사용되어야한다 예를 들어, 생성자, 소멸자,
                    <code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code>.</p>
                <p>더 많은 기능이 필요한 경우 a <code>class</code>가 더 적절합니다. 의심 스럽다면 a <code>class</code>.</p>
                <p>STL과의 일관성 <code>struct</code>을 <code>class</code>위해 펑터 및 특성 대신에 사용할 수 있습니다.</p>
                <p>구조체와 클래스의 멤버 변수에는 <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names">다른 명명
                    규칙이</a>
                    있습니다.</p>
            </div>

            <h3 id="title4-5">계승</h3>
            <div class="content">
                <p>구성은 상속보다 더 적합합니다. 상속을 사용할 때 만들어라 <code>public</code>.</p>
                <p>하위 클래스가 기본 클래스에서 상속 받으면 기본 클래스에서 정의하는 모든 데이터 및 작업에 대한 정의가 포함됩니다. "인터페이스 상속"은
                    순수 추상 기본 클래스 (상태가 없거나 정의 된 메소드가없는 클래스)의 상속입니다. 다른 모든 상속은 "구현 상속"입니다.</p>
                <p>구현 상속은 기존 클래스를 전문화하기 때문에 기본 클래스 코드를 다시 사용하여 코드 크기를 줄입니다. 상속은 컴파일 타임 선언이기
                    때문에 개발자와 컴파일러가 작업을 이해하고 오류를 감지 할 수 있습니다.
                    인터페이스 상속을 사용하여 클래스가 특정 API를 노출하도록 프로그래밍 방식으로 적용 할 수 있습니다.
                    다시 컴파일러는 클래스가 API의 필요한 메소드를 정의하지 않을 때이 경우 오류를 감지 할 수 있습니다.</p>
                <p>구현 상속을 위해 하위 클래스를 구현하는
                    코드가 기본 클래스와 하위 클래스 사이에 분산되어 있기 때문에 구현을 이해하는 것이 어려울 수 있습니다. 하위 클래스는 가상이 아닌 함수를 재정의 할 수 없으므로 하위
                    클래스는 구현을 변경할 수 없습니다.
                </p>

                <p>일반적으로 다중 상속은 성능상의 오버
                    헤드를 부과하기 때문에 문제가됩니다 (실제로 단일 상속에서 다중 상속으로의 성능 저하는 보통에서 가상 디스패치로의 성능 저하보다 커질 수 있음). "다이아몬드 "모호성,
                    혼란,
                    그리고 명백한 버그가 발생하기 쉬운 상속 패턴.</p>
                <p>모든 상속이
                    있어야합니다 <code>public</code>. private 상속을 원할
                    경우 기본 클래스의 인스턴스를 멤버로 포함해야합니다.</p>

                <p>구현 상속을 과도하게 사용하지
                    마십시오. 작곡은 종종 더 적절합니다. 상속의 사용을 "is-a"사례로 제한하십시오 . "일종의"
                    이라고 합리적으로 말할 수있는 경우 <code>Bar</code>
                    하위 클래스 .<code>Foo</code><code>Bar</code><code>Foo</code></p>

                <p><code>protected</code>하위 클! 스에서 액세스해야하는 멤버 함수로 의 사용을 제한하십시오.
                    참고 <a href="https://google.github.io/styleguide/cppguide.html#Access_Control">데이터 멤버
                        개인이어야한다</a> .</p>
                <p>가상 함수 또는 가상 소멸자의 재정의에
                    an <code>override</code>또는 (자주 사용되지 않는) <code>final</code>지정자 중 하나만 명시 적으로 주석을 추가 합니다.
                    <code>virtual</code>재정의를 선언 할 때 사용하지 마십시오 . 이론적 근거 : 기본 클래스 가상 함수가 표시 <code>override</code>되었거나
                    <code>final</code>재정의되지 않은 함수 또는 소멸자는 컴파일되지 않으며 일반적인 오류를 잡는 데 도움이됩니다. 지정자는 문서로 제공됩니다. 지정자가
                    없으면 함수 또는 소멸자가 가상인지 여부를 확인하기 위해 해당 클래스의 모든 조상을 검사해야합니다.</p>
                <p>다중 상속은 허용되지만 다중 구현 상속은 강력히 권장되지 않습니다.</p>
            </div>

            <h3 id="title4-6">연산자 오버로딩</h3>
            <div class="content">
                <p>운영자에게 현명하게 과부하. 사용자 정의 리터럴을 만들지 마십시오.</p>
                <p>C ++ 은 매개 변수 중 하나가 사용자 정의 유형 인 경우 사용자 코드가 키워드를 사용하여
                    <a href="http://en.cppreference.com/w/cpp/language/operators">내장 연산자의 오버로드 된 버전</a> 을 <a
                            href="http://en.cppreference.com/w/cpp/language/operators">선언 할</a> 수있게
                    <code>operator</code>합니다. <code>operator</code>키워드는 사용하여 리터럴의 새로운 종류를
                    정의하는 사용자 코드를 허용
                    <code>operator""</code>하고, 같은 유형 변환 함수를 정의하기를 <code>operator
                        bool()</code>.
                </p>
                <p>연산자 오버로딩은 사용자 정의 형식이 기본 제공 형식과 동일하게 동작하도록하여 코드를보다 간결하고 직관적으로 만들 수 있습니다.
                    오버로드 연산자는 특정 작업에 대한 관용적 이름입니다 (예를 들어 <code>==</code>, <code>&lt;</code>,<code>=</code>, 및 <code>&lt;&lt;</code>),
                    및 사용자 정의 유형을 더 쉽게 읽을 수 있도록하고 그 이름을 기대 라이브러리와 상호 운용 할 수 있도록 수있는 그 규칙을 준수.</p>
                <p>사용자 정의 리터럴은 사용자 정의 유형의 객체를 만드는 데 매우 간결한 표기법입니다.</p>
                <ul class="list-unstyled">
                    <li>정확하고 일관되며 놀랄 일이없는 연산자 오버로드를 제공하려면 약간의주의가 필요하며이를 수행하지 않으면 혼동과 버그가 발생할 수 있습니다.</li>
                    <li>연산자를 과도하게 사용하면 특히 오버로드 된 연산자의 의미가 규칙을 준수하지 않는 경우 코드가 흐려질 수 있습니다.</li>
                    <li>함수 오버로딩의 위험 요소는 연산자 오버로딩과 동일하게 적용됩니다.</li>
                    <li>운영자 과부하는 값 비싼 작업이 값싼 기본 제공 작업이라는 생각으로 우리의 직감을 속일 수 있습니다.</li>
                    <li>오버로드 된 운영자를위한 호출 사이트를 찾는 데는 grep이 아닌 C ++ 구문을 인식하는 검색 도구가 필요할 수 있습니다.</li>
                    <li>오버로드 된 연산자의 인수 유형을 잘못 선택하면 컴파일러 오류가 아닌 다른 오버로드가 발생할 수 있습니다. 예를 들어, <code>foo &lt; bar</code>한 가지
                        일을 할 수도 있고 <code>&amp;foo &lt; &amp;bar</code>완전히 다른 일을 할 수도 있습니다 .
                    </li>
                    <li>특정 운전자 과부하는 본질적으로 위험합니다. 단항 <code>&amp;</code>을 오버로드 하면 오버로드 선언이 표시되는지 여부에 따라 동일한 코드가 다른 의미를 가질
                        수 있습니다. 의 과부하<code>&amp;&amp;</code>, <code>||</code>그리고 <code>,</code>내장 연산자의 평가 순서의 의미를 일치하지
                        않을 수 있습니다 (쉼표).
                    </li>
                    <li>연산자는 종종 클래스 밖에서 정의되기 때문에 동일한 파일에 서로 다른 정의가 도입 될 위험이 있습니다. 두 정의가 모두 동일한 이진 파일에 링크되어 있으면 정의되지 않은
                        동작이 발생하여 런타임 버그가 미묘하게 나타날 수 있습니다.
                    </li>
                    <li>사용자 정의 리터럴을 사용하면 숙련 된 C ++ 프로그래머에게 익숙하지 않은 새로운 구문 양식을 작성할 수 있습니다.</li>
                </ul>
                <p>의미가 명백하고 당연하며 해당 내장 연산자와 일치하는 경우에만 과부하 연산자를 정의하십시오. 예를 들어, <code>|</code>비트 스타일 또는 논리 스타일로 사용하거나
                    쉘 스타일 파이프로 사용하지 마십시오.</p>
                <p>자신의 유형에만 연산자를 정의하십시오. 좀 더 정확히 말하자면, 작동하는 유형과 동일한 헤더, .cc 파일 및 네임 스페이스에 정의하십시오. 그렇게하면 유형이있는 곳이면
                    어디에서나 연산자를 사용할 수 있으므로 여러 정의의 위험을 최소화 할 수 있습니다.
                    가능한 경우 템플릿 매개 변수에 대해이 규칙을 충족해야하므로 연산자를 템플릿으로 정의하지 마십시오.
                    연산자를 정의하는 경우 관련 연산자를 정의하고 일관되게 정의되었는지 확인하십시오. 당신이 과부하 예를 들어,<code>&lt;</code>모든 비교 연산자를
                    오버로드하고, 확인 <code>&lt;</code>하고 <code>&gt;</code>같은 인수에 대해 true를 반환하지 않습니다.</p>
                <p>비 수정 이진 연산자를 비 멤버 함수로 정의하는 것을 선호합니다.
                    이진 연산자가 클래스 멤버로 정의 된 경우 Implicit Conversions은 오른쪽 인수에는 적용되지만 왼쪽 인수에는 적용되지 않습니다.
                    <code>a &lt; b</code>컴파일 하면 사용자를 혼란스럽게 하지만<code>b &lt; a</code>그렇지 않은 사용자는 혼동을줍니다 .</p>
                <p>작업자 과부하를 피하기 위해 자신의 길을 벗어나지 마십시오. 예를 들어, 정의하는 것을 선호 <code>==</code>,<code>=</code>그리고
                    <code>&lt;&lt;</code>보다는<code>Equals()</code>,
                    <code>CopyFrom()</code>하고<code>PrintTo()</code>. 반대로 다른 라이브러리가 기대하는 것처럼 연산자 오버로드를 정의하지 마십시오. 예를
                    들어, 유형에 자연 순서가 없지만이를 a에 저장 <code>std::set</code>하려면 오버로드가 아닌 사용자 정의 비교기를 사용하십시오<code>&lt;</code>.
                </p>
                <p>너무 많이 넣지 마십시오 <code>&amp;&amp;</code>, <code>||</code>,<code>,</code>(쉼표) 또는 단항
                    <code>&amp;</code>. 과부하하지 마십시오 <code>operator""</code>. 즉, 사용자 정의 리터럴을 도입 하지 마십시오 .</p>
                <p>유형 변환 연산자는 <a href="https://google.github.io/styleguide/cppguide.html#Implicit_Conversions">암시적
                    변환</a> 에 대한 절에서 다룹니다 . <code>=</code>연산자 섹션에 덮여<a
                        href="https://google.github.io/styleguide/cppguide.html#Copy_Constructors">복사 스트</a>.
                    오버로드<code>&lt;&lt;</code>스트림을 사용하기 위해이 섹션에서 설명합니다 <a
                            href="https://google.github.io/styleguide/cppguide.html#Streams">스트림</a> . <a
                            href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">함수
                        오버로딩</a>에 대한 규칙을 참조하십시오.이 규칙은 연산자 오버로딩에도 적용됩니다.</p>
            </div>

            <h3 id="title4-7">액세스 제어</h3>
            <div class="content">
                <p>클래스의 데이터 멤버 <code>private</code>가 아닌 경우<code>static const</code>(그리고 <a
                        href="https://google.github.io/styleguide/cppguide.html#Constant_Names">상수</a>의 <a
                        href="https://google.github.io/styleguide/cppguide.html#Constant_Names">명명 규칙을</a> 따르 십시오) 클래스의
                    데이터
                    멤버를 만듭니다 .</p>

                <p>기술적 인 이유로 <a href="https://github.com/google/googletest">Google 테스트</a> 를 사용할 <code>protected</code>때
                    .cc
                    파일에있는 테스트 픽스처 클래스의 데이터 멤버를 허용합니다 .<a href="https://github.com/google/googletest"></a></p>
            </div>

            <h3 id="title4-9">선언 명령</h3>
            <div class="content">
                <p>유사한 선언을 그룹화하여 공용 부품을 더 일찍
                    배치하십시오.</p>
                <p>클래스 정의는 일반적으로 시작해야
                    <code>public:</code>다음 섹션,
                    <code>protected:</code>다음, <code>private:</code>. 비어있는 섹션은 생략하십시오.</p>
                <p>각 섹션 내에서 일반적으로 함께 선언의 유사한
                    종류의 그룹화 선호하고, 일반적으로 다음과 같은 순서로 선호 : (포함 유형 <code>typedef</code>,
                    <code>using</code>상수, 공장 함수, 생성자, 대입 연산자, 소멸자, 모든 다른 방법, 데이터 멤버 중첩 된 구조체와 클래스, 등).</p>
                <p>큰 메소드 정의를 클래스 정의에 인라인으로 두지 마십시오. 일반적으로, 사소한 또는 성능이 중요하고 매우 짧은 메소드 만 인라인으로 정의 할 수
                    있습니다. 자세한 내용은 <a href="https://google.github.io/styleguide/cppguide.html#Inline_Functions">인라인
                        함수</a> 를
                    참조하십시오.</p>
            </div>

            <h2 id="title5">기능들</h2>
            <div class="content">

                <h3 id="title5-1">출력 매개 변수</h3>
                <div class="content">
                    <p>출력 매개 변수가 아닌 반환 값 사용을 선호하십시오. 출력 전용 매개 변수가 사용되면 입력 매개 변수 다음에 나타나야합니다.</p>
                    <p>C ++ 함수의 출력은 자연스럽게 반환 값을 통해 제공되며 때로는 출력 매개 변수를 통해 제공됩니다.</p>
                    <p>출력 매개 변수 대신 반환 값을 사용하는 것이 가독성을 향상시키고 종종 동일한 성능 또는 더 나은 성능을 제공하기 때문에 사용하는 것이 좋습니다.</p>
                    <p>매개 변수는 함수에 입력되거나 함수에서 출력되거나 둘 다입니다. 입력 매개 변수는 일반적으로 값 또는<code>const</code>참조이며 출력 및 입력 / 출력 매개
                        변수는 비표준에 대한 포인터 <code>const</code>입니다.</p>
                    <p>함수 매개 변수를 주문할 때는 출력 매개 변수 앞에 모든 입력 전용 매개 변수를 넣으십시오. 특히 함수의 끝에 새 매개 변수를 추가하지 마십시오.
                        새 매개 변수입니다. 새로운 입력 전용 매개 변수를 출력 매개 변수 앞에 두십시오.</p>
                    <p>이것은 어렵고 빠른 규칙이 아닙니다. 입력 및 출력 (종종 클래스 / 구조체) 매개 변수는 물을 흐트러 뜨리며, 항상 그렇듯이 관련 함수와 일관성을 유지하려면 규칙을
                        굴절시켜야 할 수도 있습니다.</p>
                </div>

                <h3 id="title5-2">짧은 함수 쓰기</h3>
                <div class="content">
                    <p>작고 집중된 기능을 선호하십시오.</p>
                    <p>긴 함수가 때로는 적절하기 때문에 함수의 길이에는 엄격한 제한이 없습니다. 함수가 약 40 줄을 초과하는 경우 프로그램의 구조를 손상시키지 않으면 서 깨질 수 있는지
                        생각하십시오.</p>
                    <p>비록 당신의 긴 함수가 완벽하게 작동하더라도 몇 달 안에 그것을 수정하는 누군가 새로운 행동을 추가 할 수 있습니다.
                        이로 인해 발견하기 어려운 버그가 발생할 수 있습니다. 기능을 짧고 단순하게 유지하면 다른 사람들이 코드를 읽고 수정하기가 더 쉬워집니다.</p>
                    <p>일부 코드로 작업 할 때 길고 복잡한 기능을 찾을 수 있습니다. 기존 코드를 수정하여 두려워하지 마라. 그러한 함수로 작업하는 것이 어렵다는 것을 알게되면, 에러를
                        디버그하기가 어렵거나 여러 다른 상황에서 그 코드를 사용하고 싶을 때 함수를 더 작은 코드로 분해하는 것을 고려한다. 더 관리하기 쉬운 조각.</p>
                </div>

                <h3 id="title5-3">참조 인수</h3>
                <div class="content">
                    <p>왼쪽 된 참조에 의해 전달 된 모든 매개 변수에 레이블을 지정해야합니다<code>const</code>.</p>
                    <p>함수가 변수를 수정해야하는 경우 C에서, 매개 변수는 예를 들어, 포인터를 사용해야합니다 <code>int foo(int *pval)</code>. C ++에서이 함수는 참조
                        매개 변수를 대신 선언 할 수 있습니다<code>int foo(int &amp;val)</code>.</p>
                    <p>매개 변수를 참조로 정의하면 추한 코드를 피할 수<code>(*pval)++</code>있습니다. 복사 생성자와 같은 일부 응용 프로그램에 필요합니다. 포인터와 달리 null
                        포인터가 가능한 값이 아니라는 점을 분명히합니다.</p>
                    <p>참조 구문은 가치 문법이지만 포인터 의미론을 가지기 때문에 혼란 스러울 수 있습니다.</p>
                    <p>함수 매개 변수 목록 내에서 모든 참조는 다음 <code>const</code>과 같아야합니다.</p>
                    <pre>void Foo (const string &amp; in, string * out);</pre>
                    <p>사실 Google 코드에서 입력 인수는 값 또는 <code>const</code>참조이고 출력 인수는 포인터 인 매우 강력한 규칙입니다 . 입력 매개 변수는
                        <code>const</code>포인터
                        가 될 수 있지만 <code>const</code>, 관습에 따라 필요한 경우를 제외하고 는 비표준 매개 변수를 허용하지 않습니다 <code>swap()</code>.
                    </p>
                    <p>그러나 입력 매개 변수 <code>const T*</code>를 사용하는 것이 더 바람직한 경우가 <code>const T&amp;</code>있습니다. 예 :</p>
                    <ul class="list-unstyled">
                        <li>null 포인터를 전달하려고합니다.</li>
                        <li>이 함수는 포인터 또는 입력 참조를 저장합니다.</li>
                    </ul>
                    <p>대부분의 입력 매개 변수는로 지정됩니다 <code>const T&amp;</code>. <code>const T*</code>대신에 using을 사용 하면 독자에게
                        입력 내용이 어떻게 든 다르게 처리됩니다. 당신이 선택하는 경우에 따라서 <code>const T*</code>보다는 <code>const T&amp;</code>,
                        구체적인 이유에 대해 이렇게; 그렇지 않으면 독자가 존재하지 않는 설명을 찾게하여 혼란을 일으킬 수 있습니다.</p>
                </div>
            </div>

            <h3 id="title5-4">함수 오버로딩</h3>
            <div class="content">
                <p>호출 사이트를보고있는 독자가 정확히 어떤 과부하가 호출되고 있는지 정확히 파악할 필요없이 무슨 일이 일어나고 있는지 좋은 아이디어를 얻을 수있는 경우에만 오버로드 된 함수 (생성자
                    포함)를 사용하십시오.</p>
                <p>당신은 걸리고 걸리는 함수로 <code>const string&amp;</code>그것을 오버로드 하는 함수를 작성할 수 있습니다 <code>const char*</code>.
                    그러나이 경우 대신 std
                    :: string_view를 고려하십시오.</p>
                <div class="code-box-copy">
                    <pre><code class="language-js">class MyClass {
 public:
  void Analyze(const string &text);
  void Analyze(const char *text, size_t textlen);
};</code></pre>
                </div>
                <p>오버로드는 동일하게 명명 된 함수가 다른 인수를 취하도록함으로써 코드를보다 직관적으로 만들 수 있습니다. 그것은 templatized 코드에 필요할 수 있으며 방문자들에게
                    편리 할 수 ​​있습니다.</p>
                <p>const 또는 ref 한정을 기반으로하는 오버로딩은 유틸리티 코드를보다 유용하고 효율적으로 또는 둘 모두로 만들 수 있습니다. ( 더 자세한 <a
                        href="http://abseil.io/tips/148">정보는 148</a>참고 ).
                </p>
                <p>함수가 인수 유형으로 만 오버로드되는 경우 독자는 무슨 일이 일어나고 있는지 알기 위해 C ++의 복잡한 일치 규칙을 이해해야 할 수도 있습니다. 파생 클래스가 함수의 일부
                    변형 만 재정의하는 경우 많은 사람들이 상속의 의미로 혼동됩니다.</p>
                <p>변형 사이에 의미 적 차이가 없을 때 함수에 오버로드가 발생할 수 있습니다. 이러한 오버로드는 유형, 한정자 또는 인수 개수가 다를 수 있습니다. 그러나, 이러한 호출의
                    독자가 아니라, 과부하 세트의 멤버가 선택되는 알 필요가 있어야 <b>뭔가</b>설정에서 호출되고있다.
                    오버로드 세트의 모든 항목을 헤더에 단일 주석으로 문서화 할 수 있다면 잘 설계된 오버로드 세트라는 좋은 신호입니다.</p>
            </div>

            <h3 id="title5-5">기본 인수</h3>
            <div class="content">
                <p>기본값은 항상 동일한 값을 보장하는 경우 가상 함수가 아닌 경우 기본 인수가 허용됩니다. <a
                        href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">함수
                    오버로딩</a> 과 동일한 제한을 따르고 기본 인수로 얻은 가독성이 아래 단점보다 중요하지 않은 경우 오버로드 된 함수를 선호합니다.
                </p>
                <p>종종 디폴트 값을 사용하는 함수가 있지만 때로는 기본값을 대체하려고합니다. 기본 매개 변수를 사용하면 드문 예외에 대해 많은 함수를 정의하지 않고도 쉽게이 작업을 수행 할 수
                    있습니다. 함수의 오버로드와 비교할 때, 기본 인수는보다 명확한 구문을 가지고 있으며, '필수'인수와 '선택적'인수 사이의 명확한 구분이됩니다.</p>
                <p>기본 인수는 오버로드 된 함수의 의미를 얻기위한 또 다른 방법이므로 <a
                        href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">함수 오버로드가 발생하지
                    않는</a> 모든 <a
                        href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">이유가</a>적용됩니다.
                </p>
                <p>가상 함수 호출에서 인수의 기본값은 대상 객체의 정적 유형에 의해 결정되며 주어진 함수의 모든 재정의가 동일한 기본값을 선언한다는 보장은 없습니다.</p>
                <p>기본 매개 변수는 각 호출 사이트에서 재평가되어 생성 된 코드를 부 풀릴 수 있습니다. 독자는 또한 각 호출에서 변화하지 않고 기본값에서 값이 고정 될 것으로 기대할 수
                    있습니다.</p>
                <p>함수 시그니처는 종종 호출 시그니처와 일치하지 않기 때문에 함수 포인터는 기본 인수가있을 때 혼란 스럽습니다. 함수 오버로드를 추가하면 이러한 문제를 피할 수
                    있습니다.</p>
                <p>기본 인수는 가상 함수에서 제대로 작동하지 않는 경우와 지정된 기본값이 평가 시점에 따라 동일한 값으로 평가되지 않을 수있는 경우 금지됩니다. 예를 들어, 쓰지 마십시오
                    <code>void
                        f(int n = counter++);</code>.</p>
                <p>다른 경우 기본 인수는 위의 단점을 극복 할 수 있도록 함수 선언의 가독성을 향상시킬 수 있으므로 허용됩니다. 의심스러운 경우 과부하를 사용하십시오.</p>
            </div>

            <h3 id="title5-6">후행 반환 형식 구문</h3>
            <div class="content">
                <p>후행 반환 형식은 일반 구문 (선행 반환 형식)을 사용하는 것이 비현실적이거나 훨씬 쉽게 읽을 수없는 경우에만 사용하십시오.</p>
                <p>C ++은 두 가지 형태의 함수 선언을 허용합니다. 이전 형식에서는 반환 형식이 함수 이름 앞에 나타납니다. 예 :</p>
                <pre>int foo (int x);</pre>
                <p>C ++ 11에서 소개 된 새로운 형식 <code>auto</code> 은 함수 이름 앞에 키워드를 사용 하고 인수 목록 뒤에 후행 형식을 사용합니다. 예를 들어, 위의 선언은
                    다음과 같이 동등하게 작성할 수 있습니다.</p>
                <div class="code-box-copy">
                    <pre><code class="language-js">auto foo(int x) -> int;</code></pre>
                </div>
                <p>후행 반환 형식은 함수의 범위에 있습니다. 이것은 단순한 경우에는 차이가 <code>int</code>없지만 클래스 범위에서 선언 된 유형이나 함수 매개
                    변수로 작성된 유형과 같이 더 복잡한 경우에 중요합니다.</p>
                <p>후행 반환 형식은 <a href="https://google.github.io/styleguide/cppguide.html#Lambda_expressions">람다식</a> 의
                    반환 형식을 명시 적으로 지정하는 유일한 방법 입니다. 경우에 따라 컴파일러는 람다의 반환 유형을 추론 할 수 있지만 모든 경우에서이를 추론 할 수는
                    없습니다. 컴파일러가 자동으로 추론 할 수있는 경우에도 명시 적으로 명시 적으로 지정하는 것이 독자에게는 더욱 분명합니다. </p>
                <p>함수의 매개 변수 목록이 이미 나타난 후 반환 형식을 지정하는 것이 더 쉽고 가독 적이기도합니다. 반환 유형이 템플릿 매개 변수에 따라 다를 때 특히 그렇습니다. 예 :</p>
                <div class="code-box-copy">
                    <pre><code class="language-js">    template &lt;typename T, typename U&gt;
    auto add(T t, U u) -> decltype(t + u);
  </code></pre>
                </div>

                대

                <div class="code-box-copy">
                    <pre><code class="language-js">    template &lt;typename T, typename U&gt;
    decltype(declval&lt;T&&gt;() + declval&lt;U&&gt;()) add(T t, U u);
  </code></pre>
                </div>
                <p>후행 형식의 구문은 비교적 새롭고 C 및 Java와 같은 언어와 같은 C ++에서 아날로그가 없으므로 일부 독자는 익숙하지 않을 수 있습니다.</p>
                <p>기존의 코드 기반은 새로운 구문을 사용하도록 변경되지 않을 엄청난 수의 함수 선언을 가지고 있으므로 현실적인 선택은 이전 구문만을 사용하거나이 두 가지를 혼합하여 사용합니다. 단일
                    버전을 사용하면 스타일의 균일 성이 향상됩니다.</p>
                <p>대부분의 경우 반환 유형이 함수 이름 앞에 오는 경우 이전 스타일의 함수 선언을 계속 사용하십시오. 필요한 경우에만 (예 : lambdas)
                    또는 함수 매개 변수 목록 뒤에 형식을 추가하여 더 쉽게 읽을 수있는 형식으로 형식을 쓸 수있는 경우 새 후행 반환 형식 양식을 사용하십시오. 후자의 경우는 드문
                    경우입니다. <a href="https://google.github.io/styleguide/cppguide.html#Template_metaprogramming">대부분의
                        경우 낙담</a> 한 상당히 복잡한 템플릿 코드의 문제입니다.</p>
            </div>


            <h2 id="title7">기타 C ++ 기능</h2>
            <div class="content">

                <h3 id="title7-1">Rvalue References</h3>
                <div class="content">
                    <p>rvalue 참조를 사용하여 :</p>
                    <ul class="list-unstyled">
                        <li>이동 생성자를 정의하고 할당 연산자를 이동합니다.</li>
                        <li>값으로 전달하는 것보다 의미있는 성능 향상을 제공한다는 증거가 있거나 임의의 형식을 지원해야하는 오버 헤드가 낮은 일반 코드를 작성하는 경우 const &amp; 및
                            &amp;&amp;
                            변형을 사용하여 <a href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">오버로드
                                집합</a>
                            을 정의하십시오 . 조합 오버로드 집합을주의하십시오. 즉, 둘 이상의 매개 변수를 거의 오버로드하지 않습니다.
                        </li>
                        <li>일반 코드에서 '완벽한 전달'을 지원하십시오.</li>
                    </ul>
                    <p>Rvalue 참조는 임시 객체에만 바인딩 할 수있는 참조 유형입니다. 구문은 기존의 참조 구문과 유사합니다. 예를 들어, <code>void f(string&amp;&amp;
                        s);</code>인수가 문자열에 대한 rvalue 참조 인 함수를 선언합니다.</p>
                    <p>토큰 '&amp;&amp;'가 함수 매개 변수의 규정되지 않은 템플리트 인수에 적용되면 특수 템플리트 인수 공제 규칙이 적용됩니다. 이러한 참조를 전달 참조라고합니다.</p>
                    <ul class="list-unstyled">
                        <li>이동 생성자 (클래스 유형에 대한 rvalue 참조를 취하는 생성자)를 정의하면 값을 복사하는 대신 이동시킬 수 있습니다. 경우 <code>v1</code>인
                            <code>std::vector&lt;string&gt;</code>, 예를 들어, 다음 <code>auto v2(std::move(v1))</code> 아마 대신
                            많은 양의 데이터를 복사하는 몇 가지 간단한 포인터 조작에 발생합니다. 대부분의 경우 성능이 크게 향상 될 수 있습니다.
                        </li>
                        <li>Rvalue 참조는 이동
                            가능하지만 복사 할 수없는 유형을 구현할 수있게합니다. 복사 할 수있는 정의가 없지만 여전히 함수 인수로 전달하고 컨테이너에 넣을 수있는 유형에 유용 할 수
                            있습니다.
                        </li>
                        <li><code>std::move</code>같은 표준 라이브러리 유형을 효과적으로 사용하려면 필요합니다 <code>std::unique_ptr</code>.
                        </li>
                        <li><a href="https://google.github.io/styleguide/cppguide.html#Forwarding_references"></a>rvalue
                            참조 토큰을 사용하는 <a
                                    href="https://google.github.io/styleguide/cppguide.html#Forwarding_references">전달
                                참조</a> 를 사용하면 해당 인수를 다른 함수로 전달하는 일반 함수 래퍼를 작성할 수 있으며 인수가 임시 객체 및 / 또는 const인지 여부에 관계없이
                            작동합니다. 이를 '완벽한 포워딩'이라고합니다.
                        </li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>Rvalue 참조는 아직 널리 이해되지 않았습니다. 이동 생성자의 자동 합성 및 참조 축소 (예 : 함수 템플릿의 T &amp;&amp; 매개 변수에 적용되는 특수
                            규칙 참조)와 같은 규칙은 다소 모호합니다.
                        </li>
                        <li>Rvalue 참조는 종종 오용됩니다. rvalue 참조를 사용하면 인수가 함수 호출 후 유효한 지정 상태를 갖거나 이동 작업이 수행되지 않는 시그너처에서 카운터
                            직관적입니다.
                        </li>
                    </ul>
                    <p>rvalue 참조를 사용하여 이동 생성자를 정의하고 할당 연산자를 이동할 수 있습니다 ( <a
                            href="https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types">복사 가능 및 이동
                        가능 유형</a> 에서 설명 ). 이동 시멘틱스와에 대한 더 자세한 정보 는 <a
                            href="https://google.github.io/styleguide/primer#copying_moving">C ++ 입문서</a>를 참조하십시오 <code>std::move</code>.
                    </p>
                    <p>rvalue 참조를 사용하여 과부하 쌍을 정의 할 수 있습니다. 하나는 Foo &amp;&amp;를 취하고 다른 하나는 const Foo &amp;를 취합니다. 대개 선호하는
                        솔루션은 값으로 전달하는 것일 뿐이지 만 오버로드 된 함수 쌍은 때때로 더 나은 성능을 제공하며 때로는 다양한 유형을 지원해야하는 일반 코드에서 필요합니다.
                        항상 그렇듯이 : 성능 향상을 위해 더 복잡한 코드를 작성하는 경우 실제로 도움이된다는 증거를 확인하십시오.</p>
                    <p><code><a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code>완벽한 전달을
                        지원하기
                        위해 와 함께 전달 참조를 사용할 수 있습니다 .</p>
                </div>

                <h3 id="title7-2">Friends</h3>
                <div class="content">
                    <p>우리는 <code>friend</code>이유 내에서 클래스와 함수의 사용을 허용합니다 .</p>
                    <p>Friends는 일반적으로 동일한 파일에 정의되어야하므로 독자는 클래스의 비공개 멤버의 사용을 찾기 위해 다른 파일을 볼 필요가 없습니다. 의 일반적인 용도는
                        <code>friend</code>하는 것입니다 <code>FooBuilder</code>클래스의 friends <code>Foo</code>가의 내부 상태를 구성 할 수
                        있도록
                        <code>Foo</code>세계에이 상태를 노출하지 않고, 제대로을. 경우에 따라 unittest 클래스를 테스트하는 클래스의 friends로
                        만드는 것이 유용 할 수 있습니다.</p>
                    <p>Friends는 클래스의 캡슐화 경계를 확장하지만 중단하지 않습니다. 경우에 따라 다른 클래스에 하나만 액세스 권한을 부여하려는 경우 멤버를 공개로 설정하는 것보다
                        낫습니다. 그러나 대부분의 클래스은 공개 클래스을 통해서만 다른 클래스과 상호 작용해야합니다.</p>
                </div>

                <h3 id="title7-3">예외</h3>
                <div class="content">
                    <p>C ++ 예외는 사용하지 않습니다. </p>
                    <ul class="list-unstyled">
                        <li>예외를 사용하면 상위 수준의 응용 프로그램에서 오류 코드의 가려워하고 오류가 발생하기 쉬운 보류없이 깊게 중첩 된 함수에서 "발생할 수 없음"오류를 처리하는 방법을
                            결정할 수 있습니다.
                        </li>
                        <li>예외는 다른 대부분의 현대 언어에서 사용됩니다. C ++에서 이들을 사용하면 다른 사람들이 익숙한 Python,
                            Java 및 C ++와보다 일관성을 유지할 수 있습니다.
                        </li>
                        <li>일부 타사 C ++ 라이브러리는 예외를 사용하고 내부적으로 끄면 라이브러리와 통합하기가 더 어려워집니다.</li>
                        <li>예외는 생성자가 실패하는 유일한 방법입니다. 팩토리 함수 나 <code>Init()</code>메소드로 이것을
                            시뮬레이트 할 수 있지만, 이것들은 각각 힙 할당이나 새로운 "무효"상태를 필요로합니다.
                        </li>
                        <li>예외는 테스트 프레임 워크에서 매우 편리합니다.</li>
                    </ul>

                    <ul class="list-unstyled">
                        <li><code>throw</code>기존 함수에 명령문을 추가 할 때 모든 임시 호출자를 검사해야합니다. 최소한 기본 안전 예외 조항을 반드시 작성해야합니다. 그렇지
                            않으면 절대 예외를 포착해서는 안되며 결과적으로 프로그램 종료에 만족해야합니다. 예를 들어, 만약<code>f()</code>통화
                            <code>g()</code>호출<code>h()</code>및 <code>h</code>예외가 발생 <code>f</code>포착을 <code>g</code>조심해야한다
                            또는 제대로 정리하지 않을 수 있습니다.
                        </li>

                        <li>보다 일반적으로, 예외는 코드를 살펴봄으로써 프로그램의 제어 흐름을 평가하기 어렵게 만듭니다. 예상하지 못한 위치에서 함수가 반환 될 수 있습니다.
                            이로 인해 유지 보수성과 디버깅이 어려워집니다. 예외를 사용할 수있는 방법과 장소에 대한 몇 가지 규칙을 통해이 비용을 최소화 할 수 있지만 개발자가 알아야 할 것이
                            더 많은 비용을 부담해야합니다.
                        </li>
                        <li>예외 안전성은 RAII와 다른 코딩 방법을 필요로합니다. 정확한 예외 안전 코드를 쉽게 작성하려면 많은 지원 도구가 필요합니다.
                            또한 독자가 전체 콜 그래프를 이해할 필요가 없도록하려면 예외 안전 코드가 영구 상태에 쓰는 논리를 "커밋"단계로 분리해야합니다.
                            이것은 이점과 비용을 모두 가질 것입니다 (커밋을 분리하기 위해 코드를 난독 화해야하는 경우).
                            예외를 허용하면 가치가없는 경우에도 항상 비용을 지불해야합니다.
                        </li>
                        <li>예외를 설정하면 생성 된 각 바이너리에 데이터가 추가되어 컴파일 시간이 길어지고 (아마 약간) 주소 공간 압력이 증가 할 수 있습니다.</li>
                        <li>예외를 사용할 수있게되면 개발자가 적절하지 않을 때 던져 버리거나 안전하지 않을 때 복구 할 수 있습니다.
                            예를 들어 잘못된 사용자 입력으로 인해 예외가 발생해서는 안됩니다. 이러한 제한을 문서화하려면 스타일 가이드를 더 오래 사용해야합니다.
                        </li>
                    </ul>
                    <p>그들의 얼굴에, 예외를 사용하는 것의 이점은 특히 새로운 프로젝트에서 비용보다 중요합니다.
                        그러나 기존 코드의 경우 예외를 도입하면 모든 종속 코드에 영향을 미칩니다. 예외가 새 프로젝트 이상으로 전달 될 수있는 경우 새 프로젝트를 기존의 예외없는 코드에 통합하는
                        것도 문제가됩니다. Google의 기존 C ++ 코드는 예외를 처리 할 준비가되어 있지 않으므로 예외를 생성하는 새 코드를 채택하는 것은 비교적 어렵습니다.</p>
                    <p>Google의 기존 코드가 예외 허용치가 아니므로 예외 사용 비용은 새 프로젝트의 비용보다 다소 높습니다.
                        변환 프로세스가 느리고 오류가 발생하기 쉽습니다. 우리는 오류 코드 및 어설 션과 같은 예외에 사용할 수있는 대안이 상당한 부담을 초래한다고 생각하지 않습니다.</p>
                    <p>예외 사용에 대한 우리의 조언은 철학적 또는 도덕적 근거가 아니라 실제적인 것에 근거합니다. Google은 오픈 소스 프로젝트를 Google에서 사용하기를 원하고 그러한
                        프로젝트가 예외를 사용하는 경우 그렇게하기 어렵 기 때문에 Google 오픈 소스 프로젝트의 예외 사항에 대해서도 조언해야합니다.
                        처음부터 다시해야만한다면 상황이 달라질 수 있습니다.</p>
                    <p>이러한 금지는 같은 C ++ 11에 추가 된 예외 처리와 관련된 기능을 적용<code>std::exception_ptr</code>하고<code>std::nested_exception</code>.
                    </p>
                    <p>이 <a href="https://google.github.io/styleguide/cppguide.html#Windows_Code">예외</a> Windows 코드에 대한이
                        규칙 (의도 웃기)에가.</p>
                </div>

                <h3 id="title7-4">noexcept</h3>
                <div class="content">
                    <p><code>noexcept</code>유용하고 정확한시기를 지정 하십시오.</p>
                    <p>이 <code>noexcept</code>지정자는 함수가 예외를 throw하는지 여부를 지정하는 데 사용됩니다. 표시된 함수에서 예외가 이탈
                        <code>noexcept</code>하면 프로그램이를 통해 충돌 <code>std::terminate</code>합니다.</p>
                    <p><code>noexcept</code>연산자는 표현식이 예외를 던지지 선언되고있는 경우에 true를 돌려줍니다 컴파일시 검사를 수행합니다.</p>
                    <ul class="list-unstyled">
                        <li>이동 생성자를 지정 <code>noexcept</code> 하면 성능이 향상되는 경우가 있습니다 (예 : <code>std::vector&lt;T&gt;::resize()</code>T의
                            이동 생성자 인 경우 객체를 복사하는 것이 아니라 이동) <code>noexcept</code>.
                        </li>
                        <li><code>noexcept</code>함수를 지정 하면 예외가 활성화 된 환경에서 컴파일러 최적화를 트리거 할 수 있습니다.
                            예를 들어 컴파일러는 <code>noexcept</code>지정자 로 인해 예외가 throw 될 수 없다는 것을 알고있는 경우 스택 되감기를위한 추가 코드를 생성 할
                            필요가
                            없습니다.
                        </li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>이 가이드 다음에 예외가 사용되지 않는 프로젝트에서는 <code>noexcept</code>지정자가 정확하고 어떤 정확성을 의미 하는지를 정의하기 어렵습니다.
                        </li>
                        <li>불가능한 것은 아니지만 <code>noexcept</code> 호출자가 신뢰할 수있는 보장을 없애기 때문에 실행을 취소 하기가 어렵지 않습니다.
                        </li>
                    </ul>

                    <p><code>noexcept</code>의도 한 기능의 의미를 정확하게 반영하면
                        성능에 유용 할 때 사용할 수 있습니다 . 즉, 함수 본문에서 예외가 발생하면 치명적인 오류가 발생합니다. <code>noexcept</code>이동 생성자에서 의미있는
                        성능
                        이점이 있다고 가정 할 수 있습니다 . <code>noexcept</code>다른 기능 을 지정하여 성능이 크게 향상
                        된다고 생각되면 프로젝트 리드와상의하십시오.</p>

                    <p><code>noexcept</code>예외가 완전히 비활성화 된 경우 (예 :
                        대부분의 Google C ++ 환경) 무조건 조건을 선호 합니다. 그렇지
                        않으면 <code>noexcept</code>함수가 잠재적으로 throw 할 수있는 몇 가지 경우에만 false를 평가하는 방식으로 조건이
                        간단한 조건부 지정자를 사용 하십시오. 테스트에는 관련
                        연산이 던져 질지 (예 : <code>std::is_nothrow_move_constructible</code>움직이는 객체를위한) 또는 할당이 던질
                        수 있는지 여부에 대한 유형 특성 검사
                        (예
                        :<code>absl::default_allocator_is_nothrow</code>표준 기본 할당의
                        경우). 많은 경우에 예외에 대한 유일한 가능한 원인은 할당 실패입니다 (우리는 생성자가 할당
                        실패로 인해 예외를 제외하고 던져서는 안된다고 믿습니다). 예외적 인 상황이 아닌 치명적인 오류로 메모리 고갈을 처리하는 것이 적절한 많은 애플리케이션이 있습니다
                        프로그램에서
                        복구를 시도해야합니다. 다른 잠재적 인 실패에 대해서도 가능한 모든 예외 발생 시나리오를 지원하는
                        것보다 인터페이스 단순성에 우선 순위를 두어야 <code>noexcept</code>합니다. 예를 들어 해시 함수가 던져 넣을 수 있는지 여부에 따라 복잡한 절을 작성하는
                        대신 구성 요소가 던지는 해시 함수 및 그것을 무조건적으로 만든다
                        <code>noexcept</code>.</p>
                </div>

                <h3 id="title7-5">런타임 유형 정보 (RTTI)</h3>
                <div class="content">
                    <p>런타임 유형 정보 (RTTI)를 사용하지 마십시오.</p>
                    <p>RTTI를 사용하면 프로그래머는 런타임에
                        객체의 C ++ 클래스를 질의 할 수 있습니다. <code>typeid</code>또는
                        을 사용하여 수행됩니다 <code>dynamic_cast</code>.</p>
                    <p>런타임에 개체 유형을 쿼리하면 디자인 문제가 자주 발생합니다. 런타임에 객체의 유형을 알아야하는 경우가 종종 클래스 계층 구조의 설계에
                        결함이 있음을 나타냅니다.</p>
                    <p>RTTI를 면밀히 사용하면 코드를 유지 관리하기가 어렵습니다. 코드를 통해 분산 된 유형 기반 의사 결정 트리 또는 스위치 명령문으로
                        이어질 수 있으며,이 모든 변경 사항은 추가 변경시 검토해야합니다.</p>
                    <p>RTTI의 표준 대안 (아래에 설명 됨)은 문제의 클래스 계층 구조를 수정하거나 다시 설계해야합니다. 때로는 이러한 수정은 실행 불가능하거나
                        바람직하지 않습니다. 특히 널리 사용되거나 성숙한 코드의 경우.</p>
                    <p>RTTI는 일부 단위 테스트에서 유용 할 수 있습니다. 예를 들어, 새로 생성 된 객체에 예상되는 동적 유형이 있는지 확인해야하는 팩토리
                        클래스의 테스트에 유용합니다. 또한 객체와 객체 사이의 관계를 관리하는 데 유용합니다.</p>
                    <p>RTTI는 여러 추상 객체를 고려할 때 유용합니다. 중히 여기다</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == nullptr)
    return false;
  ...
}</code></pre>
                    </div>
                    <p>RTTI는 합법적 인 용도로 사용되지만 남용되기 쉽기 때문에 사용시주의해야합니다.
                        unittest에서는 자유롭게 사용할 수 있지만 가능한 경우 다른 코드에서는 사용하지 마십시오. 특히, 새로운 코드에서 RTTI를 사용하기 전에 두 번 생각하십시오.
                        객체의 클래스에 따라 다르게 동작하는 코드를 작성해야하는 경우 유형을 쿼리하는 다음 방법 중 하나를 고려하십시오.</p>
                    <ul class="list-unstyled">
                        <li>가상 메소드는 특정 서브 클래스 유형에 따라 다른 코드 경로를 실행하는 기본 방법입니다. 이것은 객체 자체 내에 작업을 넣습니다.</li>
                        <li>작품이 객체 외부에 있고 일부 처리 코드에 속한 경우 방문자 디자인 패턴과 같은 이중 디스패치 솔루션을 고려하십시오. 이것은
                            객체 자체가 아닌 시설이 내장형 시스템을 사용하여 클래스 유형을 결정할 수있게합니다.
                        </li>
                    </ul>
                    <p>프로그램의 논리가 기본 클래스의 주어진 인스턴스가 실제로 특정 파생 클래스의 인스턴스라는 것을 보장 할 때, a <code>dynamic_cast</code>는 객체에서
                        자유롭게 사용될 수 있습니다. 일반적으로 <code>static_cast</code>이러한 상황에서 대안으로 사용할 수 있습니다 .</p>
                    <p>유형을 기반으로 한 의사 결정 트리는 코드가 잘못된 경로에 있음을 보여줍니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...</code></pre>
                    </div>
                    <p>이와 같은 코드는 일반적으로 추가 하위 클래스가 클래스 계층에 추가 될 때 중단됩니다. 또한 하위 클래스의 속성이 변경되면 영향을받는
                        모든 코드 세그먼트를 찾아서 수정하기가 어렵습니다.</p>
                    <p>RTTI와 유사한 해결 방법을 직접 구현하지 마십시오. RTTI에 대한 인수는 유형 태그가있는 클래스 계층 구조와 같은 대안에
                        적용됩니다. 또한, 해결 방법은 진실한 의도를 가장합니다.</p>
                </div>

                <h3 id="title7-6">주조</h3>
                <div class="content">
                    <p>같은 <code>static_cast&lt;float&gt;(double_value)</code>산술 형식의 변환에 대한 C ++ 스타일의 캐스트 또는 중괄호
                        초기화를
                        사용하십시오 <code>int64 y = int64{1} &lt;&lt;
                            42</code>. <code>int y = (int)x</code>또는 같은 캐스트 형식을 사용하지 마십시오
                        <code>int y = int(x)</code>(그러나 후자는 클래스 유형의 생성자를 호출 할 때 괜찮습니다).</p>
                    <p> C ++은 캐스팅 작업의 유형을 구분하는 C와 다른 캐스팅 시스템을 도입했습니다.</p>
                    <p>C 캐스트의 문제점은 작업의 모호성입니다. 때로는 전환 (예 <code>(int)3.5</code>:)을하고 있고 때로는 캐스트 (예 :)를하고 <code>(int)"hello"</code>있습니다.
                        브레이스 초기화 및 C ++ 캐스트는 종종 이러한 모호성을 피할 수 있습니다. 또한 C ++ 캐스트는 검색 할 때 더 잘 보입니다.</p>
                    <p>C ++ 스타일의 캐스트 구문은 길고 복잡합니다.</p>
                    <p>C 스타일의 캐스트는 사용하지 마십시오. 대신 명시 적 유형 변환이 필요할 때 이러한 C ++ 스타일 캐스트를 사용하십시오.</p>
                    <ul class="list-unstyled">
                        <li>산술 타입 (예 :)을 변환하려면
                            중괄호 초기화를 사용하십시오 <code>int64{x}</code>. 변환이 정보 손실을
                            초래할 수있는 경우 코드가 컴파일되지 않으므로 가장 안전한 방법입니다. 구문도
                            간결합니다.
                        </li>
                        <li><code>static_cast</code>값 변환을 수행하는 C 스타일의
                            캐스트와 동일하게 사용하십시오 . 클래스에서 수퍼 클래스로 명시 적으로 포인터를 업스트림해야하거나 수퍼 클래스에서 서브 클래스로 포인터를
                            명시 적으로 캐스트해야하는 경우에 사용하십시오. 이 마지막 경우에는 객체가 실제로 하위
                            클래스의 인스턴스인지 확인해야합니다.
                        </li>
                        <li>한정자 <code>const_cast</code>를 제거 할 때
                            사용 <code>const</code>하십시오
                            ( <a href="https://google.github.io/styleguide/cppguide.html#Use_of_const">const</a> 참조
                            ).
                        </li>
                        <li><code>reinterpret_cast</code>정수 및 기타 포인터 유형간에 포인터
                            유형의 안전하지 않은 변환을 수행하는 데 사용 합니다. 자신이하고있는
                            일을 알고 있고 별칭 문제를 이해하는 경우에만 이것을 사용하십시오.
                        </li>
                    </ul>
                    <p><a
                            href="https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_">
                        RTTI</a>
                        사용에 대한 지침 은 <a
                                href="https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_">RTTI
                            섹션</a> 을
                        참조하십시오 <code>dynamic_cast</code>.</p>

                </div>

                <h3 id="title7-7">스트림</h3>
                <div class="content">
                    <p>스트림을 적절하게 사용하고 "간단한"용도에 충실하십시오. <code>&lt;&lt;</code>값을 나타내는 유형에만 스트리밍 할 수 있도록 오버로드 하고 구현 세부 사항이
                        아닌 사용자가 볼 수있는 값만 씁니다.</p>
                    <p>스트림은 C ++의 표준 I / O 추상화로, 표준 헤더로 예시됩니다 <code>&lt;iostream&gt;</code>.
                        이들은 Google 코드에서 널리 사용되지만 디버그 로깅 및 테스트 진단에만 사용됩니다.</p>
                    <p><code>&lt;&lt;</code>및 <code>&gt;&gt;</code>
                        스트림 운영자는 쉽게 배운 형식의 I / O, 휴대용, 재사용 및 확장을위한 API를 제공합니다.
                        <code>printf</code>반대로 <code>string</code>사용자 정의 유형에 대해서는 아무런 언급 도하지 않고 지원하지도 않으며 이식성이 매우 뛰어납니다.
                        <code>printf</code>또한이 함수의 수많은 다른 버전 중에서 선택해야하고 수십 개의 변환 지정자를 탐색해야합니다.</p>
                    <p>스트림은 콘솔 I / O를 통해 먼저 수준의 지원을 제공 <code>std::cin</code>, <code>std::cout</code>,
                        <code>std::cerr</code>,와 <code>std::clog</code>. C API도 마찬가지지만 수동으로 입력을 버퍼링해야하므로 방해가됩니다.</p>
                    <ul class="list-unstyled">
                        <li>스트림 포맷은 스트림의 상태를 변경하여 구성 할 수 있습니다. 이러한 변형은 영구적이므로 코드의 동작은 스트림의 이전
                            전체 기록에 의해 영향을받을 수 있습니다. 다른 코드가 코드를 건드릴 때마다 알려진 상태로 복원하지 않는 한.
                            사용자 코드는 기본 제공 상태를 수정할 수있을뿐만 아니라 등록 시스템을 통해 새로운 상태 변수 및 동작을 추가 할 수 있습니다.
                        </li>
                        <li>위의 문제, 코드 및 데이터가 스트리밍 코드에서 혼합되는 방식 및 연산자 오버로드 (예상되는 것보다 다른 과부하를 선택할 수 있음)로 인해 스트림 출력을 정밀하게
                            제어하기가 어렵습니다.
                        </li>
                        <li><code>&lt;&lt;</code>연산자 체인을 통해 출력물을 만드는 관행은 코드에 단어 순서를 부여하고 스트림의 현지화 지원에 <a
                                href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">
                            결함이</a> 있기 때문에 국제화를 방해 합니다.
                        </li>
                        <li>스트림 API는 미묘하고 복잡하기 때문에 프로그래머는 효과적으로 사용하기 위해 경험을 개발해야합니다.</li>
                        <li>많은 오버로드를 해결하는 <code>&lt;&lt;</code>것은 컴파일러에게는 매우 비용이 많이 든다.
                            대규모 코드베이스에서 널리 사용되는 경우 파싱 및 의미 분석 시간의 20%를 소비 할 수 있습니다.
                        </li>
                    </ul>
                    <p>스트림이 작업을위한 최상의 도구 일 때만 스트림을 사용하십시오. 이것은 일반적으로 I / O가 임시적이고, 로컬이며, 사람이 읽을 수 있고
                        최종 사용자가 아닌 다른 개발자를 대상으로하는 경우입니다. 주위의 코드 및 코드베이스 전체와 일관성을 유지하십시오. 문제가 해결 된 도구가있는 경우 대신 해당 도구를
                        사용하십시오. 특히 로깅 라이브러리는 일반적으로 진단 출력 보다 <code>std::cerr</code>또는 <code>std::clog</code>진단
                        출력용 <code>absl/strings</code> 으로 더 적합하며, 보통 또는 그와 동등한 라이브러리 가 일반적으로보다 나은 선택 <code>std::stringstream</code>입니다.
                    </p>
                    <p>외부 사용자를 대면하거나 신뢰할 수없는 데이터를 처리하는 I / O에는 스트림을 사용하지 마십시오. 대신 적절한 템플릿 라이브러리를 찾아서 사용하여 국제화, 현지화 및 보안
                        강화와 같은 문제를 처리하십시오.</p>
                    <p>당신이 스트림을 사용한다면, 같은 (오류 상태 제외) 스트림 API의 상태 부분을 방지 <code>imbue()</code>,
                        <code>xalloc()</code>및 <code>register_callback()</code>. <code>absl/strings</code>숫자 기수, 정밀도 또는
                        패딩과 같은 형식 세부 정보를 제어하려면 스트림 조작자 또는 서식 플래그 대신 명시 적 포맷 함수 (예 : 참조 )를 사용하십시오.</p>
                    <p><code>&lt;&lt;</code>유형이 값을 나타내는 경우에만 유형의 스트리밍 연산자로 오버로드 하고 해당 값 <code>&lt;&lt;</code>의 사람이 읽을
                        수있는 문자열 표현을 작성합니다. 출력에 구현 세부 사항이 드러나지 않도록하십시오 <code>&lt;&lt;</code>. 디버깅을 위해 객체 내부를 인쇄해야하는 경우 대신
                        명명 된 함수를 사용하십시오 ( <code>DebugString()</code>가장 일반적인 규칙은 이름 이 지정된 메서드 입니다).</p>
                </div>

                <h3 id="title7-8">사전 증가 및 예지</h3>
                <div class="content">
                    <p><code>++i</code>증가 및 감소 연산자의 접두어 form ( )을 이터레이터 및
                        기타 템플릿 객체에 사용하십시오.</p>
                    <p>변수가 증가 ( <code>++i</code>또는 <code>i++</code>)되거나 감소되거나
                        ( <code>--i</code>또는 <code>i--</code>) 식의 값이 사용되지 않으면 사전 증가
                        (감소) 또는 후 증가 (감소) 여부를 결정해야합니다.</p>
                    <p>반환 값을 무시하면 "이전"양식
                        ( <code>++i</code>)은 "게시"양식 ( <code>i++</code>) 보다 효율성이 떨어지며 더
                        효율적입니다. 이는 후행 증가 (또는 감소)에 사본의
                        작성 <code>i</code>이 필요하기 때문에 표현식의
                        값입니다. 만약 <code>i</code>iterator 나 다른 스칼라
                        타입이 아니라면 , 복사 <code>i</code>
                        비용이 많이 든다. 값이 무시 될 때 두 가지 유형의 증가가 동일하게 작동하므로 항상 미리
                        증가하지 않는 이유는 무엇입니까?</p>
                    <p>전통적으로, 표현 값이 사용되지 않을 때,
                        특히 <code>for</code>루프 에서 사후 증가를 사용하는
                        C 언어가 개발되었습니다
                        . 어떤
                        사람들 은 영어와 마찬가지로 "subject"( <code>i</code>)가
                        "동사"( <code>++</code>) 앞에 있기 때문에 읽기 쉬운 포스트 증가를 찾습니다 .</p>
                    <p>단순한 스칼라 (비 객체) 값의 경우
                        하나의 형식을 선호 할 이유가 없으며 둘 중 하나를 허용합니다. 이터레이터 및 기타 템플릿 유형의
                        경우 사전 증가를 사용하십시오.</p>
                </div>

                <h3 id="title7-9">const 사용</h3>
                <div class="content">
                    <p><code>const</code>그것이 의미가있을 때마다 사용하십시오 . C ++ 11
                        <code>constexpr</code>에서는 const를 일부 사용하는 경우 더 나은 선택입니다.</p>
                    <p>선언 된 변수와
                        매개 <code>const</code>변수는 변수가 변경되지 않았 음을 나타 내기 위해 키워드 앞에 올 수 있습니다 (예
                        :) <code>const int foo</code>. 클래스 함수는 <code>const</code>클래스 멤버 변수의 상태를 변경하지 않는
                        함수를 나타내는 한정자를 가질 수 있습니다 (예 :) <code>class Foo { int
                            Bar(char c) const; };</code>.</p>
                    <p>사람들이 변수를 사용하는 방법을 쉽게
                        이해할 수 있습니다. 컴파일러가 더 나은 형식 검사를 수행하고 더 나은 코드를 생성 할 수
                        있습니다. 사람들이 자신의 변수를 수정하는 방법이 제한적이라는 것을 알고 있기 때문에 사람들이
                        프로그램의 정확성을 확신하도록 도와줍니다. 멀티 스레드 프로그램에서 잠금없이 사용할 수있는 기능을
                        사람들에게 알려줍니다.</p>
                    <p><code>const</code>바이러스
                        성입니다 : <code>const</code>변수를 함수에 전달하면
                        해당 함수가 <code>const</code>프로토 타입에 있어야합니다 (또는 변수에 a가
                        필요합니다 <code>const_cast</code>). 라이브러리 함수를 호출 할
                        때 특히 문제가 될 수 있습니다.</p>
                    <p><code>const</code>변수,
                        데이터 멤버, 메소드 및 인수는 컴파일 타임 유형 검사 수준을 추가합니다. 오류를 가능한 한 빨리
                        감지하는 것이 좋습니다. 따라서 다음과 같이 사용하는 것이 좋습니다
                        <code>const</code>.</p>
                    <ul class="list-unstyled">
                        <li>함수가 참조 또는 포인터에 의해 전달 된 인수를 수정하지 않는다고 보증하는 경우 해당 함수 매개 변수는 각각 참조 대상 const ( <code>const T&amp;</code>)
                            또는 포인터 대 const ( ) 이어야합니다 <code>const T*</code>.
                        </li>
                        <li><code>const</code>가능할 때마다 메소드를 선언 하십시오. 접근자는 거의 항상 있어야 <code>const</code>합니다. 다른 메소드는
                            데이터 멤버를 수정하지 않고 비 - <code>const</code>메소드를 호출하지 않고 데이터 멤버에 <code>const</code>포인터가 아닌
                            <code>const</code>참조를 반환 하지 않는 경우 const 여야합니다.
                        </li>
                        <li><code>const</code> 구축 후 수정할 필요가 없을 때마다 데이터 멤버를 만드는 것을 고려하십시오.</li>
                    </ul>
                    <p><code>mutable</code>키워드는 허용하지만, 스레드와 함께 사용하면 안전하지 않은, 그래서 스레드 안전을 신중하게 먼저 고려되어야한다.</p>
                    <h4>const를 넣을 곳</h4>
                    <p>어떤 사람들은이 양식 <code>int const *foo</code> 을 선호합니다 <code>const int* foo</code>. 그들은 더 일관성이 있기 때문에
                        이것이 더 읽기 쉽다고 주장한다. 그것은 그것이 <code>const</code>기술하고있는 대상 을 항상 뒤 따르는 규칙을 유지한다 . 그러나이 일관성 인수는 대부분의
                        <code>const</code>표현식에 단 하나만있는 포인터 기반 표현식이 거의없는 코드베이스에는 적용되지 않으며 <code>const</code>기본 값에 적용됩니다.
                        이러한 경우 유지 관리의 일관성이 없습니다. (가) 퍼팅 <code>const</code>는 "형용사"(퍼팅에서 영어를 따르기 때문에 첫번째 것은 틀림없이 더 읽을
                        <code>const</code>은 "명사"전에) ( <code>int</code>).</p>
                    <p>즉, <code>const</code>먼저 퍼팅하는 것이 좋지만 필요하지는 않습니다. 그러나 주위의 코드와 일관성을 유지하십시오!</p>
                </div>

                <h3 id="title7-10">constexpr의 사용</h3>
                <div class="content">
                    <p>C ++ 11에서는 <code>constexpr</code>실제 상수를 정의하거나 상수 초기화를 보장 하는 데 사용합니다.</p>
                    <p>일부 변수는 <code>constexpr</code> 변수가 참 상수, 즉 컴파일 / 링크 시간에 고정되어 있음을 나타 내기 위해 선언 될 수
                        있습니다 . 변수 <code>constexpr</code>를 정의 할 때 사용할 수있는 함수와 생성자를 선언 할 수 있습니다 <code>constexpr</code>.
                    </p>
                    <p>의 사용은 <code>constexpr</code>리터럴이 아닌 부동 소수점 표현식으로 상수의 정의 를 가능하게합니다. 사용자 정의 유형의 상수 정의; 함수 호출로 상수
                        정의.</p>
                    <p>뭔가를 constexpr로 성급하게 표시하면 나중에 다운 그레이드해야하는 경우 마이그레이션 문제가 발생할 수 있습니다. constexpr
                        함수 및 생성자에서 허용되는 것에 대한 현재 제한은이 정의에서 모호한 해결 방법을 유도 할 수 있습니다.</p>
                    <p><code>constexpr</code>정의는 인터페이스의 상수 부분에 대한보다 강력한 사양을 가능하게합니다. <code>constexpr</code>참 상수와 해당 정의를
                        지원하는 함수를 지정하는 데 사용하십시오 . 함수 정의를 복합화하여 사용하지 마십시오 <code>constexpr</code>. <code>constexpr</code>인라이닝을
                        강제 하지 마십시오.</p>
                </div>

                <h3 id="title7-11">정수형</h3>
                <div class="content">
                    <p>기본 제공 C ++ 정수 유형 중 유일하게 사용되는 정수 유형입니다 <code>int</code>. 프로그램이 다른 크기의 변수를
                        필요로한다면,에서 <code>&lt;stdint.h&gt;</code>와 같은 정확한 너비 정수 유형을 사용하십시오 <code>int16_t</code>. 변수가 2 ^
                        31 (2GiB)보다
                        크거나 같을 수있는 값을 나타내면와 같은 64 비트 유형을 사용하십시오
                        <code>int64_t</code>. 귀하의 가치가 너무 큰 경우가
                        아니더라도 <code>int</code>더 큰 유형이 필요할 수도있는 중간 계산에 사용될 수 있음 을 명심하십시오 . 의심스러운 경우 더 큰 유형을
                        선택하십시오.</p>
                    <p>C ++은 정수형의 크기를 지정하지 않습니다 <code>int</code>. 일반적으로 사람들 <code>short</code>은 16 비트,
                        <code>int</code>32 비트, <code>long</code>32 비트 및 <code>long long</code>64 비트 라고 가정합니다 .</p>
                    <p>선언의 통일성. </p>
                    <p>C ++의 정수 타입의 크기는 컴파일러와 아키텍처에 따라 달라질 수 있습니다.</p>
                    <p><code>&lt;stdint.h&gt;</code>같은 유형을 정의 <code>int16_t</code>, <code>uint32_t</code>,
                        <code>int64_t</code>당신은 항상 우선하여 그 사용해야하는 등 <code>short</code>, <code>unsigned
                            long long</code>당신이 정수의 크기에 대한 보증을 필요로 할 때 등을들 수있다. C 정수 유형 중 오직 <code>int</code>사용해야합니다.
                        해당되는 경우 <code>size_t</code>및과 같은 표준 유형을 사용해도됩니다 <code>ptrdiff_t</code>.</p>
                    <p>우리는 <code>int</code>루프 카운터와 같이 너무 커질 수없는 정수를 매우 자주 사용 합니다. <code>int</code>그런 것들을 위해 평범한 것을
                        사용하십시오 . an <code>int</code>은 적어도 32 비트라고 가정해야하지만 32 비트 이상 있다고 가정하지는 않습니다. <code>int64_t</code>
                        또는 64 비트 정수형이 필요한 경우 또는를 사용
                        <code>uint64_t</code>합니다.</p>
                    <p>우리가 알고있는 정수가 "크다"면, 사용하십시오<code>int64_t</code>. </p>
                    <p><code>uint32_t</code>숫자가 아닌 비트 패턴을 나타내는 것과 같은 유효한 이유가 없거나 2 ^ N을 기준으로 오버플로를 정의해야하는 경우를 제외하고 와 같은
                        부호없는 정수 유형을 사용하면 안됩니다. 특히 부호가없는 유형을 사용하여 숫자가 음수가 될 수 없다는 것을 말하지 마십시오. 대신, 이것을 위해 어설 션을
                        사용하십시오.</p>
                    <p>코드가 크기를 반환하는 컨테이너 인 경우 컨테이너의 사용을 수용 할 수있는 유형을 사용해야합니다. 의심스러운 경우 더 작은 유형보다는 큰 유형을 사용하십시오.</p>
                    <p>정수 유형을 변환 할 때는주의하십시오. 정수 변환 및 프로모션은 정의되지 않은 동작을 일으켜 보안 버그 및 기타 문제를 일으킬 수 있습니다.</p>
                    <h4>부호없는 정수</h4>
                    <p>부호없는 정수는 비트 필드 및 모듈러 연산을 나타내는 데 적합합니다. 역사적인 사고로 인해 C ++ 표준은 컨테이너의 크기를 나타 내기
                        위해 부호없는 정수를 사용합니다. 표준 본문의 많은 구성원이이를 실수로 생각하지만 현재로서는 수정이 불가능합니다. 부호없는 산술 연산이 단순한 정수의 동작을
                        모델링하지 않고 표준에 의해 모듈러 산술을 모델링 (오버 플로우 / 언더 플로에서 랩핑)하는 대신에 정의된다는 사실은 컴파일러가 중요한 클래스의 버그를 진단 할 수 없다는
                        것을 의미합니다. 다른 경우에는 정의 된 동작이 최적화를 방해합니다.</p>
                    <p>즉, 정수 유형의 signedness를 혼합하는 것은 똑같이 큰 종류의 문제를 담당합니다. 우리가 제공 할 수있는 최선의 조언 :
                        포인터와 크기보다는 반복자와 컨테이너를 사용하고 부호가 섞이지 않도록하고 비트 필드 나 모듈러 연산을 제외하고 부호없는 형식을 사용하지 않도록하십시오. 변수가 음이 아닌
                        것으로 주장하는 데 부호없는 유형을 사용하지 마십시오.</p>
                </div>

                <h3 id="title7-12">64 비트 이식성</h3>
                <div class="content">
                    <p>코드는 64 비트 및 32 비트 친화적이어야합니다. 인쇄, 비교 및 ​​구조 조정 문제를 염두에 두십시오. </p>
                    <ul class="list-unstyled">
                        <li>
                            <p><code>printf()</code>일부 필수 typedef에 대한 올바른 휴대용 변환 지정자는 사용하기가 어렵고 필요하지 않은 (
                                <code>PRI</code>매크로가있는<code>&lt;cinttypes&gt;</code>) 매크로 확장에 의존합니다 . 특정 사례에 대한 합리적인 대안이
                                없으면 <code>printf</code>가족에 의존하는 API를 피하거나 업그레이드하십시오 . 대신 <a
                                        href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h"><code>StrCat</code></a>또는<a
                                        href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h"><code>Substitute</code></a>빠른
                                단순 변환 과 같은 형식 안전 숫자 형식을 지원하는 라이브러리를 사용하십시오<a
                                        href="https://google.github.io/styleguide/cppguide.html#Streams"><code>std::ostream</code></a>.
                            </p>
                            <p>불행하게도, <code>PRI</code>매크로 (예 : 표준 비트 너비 형식 정의에 대한 변환을 지정하는 유일한 휴대용
                                방법<code>int64_t</code>, <code>uint64_t</code>,
                                <code>int32_t</code>,<code>uint32_t</code>, 등). 가능한 경우, bitwidth typedef가 지정한 유형의 인수를
                                <code>printf</code>기반 API에 전달하지 마십시오 . printf가<code>size_t</code>(
                                <code>z</code>),<code>ptrdiff_t</code>( <code>t</code>) 및 <code>maxint_t</code>(
                                <code>j</code>) 와 같은 전용 길이 수정자를 갖는 typedef를 사용하는 것이 허용됩니다 .</p>
                        </li>
                        <li>그것을 기억하십시오 <code>sizeof(void *)</code>! = <code>sizeof(int)</code>. <code>intptr_t</code>포인터
                            크기의 정수를 원한다면 사용하십시오 .
                        </li>
                        <li>특히 디스크에 저장된 구조의 경우 구조 정렬에주의해야합니다. <code>int64_t</code>/ <code>uint64_t</code>
                            member가 있는 모든 클래스 / 구조 는 기본적으로 64 비트 시스템에서 8 바이트로 정렬됩니다. 이러한 구조가 32 비트와 64 비트 코드간에 디스크에서
                            공유되는 경우 두 아키텍처 모두에서 동일한 구조로 패킹되어야합니다. 대부분의 컴파일러는 구조 정렬을 변경하는 방법을 제공합니다. gcc에 대해, 당신은 사용할 수
                            있습니다
                            <code>__attribute__((packed))</code>. MSVC는 제공 <code>#pragma pack()</code>하고 <code>__declspec(align())</code>.
                        </li>
                        <li>
                            <p>64 비트 상수를 생성하는 데
                                필요한 경우 <a href="https://google.github.io/styleguide/cppguide.html#Casting">braced -
                                    initialization</a> 을 사용하십시오 . 예 :
                            </p>
                            <div class="code-box-copy">
                                <pre><code class="language-js">int64_t my_value{0x123456789};
uint64_t my_mask{3ULL << 48};</code></pre>
                            </div>
                        </li>
                    </ul>
                </div>

                <h3 id="title7-13">전 처리기 매크로</h3>
                <div class="content">
                    <p>특히 헤더에서 매크로를 정의하지
                        마십시오. 인라인 함수, 열거 형 및 <code>const</code>변수를 선호 합니다. 프로젝트 별 접두사가있는 매크로 이름 지정. 매크로를 사용하여 C ++ API
                        조각을
                        정의하지 마십시오.</p>
                    <p>매크로는 사용자가 보는 코드가 컴파일러가 보는
                        코드와 같지 않다는 것을 의미합니다. 매크로가 전역 범위를 가지므로 예기치 않은 동작이 발생할 수
                        있습니다.</p>
                    <p>매크로에 의해 도입 된 문제는 C ++ API의
                        조각을 정의하는 데 사용되는 경우 특히 심각하며 공개 API의 경우 더욱 그렇습니다. 개발자가 해당
                        인터페이스를 잘못 사용할 때 컴파일러의 모든 오류 메시지는 이제 매크로가 인터페이스를 구성하는 방법을 설명해야합니다. 리 팩터링 및 분석 도구는 인터페이스를 업데이트하는 데
                        극적인
                        어려움을 겪습니다. 결과적으로, 우리는 이러한 방식으로 매크로를 사용하는 것을 특별히 금지합니다. 예를 들어 다음과 같은 패턴은 사용하지 마십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, <)
};</code></pre>
                    </div>
                    <p>다행히도 매크로는 C 에서처럼 C ++ 에서처럼 거의 필요하지 않습니다. 성능이 중요한 코드를 인라인하는 매크로를 사용하는 대신 인라인 함수를 사용하십시오. 매크로를 사용하여
                        상수를 저장하는 대신 <code>const</code>변수를 사용 하십시오. 매크로를 사용하여 긴 변수 이름을 "축약"하는 대신 참조를 사용하십시오. 조건부로 코드를
                        컴파일하기 위해 매크로를 사용하는 대신 ... 전혀하지 마라. (물론, <code>#define</code>경비원이 헤더 파일을 두 번 포함하지 못하도록하는 것을 제외하고
                        ). 그것은 테스트를 훨씬 어렵게 만듭니다.</p>
                    <p>매크로는 다른 기법으로는 할 수없는 일을 할 수 있으며, 코드베이스, 특히 하위 레벨 라이브러리에서 볼 수 있습니다. 또한 특수 기능 (예 : 문자열
                        연결, 연결 등)은 적절한 언어를 통해 사용할 수 없습니다. 그러나 매크로를 사용하기 전에 동일한 결과를 얻는 비 매크로 방식이 있는지주의 깊게 고려하십시오. 매크로를
                        사용하여 인터페이스를 정의해야하는 경우 프로젝트 리드에게 문의하여이 규칙의 포기를 요청하십시오.</p>
                    <p>다음 사용 패턴은 매크로에서 많은 문제를 피할 수 있습니다. 매크로를 사용하는 경우 가능하면 매크로를 따르십시오.</p>

                    <ul class="list-unstyled">
                        <li><code>.h</code>파일에 매크로를 정의하지 마십시오.</li>
                        <li><code>#define</code>매크로를 사용하기 직전의 매크로와 <code>#undef</code>그 직후의 매크로.</li>
                        <li><code>#undef</code>자신의 매크로로 바꾸기 전에 기존의 매크로를 사용 하지 마십시오. 대신 고유 할 가능성이 높은 이름을 선택하십시오.</li>
                        <li>불균형 C ++ 구조로 확장되는 매크로를 사용하지 않거나 적어도 그 동작을 잘 문서화하십시오.</li>
                        <li><code>##</code>함수 / 클래스 / 변수 이름을 생성 하는 것을 선호하지 마십시오 .</li>
                    </ul>

                    <p>헤더에서 매크로를 내보내는 (즉, 헤더 <code>#undef</code>의 끝 부분 앞에 매크로를 삽입하지 않고 헤더에 매크로를 정의하는 ) 것은 매우 강력하게 권장되지
                        않습니다. 헤더에서 매크로를 내 보내면 전역 적으로 고유 한 이름이 있어야합니다. 이를 수행하려면 프로젝트의 네임 스페이스 이름 (대문자)으로 구성된 접두어로 이름을
                        지정해야합니다.</p>
                </div>

                <h3 id="title7-14">0 및 nullptr / NULL</h3>
                <div class="content">
                    <p>사용하여 <code>0</code>정수를 들어, <code>0.0</code>실수에 대한
                        <code>nullptr</code>포인터를 위해, 그리고 <code>'\0'</code>문자에 대해.</p>
                    <p><code>0</code>정수 및 <code>0.0</code>실수에 사용하십시오 .</p>
                    <p>포인터 (주소 값)의
                        경우 <code>nullptr</code>, type-safety를 제공하므로 이것을 사용하십시오 .</p>
                    <p>C ++ 03 프로젝트의 경우 선호 <code>NULL</code>합니다 <code>0</code>. 값은 동등하지만 <code>NULL</code>판독기에 대한 포인터와
                        유사 해
                        보이며 일부 C
                        ++ 컴파일러는 <code>NULL</code>
                        유용한 경고를 줄 수있는 특수한 정의 를 제공합니다.</p>
                    <p><code>'\0'</code>널 문자에 사용하십시오 . 올바른 유형을 사용하면 코드를보다 쉽게 ​​읽을 수 있습니다.</p>
                </div>

                <h3 id="title7-15">크기</h3>
                <div class="content">
                    <p>선호 함
                        .<code>sizeof(<var>varname</var>)</code><code>sizeof(<var>type</var>)</code></p>
                    <p>특정 변수의 크기를 사용할 때 사용 합니다.
                        누군가가 현재 또는 나중에 변수 유형을 변경하면 적절히 업데이트됩니다. 적절한 C ++ 유형의 변수가 편리하지 않은 외부 또는 내부 데이터 형식을 관리하는 코드와 같은 특정
                        변수와
                        관련없는
                        코드에 사용할 수 있습니다
                        .<code>sizeof(<var>varname</var>)</code><code>sizeof(<var>varname</var>)</code><code>sizeof(<var>type</var>)</code>
                    </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">Struct data;
memset(&data, 0, sizeof(data));</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">memset(&data, 0, sizeof(Struct));</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (raw_size < sizeof(int)) {
  LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
  return false;
}</code></pre>
                    </div>
                </div>

                <h3 id="title7-16">자동</h3>
                <div class="content">
                    <p><code>auto</code>시끄 럽거나 분명한 또는 중요하지 않은 유형 이름을
                        피 하십시오 . 유형이
                        독자에게 명확하게 도움이되지 않는 경우. 가독성을 높이려면 매니페스트 유형 선언을 계속
                        사용하십시오.</p>

                    <ul class="list-unstyled">
                        <li>C ++ 타입의 이름은 길거나
                            귀찮을 수 있습니다. 특히 템플릿이나 네임 스페이스가 관련되어있을 때는 더욱 그렇습니다.
                        </li>
                        <li>단일 선언 또는 작은 코드 영역
                            내에서 C ++ 유형 이름이 반복 될 때 반복은 가독성을 높이는 데 도움이되지 않을 수 있습니다.
                        </li>
                        <li>의도하지 않은 복사 나 형식
                            변환의 가능성을 피하기 때문에 유형을 초기화 표현식의 유형으로 지정하게하는 것이 더 안전 할 수도 있습니다.
                        </li>
                    </ul>
                    <p>타입 선언시, 특히 변수의 초기화가 멀리
                        선언 된 것에 의존 할 때 코드가 명확 해지는 경우가 있습니다. 표현식에서
                        :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">auto foo = x.add_foo();
auto i = y.Find(key);</code></pre>
                    </div>

                    <p>그 타입이 <code>y</code>잘 알려지지 않았거나 <code>y</code>더 일찍 선언 되었다면 결과 타입이 무엇인지 분명하지 않을 수 있습니다 .</p>
                    <p>프로그래머의 차이를 이해해야 <code>auto</code>하고 <code>const auto&amp;</code>또는가 말은하지 않았다 때 그들은 사본을
                        얻을 수 있습니다.</p>
                    <p><code>auto</code>변수가 인터페이스의 일부로 사용되는 경우 ( 예 : 헤더의 상수) 프로그래머는 값을 변경하려는 경우에만 유형을 변경하여 의도 한 것보다 급격한
                        API 변경을 초래할 수 있습니다.</p>
                    <p><code>auto</code>특히 아래에서 설명하는 것처럼 가독성을 높일 때 허용됩니다. <code>auto</code>괄호로 묶은 초기화 목록으로 타입
                        변수를 초기화하지 마십시오 .</p>
                    <p><code>auto</code>허용 또는 권장되는 특정 사례 : </p>
                    <ul class="list-unstyled">
                        <li>유형이 컨텍스트에서 분명 특히, 반복자 및 기타 긴 / cluttery 유형 이름의 (격려) (호출 <code>find</code>,
                            <code>begin</code>또는 <code>end</code>예를 들어).
                        </li>
                        <li>(허용됨) 유형이 로컬 컨텍스트 (동일한 표현식 또는 몇 줄 이내)에서 분명하지 않은 경우. 호출에 대한 포인터 또는
                            스마트 포인터의 초기화 <code>new</code>및 <code>std::make_unique</code>
                            사용과 마찬가지로 일반적으로는이 범주에 속하는 <code>auto</code>유형이 근처에 밖으로 철자가 컨테이너를 통해 범위 기반 루프를.
                        </li>
                        <li>(허용됨) 유형이 동등 비교 이외의 용도로 사용되지 않기 때문에 유형이 중요하지 않은 경우.</li>
                        <li>(권장) 범위 기반 루프를
                            사용하여 맵을 반복 할 때 (올바른 유형 <code>std::pair&lt;KeyType, ValueType&gt;</code>이 실제로 는 반면에 실제로
                            가정되기 때문에 <code>std::pair&lt;const KeyType, ValueType&gt;</code>). 이것은 특히 로컬 <code>key</code>
                            및 <code>value</code>별칭 <code>.first</code> 및 <code>.second</code>(종종 const-ref) 와 잘 조화를 이룹니다
                            .
                            <div class="code-box-copy">
                                <pre><code class="language-js">for (const auto& item : some_map) {
  const KeyType& key = item.first;
  const ValType& value = item.second;
  // The rest of the loop can now just refer to key and value,
  // a reader can see the types in question, and we've avoided
  // the too-common case of extra copies in this iteration.
}</code></pre>
                            </div>
                        </li>
                    </ul>
                </div>

                <h3 id="title7-17">브레이스 드 이니셜 라이저 목록</h3>
                <div class="content">
                    <p>braced initializer 목록을 사용할 수 있습니다.</p>
                    <p>C ++ 03에서 집계 형식 (생성자가없는 배열
                        및 구조체)은 braced initializer 목록으로 초기화 될 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">struct Point { int x; int y; };
Point p = {1, 2};</code></pre>
                    </div>
                    <p>C ++ 11에서이 구문은 일반화 되었으며 C ++ 문법에서 <i>braced-init-list</i> 로 알려진 braced initializer
                        목록으로 모든 객체 유형을 만들 수 있습니다 . 다음은 몇 가지 사용 예입니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Vector takes a braced-init-list of elements.
std::vector&lt;string&gt; v{"foo", "bar"};

// Basically the same, ignoring some small technicalities.
// You may choose to use either form.
std::vector&lt;string&gt; v = {"foo", "bar"};

// Usable with 'new' expressions.
auto p = new std::vector&lt;string&gt;{"foo", "bar"};

// A map can take a list of pairs. Nested braced-init-lists work.
std::map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// A braced-init-list can be implicitly converted to a return type.
std::vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// Iterate over a braced-init-list.
for (int i : {-1, -2, -3}) {}

// Call a function using a braced-init-list.
void TestFunction2(std::vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});</code></pre>
                    </div>
                    <p>사용자 정의 유형은 또한 <i>braced-init-list</i><code>std::initializer_list&lt;T&gt;</code> 에서 자동으로 생성되는 생성자
                        및 / 또는 할당 연산자를 정의 할 수 있습니다 .<i></i></p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class MyType {
 public:
  // std::initializer_list references the underlying init list.
  // It should be passed by value.
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType& operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};</code></pre>
                    </div>
                    <p>마지막으로 중괄호 초기화는 <code>std::initializer_list&lt;T&gt;</code>생성자 가없는 경우에도 데이터 유형의 일반 생성자를 호출 할 수
                        있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">double d{1.23};
// Calls ordinary constructor as long as MyOtherType has no
// std::initializer_list constructor.
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, "b"};
// If the constructor is explicit, you can't use the "= {}" form.
MyOtherType m{"b"};</code></pre>
                    </div>
                    <p><i>braced-init-list</i> 를 자동 로컬 변수에 할당하지 마십시오 . 단일 요소의 경우, 이것이 의미하는 것은 혼란 스러울 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.</code></pre>
                    </div>
                    <p>형식을 지정 <a
                            href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List_Format">하려면
                        Braced_Initializer_List_Format</a> 을 참조하십시오 .</p>
                </div>

                <h3 id="title7-18">람다 식</h3>
                <div class="content">
                    <p>적절한 경우 람다 식을 사용하십시오. 람다가 현재 스코프를 벗어날 때 명시적인 캡처를 선호하십시오.</p>
                    <p>람다 식은 익명의 함수 객체를 만드는 간결한 방법입니다. 함수를 인수로 전달할 때 종종 유용합니다. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) < Weight(y);
});</code></pre>
                    </div>
                    <p>그들은 또한 명시 적으로 이름으로 또는 명시 적으로 기본 캡처를 사용하여 둘러싼 범위에서 변수를 캡처 할 수 있습니다. 명시 적 캡처를 사용하려면 각 변수를 값 또는
                        참조 캡처로 나열해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &sum](int x) {
  sum += weight * x;
});</code></pre>
                    </div>
                    기본 캡처는 <code>this</code>맴버가 사용되는 경우를 포함하여 람다 본문에서 참조되는 모든 변수를 암시적으로 캡처합니다.
                    <div class="code-box-copy">
                        <pre><code class="language-js">const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&](int a, int b) {
  return lookup_table[a] < lookup_table[b];
});</code></pre>
                    </div>
                    <p>Lambda는 C ++ 11에서 다형 랩퍼 (polymorphic wrapper)와 같은 함수 객체로 작업하기위한 유틸리티 집합과 함께 소개되었습니다 <code>std::function</code>.
                    </p>
                    <ul class="list-unstyled">
                        <li>Lambda는 STL 알고리즘에 전달할 함수 개체를 정의하는 다른 방법보다 훨씬 간결하며 읽기 쉽도록 개선 될 수 있습니다.</li>
                        <li>기본 캡처를 적절하게 사용하면 중복을 제거하고 기본 예외에서 중요한 예외를 강조 표시 할 수 있습니다.</li>
                        <li>주면서, <code>std::function</code>및 <code>std::bind</code>범용 콜백기구로서 병용 할 수있다; 바운드 함수를 인수로 사용하는
                            함수를 작성하기 쉽습니다.
                        </li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>람다에서의 변수 캡처는 댕글 링 포인터 버그의 원인이 될 수 있습니다. 특히 람다가 현재 범위를 이스케이프하면 더욱 그렇습니다.</li>
                        <li>값에 의한 기본 캡처는 매달 리 포인터 버그를 방지하지 않으므로 오도 된 수 있습니다. 값으로 포인터를 캡처해도 딥 복사본이 생성되지 않으므로 종종 참조로 캡처하는
                            것과 동일한 수명 문제가 발생합니다. 이것은 'this'를 사용하는 것이 종종 암시적이기 때문에 '값'으로 'this'를 캡처 할 때 특히 혼란 스럽습니다.
                        </li>
                        <li>람다를 사용하면 손을 뗄 수 있습니다. 매우 긴 중첩 된 익명 함수는 코드를 이해하기 어렵게 만듭니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>적절한 경우 람다 식을 사용하고 <a
                                href="https://google.github.io/styleguide/cppguide.html#Formatting_Lambda_Expressions">아래</a>설명
                            된 <a href="https://google.github.io/styleguide/cppguide.html#Formatting_Lambda_Expressions">대로</a>서식을
                            지정
                            <a href="https://google.github.io/styleguide/cppguide.html#Formatting_Lambda_Expressions">합니다</a>.
                        </li>
                        <li>람다가 현재 범위를 벗어날 수있는 경우 명시 적 캡처를 선호합니다. 예를 들어, 대신 :
                            <div class="code-box-copy">
                                <pre><code class="language-js">{
  Foo foo;
  ...
  executor->Schedule([&] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.</code></pre>
                            </div>
                            다음을 작성하는 것을 선호합니다.
                            <div class="code-box-copy">
                                <pre><code class="language-js">{
  Foo foo;
  ...
  executor->Schedule([&foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.</code></pre>
                            </div>
                        </li>
                        <li>람다의 수명이 모든 잠재적 캡처보다 분명히 짧은 경우에만 참조 ([&amp;])로 기본 캡처를 사용하십시오.</li>
                        <li>캡처 된 변수 세트가 눈에 띄는 짧은 람다에 대해 몇 가지 변수를 바인딩하는 수단으로 만 값 ([=])을 사용하십시오. 값에 의한 기본 캡처로 길거나 복잡한
                            람다를
                            작성하지 마십시오.
                        </li>
                        <li>람다의 반환 형식을 명시 적으로 지정하면 독자가 더 명확하게 이해할 수 있습니다<a
                                href="https://google.github.io/styleguide/cppguide.html#auto"><code>auto</code></a>.
                        </li>
                    </ul>
                </div>

                <h3 id="title7-19">템플릿 메타 프로그래밍</h3>
                <div class="content">
                    <p>복잡한 템플릿 프로그래밍을 피하십시오.</p>
                    <p>템플릿 메타 프로그래밍은 C ++ 템플릿 인스턴스화 메커니즘이 Turing 전체이며 형식 도메인에서 임의의 컴파일 타임 계산을 수행하는 데 사용될 수 있다는 사실을 활용하는
                        기술
                        계열을 나타냅니다.</p>
                    <p>템플릿 메타 프로그래밍은 유형 안전성과 고성능을 제공하는 매우 유연한 인터페이스를 제공합니다. 같은 시설<a
                            href="https://code.google.com/p/googletest/">구글 테스트는</a>,<code>std::tuple</code>, <code>std::function</code>,
                        및 Boost.Spirit 그것없이 불가능하다.</p>
                    <p>템플릿 메타 프로그래밍에 사용되는 기술은 언어 전문가를 제외하고는 누구에게나 애매합니다.
                        복잡한 방식으로 템플릿을 사용하는 코드는 종종 읽을 수 없으며 디버깅하거나 유지하기가 어렵습니다.</p>
                    <p>템플릿 메타 프로그래밍은 종종 컴파일러 시간 오류 메시지를 매우 열악하게 만듭니다. 인터페이스가 단순하더라도 사용자가 잘못하면 복잡한 구현 세부 정보가 표시됩니다.</p>
                    <p>템플릿 메타 프로그래밍은 리팩토링 도구의 작업을 어렵게 만들어 대규모 리팩토링을 방해합니다.
                        첫째, 템플릿 코드가 다중 컨텍스트로 확장되므로 변형이 모두 의미가 있음을 검증하기가 어렵습니다.
                        둘째, 일부 리팩토링 도구는 템플릿 확장 후 코드 구조 만 나타내는 AST와 함께 작동합니다. 재 작성해야하는 원본 소스 구성으로 자동으로 되돌아가는 것은 어려울 수
                        있습니다.</p>
                    <p>템플릿 메타 프로그래밍을 사용하면 가능하지 않은 것보다 더 깔끔하고 사용하기 쉬운 인터페이스를 사용할 수 있지만 가끔 영리하게 사용하려는 유혹이되기도합니다.
                        적은 수의 저수준 구성 요소에서 사용하는 것이 가장 좋습니다.이 구성 요소에서는 많은 유지 보수 비용이 많은 용도에 걸쳐 분산되어 있습니다.</p>

                    <p>템플릿 메타 프로그래밍 또는 기타 복잡한 템플릿 기술을 사용하기 전에 두 번 생각하십시오.
                        팀의 평균 구성원이 다른 프로젝트로 전환, 또는 비 C ++ 프로그래머 나 사람이 부담 코드베이스를 탐색 여부를하면 오류 메시지를 이해할 수있을 것입니다
                        후를 유지하기 위해 충분히 당신의 코드를 이해 할 수 있는지에 대해 생각 호출하려는 함수의 흐름을 추적 할 수 있습니다.
                        당신이 재귀 템플릿 인스턴스화 또는 형식 목록 또는 메타 기능 또는 표현식 템플릿을 사용하거나 SFINAE 나에 의존하는 경우 <code>sizeof</code>함수
                        오버로드 확인을 검출하기위한 트릭, 당신은 너무 멀리 갔어요 좋은 기회가있다.</p>

                    <p>템플릿 메타 프로그래밍을 사용하는 경우 복잡성을 최소화하고 격리하는 데 상당한 노력을 기울일 것으로 예상됩니다.
                        가능하면 항상 메타 프로그래밍을 구현 세부 사항으로 숨겨서 사용자가 직접 볼 수있는 헤더를 읽을 수 있도록해야하며 까다로운 코드에 특히주의해야합니다.
                        코드의 사용법을 신중하게 문서화해야하며 "생성 된"코드의 모양에 대해 설명해야합니다. 사용자가 실수를했을 때 컴파일러에서내는 오류 메시지에 특히주의하십시오.
                        오류 메시지는 사용자 인터페이스의 일부이며 필요에 따라 코드를 조정해야 사용자의 관점에서 오류 메시지를 이해하고 실행할 수 있습니다.</p>
                </div>

                <h3 id="title7-20">후원</h3>
                <div class="content">
                    <p>Boost 라이브러리 콜렉션에서 승인 된 라이브러리 만 사용하십시오.</p>
                    <p><a href="https://www.boost.org/">부스트 라이브러리 컬렉션</a> 피어 - 검토, 무료, 오픈 소스 C ++ 라이브러리의 인기 모음입니다.</p>
                    <p>Boost 코드는 일반적으로 매우 고품질이며 널리 이식 가능하며 C ++ 표준 라이브러리의 유형 특성 및 더 나은 바인더와 같은 많은 중요한 틈새를 채 웁니다.</p>
                    <p>일부 부스트 라이브러리는 메타 프로그래밍 및 기타 고급 템플릿 기술과 같이 가독성을 저해 할 수있는 코딩 방법과 프로그래밍의 지나친 "기능"스타일을 장려합니다. </p>
                    <p>코드를 읽고 유지 관리 할 수있는 모든 기여자에 대해 높은 수준의 가독성을 유지하기 위해 승인 된 부스트 기능의 하위 집합 만 허용합니다. 현재 다음 라이브러리가
                        허용됩니다.</p>
                    <ul class="list-unstyled">
                        <li><a href="https://www.boost.org/libs/utility/call_traits.htm"></a>에서 <a
                                href="https://www.boost.org/libs/utility/call_traits.htm">특성 불러</a> 오기<code>boost/call_traits.hpp</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/utility/compressed_pair.htm">압축 쌍</a>으로부터 <code>boost/compressed_pair.hpp</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/graph/">부스트 그래프 라이브러리 (BGL)</a> 로부터
                            <code>boost/graph</code>직렬화
                            제외 ( <code>adj_list_serialize.hpp</code>) 및 병렬 / 분산 알고리즘 및 데이터 구조 ( <code>boost/graph/parallel/*</code>및<code>boost/graph/distributed/*</code>).
                        </li>
                        <li><a href="https://www.boost.org/libs/property_map/">Property Map</a> from ( <code>boost/property_map</code>병렬
                            / 분산 속성 맵 제외<code>boost/property_map/parallel/*</code>)
                        </li>
                        <li><a href="https://www.boost.org/libs/iterator/">반복자</a> 에서<code>boost/iterator</code>
                        </li>
                        <li>의 일부 <a href="https://www.boost.org/libs/polygon/">다각형</a> 보로 노이 다이어그램 건설 취급 및 다각형의 나머지에
                            의존하지 않습니다<code>boost/polygon/voronoi_builder.hpp</code>,<code>boost/polygon/voronoi_diagram.hpp</code>그리고<code>boost/polygon/voronoi_geometry_type.hpp</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/bimap/">Bimap</a> 에서<code>boost/bimap</code></li>
                        <li><a href="https://www.boost.org/libs/math/doc/html/dist.html">통계 분포 및 기능</a> 에서<code>boost/math/distributions</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/math/doc/html/special.html">특수 기능</a>에서<code>boost/math/special_functions</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/multi_index/">멀티 인덱스</a>
                            시작<code>boost/multi_index</code></li>
                        <li><a href="https://www.boost.org/libs/heap/">힙을</a> 에서<code>boost/heap</code></li>
                        <li>컨테이너의 평면<a href="https://www.boost.org/libs/container/">컨테이너</a> :<code>boost/container/flat_map</code>및<code>boost/container/flat_set</code>
                        </li>
                        <li><a href="https://www.boost.org/libs/intrusive/">관입</a>에서 <code>boost/intrusive</code>.
                        </li>
                        <li><a href="https://www.boost.org/libs/sort/"><code>boost/sort</code>라이브러리</a> .</li>
                        <li><a href="https://www.boost.org/libs/preprocessor/">처리기</a>에서
                            <code>boost/preprocessor</code>.
                        </li>
                    </ul>
                    <p>우리는 적극적으로 목록에 다른 부스트 기능을 추가하는 것을 고려하고 있으므로이 목록은 앞으로 확장 될 수 있습니다.</p>
                    <p>다음 라이브러리가 허용되지만 C ++ 11의 표준 라이브러리로 대체되었으므로 사용하지 않는 것이 좋습니다.</p>
                    <ul class="list-unstyled">
                        <li><a href="https://www.boost.org/libs/array/">
                            배열</a> 에서 <code>boost/array.hpp</code>: 대신 사용하십시오.<a
                                href="http://en.cppreference.com/w/cpp/container/array"><code>std::array</code></a>
                        </li>
                        <li><a href="https://www.boost.org/libs/ptr_container/">Pointer Container</a> from <code>boost/ptr_container</code>:
                            대신에 of containers를 사용하십시오.<a
                                    href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>
                        </li>
                    </ul>

                </div>

                <h3 id="title7-21">std :: hash</h3>
                <div class="content">
                    <p>의 전문화를 정의하지 마십시오 <code>std::hash</code>.</p>
                    <p><code>std::hash&lt;T&gt;</code>는 <code>T</code>사용자가 명시 적으로 다른 해시 함수를 지정하지 않는 한 C ++ 11 해시 컨테이너가
                        유형의 키를 해시하는 데 사용하는 함수 객체입니다 . 예를 들어, <code>std::unordered_map&lt;int, string&gt;</code>사용하는 해시 맵
                        인 <code>std::hash&lt;int&gt;</code>반면, 그 키를 해시 <code>std::unordered_map&lt;int, string,
                            MyIntHash&gt;</code>용도 <code>MyIntHash</code>.</p>

                    <p><code>std::hash</code>모든 정수, 부동 소수점, 포인터, 그리고 정의되어 <code>enum</code>유형뿐만 아니라 다음과 같은 몇 가지 표준 라이브러리
                        유형 <code>string</code>및 <code>unique_ptr</code>. 사용자는 해당 유형에 대한 특수화를 정의하여 해당 유형에 맞게 작동 할 수 있습니다.
                    </p>

                    <p><code>std::hash</code>사용하기 쉽고 명시 적으로 이름을 지정할 필요가 없기 때문에 코드를 단순화합니다.
                        Specializing<code>std::hash</code>은 유형을 해시하는 방법을 지정하는 표준 방법이므로 외부 리소스에서 가르치는 내용과 새로운 엔지니어가 기대하는
                        것입니다.</p>
                    <p><code>std::hash</code>전문화하기가 어렵습니다. 많은 상용구 코드가 필요하며 더 중요한 것은 해시 입력을 식별하는 책임과 해시 알고리즘 자체를 실행하는 책임을
                        결합한
                        것입니다. 유형 저자는 전자를 책임 져야하지만, 후자는 형식 저자가 일반적으로 가지고 있지 않으며 필요하지 않아야하는 전문 지식이 필요합니다. 낮은 품질의 해시 함수가 <a
                                href="https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">해시
                            넘침 공격</a> 의 출현으로 인해 보안 취약성을 낳을 수 있으므로 여기에있는 지분은 높습니다 .</p>
                    <p>전문가를 위해서조차도 <code>std::hash</code>복합 형에 대해 올바르게 구현하는 것은 전문적으로 어렵습니다. 왜냐하면 구현이 반복적
                        <code>std::hash</code>으로 데이터 멤버를 호출 할 수 없기 때문 입니다. 고품질 해시 알고리즘은 많은 양의 내부 상태를 유지
                        <code>size_t</code>하며
                        <code>std::hash</code>반환 되는 바이트의 상태를 대개 계산의 가장 느린 부분으로 축소 하므로 두 번 이상 수행하면 안됩니다.</p>
                    <p>정확히 문제로 인해 <code>std::hash</code>작동하지 않습니다 <code>std::pair</code>또는 <code>std::tuple</code>, 그리고
                        언어는
                        우리가 그들을 지원하도록 확장 할 수 없습니다.</p>
                    <p><code>std::hash</code>"즉시 사용할 수있는 "형식을 사용할 수 있지만 추가 형식을 지원하기 위해 특수화하지 마십시오.
                        <code>std::hash</code>지원하지
                        않는 키 유형으로 해시 테이블이 필요한 경우 기존 해시 컨테이너 (예 :)를 사용 하는 것이 좋습니다 <code>hash_map</code>. 그들은이 금지 사항의
                        영향을받지 않는
                        다른 기본 해시를 사용합니다.</p>
                    <p>어쨌든 표준 해시 컨테이너를 사용하려면 키 유형에 대한 사용자 정의 해더를 지정해야합니다 (예 :</p>
                    <pre>std :: unordered_map &lt;MyKeyType, Value, MyKeyTypeHasher&gt; my_map;
</pre>
                    <p>사용할 수있는 기존 해시가 있는지 유형 소유자에게 문의하십시오. 그렇지 않으면 자신과 함께 일하거나 자신의 것을 굴리십시오.</p>
                    <p>우리는 단점이없는 새로운 사용자 정의 메커니즘을 사용하여 모든 유형에서 작동 할 수있는 해시 함수를 제공 할 계획입니다<code>std::hash</code>.</p>
                </div>

                <h3 id="title7-22">C ++ 11</h3>
                <div class="content">
                    <p>적절한 경우 C ++ 11의 라이브러리 및 언어 확장을 사용하십시오. 프로젝트에서 C ++ 11 기능을 사용하기 전에 다른 환경으로의 이식성을 고려하십시오.</p>
                    <p>C ++ 11에는 언어와 라이브러리 모두에 <a href="https://en.wikipedia.org/wiki/C%2B%2B11">중요한 변경 사항이</a> 포함되어
                        있습니다 .
                    </p>
                    <p>C ++ 11은 2014 년까지 공식 표준이었으며 대부분의 C ++ 컴파일러에서 지원됩니다. 우리가 이미 사용하는 몇 가지 일반적인 C ++ 확장을 표준화하고 일부 작업의
                        약자를
                        허용하며 성능 및 안전성을 일부 개선했습니다.</p>
                    <p>C ++ 11 표준은 전작 (1300 페이지 대 800 페이지)보다 훨씬 복잡하며 많은 개발자에게 익숙하지 않습니다.
                        코드의 가독성 및 유지 보수에 대한 일부 기능의 장기적인 영향은 알려져 있지 않습니다.
                        특히 이전 버전의 도구를 사용해야하는 프로젝트의 경우, 다양한 기능이 언제 관심 대상이 될 수있는 도구로 균등하게 구현되는지 예측할 수 없습니다.</p>
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Boost">Boost</a> 와 마찬가지로 일부 C ++ 11
                        확장은
                        독자에게 도움이 될 수있는 확인 된 중복 (예 : 유형 이름)을 제거하거나 템플릿 메타 프로그래밍을 장려하는 등 가독성을 저해하는 코딩 방법을 권장합니다.
                        다른 확장 기능은 기존 메커니즘을 통해 사용할 수있는 기능을 복제하므로 혼동과 전환 비용이 발생할 수 있습니다.</p>
                    <p>별도로 지정하지 않는 한 C ++ 11 기능을 사용할 수 있습니다. 스타일 가이드의 나머지 부분에서 설명하는 것 외에도 다음 C ++ 11 기능을 사용할 수 없습니다.</p>
                    <ul class="list-unstyled">
                        <li>컴파일 타임의 유리수 ( <code>&lt;ratio&gt;</code>). 템플릿이 많은 인터페이스 스타일에 묶여 있다는 우려 때문입니다.</li>
                        <li><code>&lt;cfenv&gt;</code>및<code>&lt;fenv.h&gt;</code>헤더, 많은 컴파일러가 안정적으로 이러한 기능을 지원하지 않기
                            때문에.
                        </li>
                    </ul>
                </div>

                <h3 id="title7-23">비표준 확장</h3>
                <div class="content">
                    <p>별도로 지정하지 않는 한 C ++의 비표준 확장을 사용할 수 없습니다.</p>
                    <p>컴파일러는 표준 C ++의 일부가 아닌 다양한 확장을 지원합니다. 이러한 확장 GCC의 포함 <code>__attribute__</code>과 같은 고유 기능을
                        <code>__builtin_prefetch</code>, 지정된 이니셜 (예<code>Foo f = {.field = 3}</code>), 인라인 어셈블리, <code>__COUNTER__</code>,<code>__PRETTY_FUNCTION__</code>,
                        복합 명령문의 표현 (예를 들어<code>foo = ({ int x; Bar(&amp;x); x })</code>, 가변 길이 배열과<code>alloca()</code>,
                        그리고
                        " <a href="https://en.wikipedia.org/wiki/Elvis_operator">엘비스 운영자</a> "<code>a?:b</code>.</p>
                    <ul class="list-unstyled">
                        <li>비표준 확장은 표준 C ++에없는 유용한 기능을 제공 할 수 있습니다.
                            예를 들어, 일부 사람들은 지정된 초기화 프로그램이 생성자와 같은 표준 C ++ 기능보다 읽기 쉽다고 생각합니다.
                        </li>
                        <li>컴파일러에 대한 중요한 성능 지침은 확장을 사용하여 지정해야합니다.</li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>비표준 확장은 모든 컴파일러에서 작동하지 않습니다. 비표준 확장을 사용하면 코드의 이식성이 떨어집니다.</li>
                        <li>모든 대상 컴파일러에서 지원되는 경우에도 확장명을 잘 지정하지 않은 경우가 많으며 컴파일러간에 동작 차이가 미묘한 차이가있을 수 있습니다.</li>
                        <li>비표준 확장은 독자가 코드를 이해하기 위해 알아야 할 언어 기능을 추가합니다.</li>
                    </ul>
                    <p>비표준 확장자를 사용하지 마십시오. 비표준 확장을 사용하여 구현 된 이식성 랩퍼는 해당 프로젝트의 이식성 헤더로 지정된 래퍼를 사용할 수 있습니다.</p>
                </div>

                <h3 id="title7-24">별칭</h3>
                <div class="content">
                    <p>공개 별칭은 API 사용자를위한 것이며 분명하게 문서화되어야합니다.</p>
                    <p>다른 엔티티의 별칭 인 이름을 만드는 방법에는 여러 가지가 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;</code></pre>
                    </div>
                    <p>새 코드에서는 C ++의 나머지 구문과 일관된 구문을 제공하고 템플릿을 사용하기 때문에 <code>using</code>보다 바람직합니다 <code>typedef</code>.
                    </p>
                    <p>다른 선언과 마찬가지로 헤더 파일에 선언 된 별칭은 함수 정의, 클래스의 비공개 부분 또는 명시 적으로 표시된 내부 네임 스페이스에 있지 않으면 헤더의 공용 API의
                        일부입니다.
                        이러한 영역 또는 .cc 파일의 별명은 구현 세부 사항 (클라이언트 코드가 참조 할 수 없기 때문에)이며이 규칙에 의해 제한되지 않습니다.</p>
                    <ul class="list-unstyled">
                        <li>별명은 길거나 복잡한 이름을
                            단순화하여 가독성을 향상시킬 수 있습니다.
                        </li>
                        <li>별칭은 API에서 반복적으로
                            사용되는 한 유형의 이름을 지정함으로써 중복을 줄일 수 있으므로 나중에 유형을 쉽게 변경할 수
                            있습니다.
                        </li>
                    </ul>
                    <ul class="list-unstyled">
                        <li>클라이언트 코드가 헤더를 참조 할 수있는 헤더에 배치되면 별칭은 해당 헤더의 API에있는 엔티티의 수를 늘려 복잡성을 증가시킵니다.</li>
                        <li>클라이언트는 공개 별칭의 의도하지 않은 세부 사항에 쉽게 의지하여 변경을 어렵게 만들 수 있습니다.</li>
                        <li>API에 대한 영향이나 유지 관리 가능성을 고려하지 않고 구현에만 사용하려는 공개 별칭을 만드는 것이 유혹적 일 수 있습니다.</li>
                        <li>별칭으로 인해 이름 충돌 위험이 발생할 수 있음</li>
                        <li>앨리어스는 친숙한 구조에 익숙하지 않은 이름을 부여하여 가독성을 떨어 뜨릴 수 있습니다.</li>
                        <li>유형 별명은 명확하지 않은 API 계약을 만들 수 있습니다. 별칭이 별칭 유형과 동일하거나 동일한 API를 갖거나 지정된 좁은 방법으로 만 사용 가능한지 여부가
                            확실하지
                            않습니다.
                        </li>
                    </ul>
                    <p>구현에 입력 내용을 저장하기 위해 공용 API에 별칭을 두지 마십시오. 고객이 사용하려는 경우에만 그렇게하십시오.</p>
                    <p>공개 별칭을 정의 할 때 현재 별칭이 지정된 유형과 항상 동일하게 보장되는지 또는 제한된 호환성이 의도되는지 여부를 포함하여 새 이름의 의도를 문서화하십시오. 이를
                        통해 사용자는 유형을 대체 가능한 것으로 취급 할 수 있는지 또는 더 구체적인 규칙을 따라야하는지 여부를 알 수 있으며, 구현이 별명을 변경할 수있는 자유도를 유지하는 데
                        도움이 될 수 있습니다.</p>
                    <p>공용 API에 네임 스페이스 별칭을 넣지 마십시오. ( <a
                            href="https://google.github.io/styleguide/cppguide.html#Namespaces">네임 스페이스</a>참조 ).</p>
                    <p>예를 들어 다음 별칭은 클라이언트 코드에서 사용되는 방법을 문서화합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace mynamespace {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = foo::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;
}  // namespace mynamespace</code></pre>
                    </div>
                    <p>이러한 별칭은 의도 한 용도를 문서화하지 않으며 그 중 절반은 클라이언트 용으로 사용되지 않습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace mynamespace {
// Bad: none of these say how they should be used.
using DataPoint = foo::Bar*;
using std::unordered_set;  // Bad: just for local convenience
using std::hash;           // Bad: just for local convenience
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace mynamespace</code></pre>
                    </div>
                    <p>그러나 함수 정의, 클래스의 private 섹션, 명시 적으로 내부 이름 공간으로 표시된 클래스 및 .cc 파일에서는 로컬 편의 별칭이 적합합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// In a .cc file
using foo::Bar;</code></pre>
                    </div>
                </div>
            </div>

            <h2 id="title8">이름 지정</h2>
            <div class="content">
                <p>가장 중요한 일관성 규칙은 이름 지정을 관리하는 규칙입니다. 이름의 스타일은 타입 엔티티, 변수, 함수, 상수, 매크로 등과 같은 엔티티의 선언을 검색 할 필요없이 이름 지정된
                    엔티티가 어떤 종류인지를 즉시 알려줍니다. 우리의 두뇌에있는 패턴 일치 엔진은 이러한 명명 규칙에 크게 의존합니다.</p>
                <p>이름 지정 규칙은 매우 자의적이지만 우리는이 영역의 개별 선호도보다 일관성이 더 중요하다고 생각하므로 합리적인 지 여부에 관계없이 규칙이 규칙입니다.</p>
                <h3 id="title8-1">일반 이름 지정 규칙</h3>
                <div class="content">
                    <p>이름은 설명이 있어야합니다. 약어를 피하십시오.</p>
                    <p>가능한 이유를 설명하는 이름으로 제공하십시오. 새로운 독자가 코드를 즉시 이해할 수 있도록하기 위해 수평 공간을 절약하는 것에 대해 걱정하지 마십시오. 프로젝트 외부 독자에게
                        모호하거나 익숙하지 않은 약어는 사용하지 말고 단어 내의 문자를 삭제하여 약어를 사용하지 마십시오. 관련 도메인 지식이있는 프로젝트 외부의 누군가에게 친숙한 약어는
                        괜찮습니다. 일반적으로 위키 피 디아 (Wikipedia) 목록에있는 약어는 아마도 OK 일 것입니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
int lstm_size;             // "LSTM" is a common machine learning abbreviation.</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
FooBarRequestInfo fbri;    // Not even a word.</code></pre>
                    </div>
                    <p><code>i</code>반복 변수 및 <code>T</code>템플릿 매개 변수와 같이 보편적으로 알려진 특정 약어는 괜찮습니다 .</p>
                    <p>일부 기호의 경우이 스타일 가이드에서는 대문자로 시작하고 각 새 단어에 대문자를 사용하도록 권장합니다 (별개로 " <a
                            href="https://en.wikipedia.org/wiki/Camel_case">카멜 케이스</a> "또는 "파스칼 케이스"). 약어 또는 두문자어가 그러한
                        이름에
                        나타날 때는 약어 또는 두문자어를 한 단어로 대문자로 표기하십시오 (예<code>StartRpc()</code>: not <code>StartRPC()</code>).
                    </p>
                    <p>템플릿 매개 변수는 해당 카테고리의 명명 스타일을 따라야합니다. 유형 템플릿 매개 변수는 <a
                            href="https://google.github.io/styleguide/cppguide.html#Type_Names">유형 이름에</a> 대한 규칙을
                        따라야하고<a
                                href="https://google.github.io/styleguide/cppguide.html#Type_Names">유형이</a> 아닌 템플릿 매개
                        변수는 <a
                                href="https://google.github.io/styleguide/cppguide.html#Variable_Names">변수 이름에</a>대한 규칙을
                        따라야합니다
                        .
                    </p>
                </div>

                <h3 id="title8-2">파일 이름</h3>
                <div class="content">
                    <p>파일 이름은 모두 소문자 여야하며 밑줄 ( <code>_</code>) 또는 대시 ( <code>-</code>)를 포함 할 수 있습니다 . 프로젝트에서 사용하는 규칙을
                        따릅니다.
                        따라야 할 일관된 지역 패턴이 없으면 "_"을 선호하십시오.</p>
                    <p>허용되는 파일 이름의 예 :</p>
                    <ul class="list-unstyled">
                        <li><code>my_useful_class.cc</code></li>
                        <li><code>my-useful-class.cc</code></li>
                        <li><code>myusefulclass.cc</code></li>
                        <li><code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code></li>
                    </ul>
                    <p>C ++ 파일은 끝나야 <code>.cc</code>하며 헤더 파일은 끝나야<code>.h</code>합니다. 특정 지점에 텍스트로 포함되는 것에 의존하는 파일은 끝나야
                        <code>.inc</code>합니다
                        ( <a href="https://google.github.io/styleguide/cppguide.html#Self_contained_Headers">자체 포함
                            헤더</a> 섹션
                        참조 ).</p>
                    <p>이미 존재하는 파일 이름을 사용하지 마십시오<code>/usr/include</code>등을, <code>db.h</code>.</p>
                    <p>일반적으로 파일 이름을 매우 구체적으로 지정하십시오. 예를 들어, <code>http_server_logs.h</code>보다는을 사용하십시오
                        <code>logs.h</code>.
                        매우 일반적인 경우는 한 쌍의 파일을 호출하는 것입니다 (예 :
                        <code>foo_bar.h</code>및<code>foo_bar.cc</code>)<code>FooBar</code>.</p>
                </div>

                <h3 id="title8-3">유형 이름</h3>
                <div class="content">
                    <p>유형 이름은 대문자로 시작하고 밑줄이없는 각각의 새 단어에 대문자가 있습니다.<code>MyExcitingClass</code>,,
                        <code>MyExcitingEnum</code>.
                    </p>
                    <p>클래스, 구조체, 형식 별칭, 열거 형 및 형식 템플릿 매개 변수와 같은 모든 형식의 이름은 동일한 명명 규칙을 사용합니다. 유형 이름은 대문자로 시작하고 각각의 새 단어에
                        대문자가
                        있어야합니다. 밑줄 없음. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;

// enums
enum UrlTableErrors { ...</code></pre>
                    </div>
                </div>

                <h3 id="title8-4">변수 이름</h3>
                <div class="content">
                    <p>변수의 이름 (함수 매개 변수 포함) 및 데이터 멤버는 모두 소문자이며 단어 사이에 밑줄이 있습니다. 클래스의 데이터 멤버 (구조체가 아님)에는 추가로 밑줄이 있습니다. 예를
                        들면
                        :<code>a_local_variable</code>,
                        <code>a_struct_data_member</code>,<code>a_class_data_member_</code>.
                    </p>
                    <h4>공통 변수 이름</h4>
                    <p>예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">string tableName;   // Bad - mixed case.</code></pre>
                    </div>
                    <h4>클래스 데이터 멤버</h4>
                    <p>정적 및 정적이 아닌 클래스의 데이터 멤버는 일반적인 비 멤버 변수와 같이 이름이 지정되지만 후행 밑줄이 붙습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};</code></pre>
                    </div>
                    <h4>구조 데이터 멤버</h4>
                    <p>정적 및 비 정적 구조체의 데이터 멤버는 일반 비 멤버 변수와 같이 이름이 지정됩니다. 클래스의 데이터 멤버가 가지는 밑줄이 없습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};</code></pre>
                    </div>
                    <p>struct 대 클래스를 사용하는 경우에 대한 설명은 <a
                            href="https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes">Structs 대
                        Classes</a>를 참조하십시오 .</p>
                </div>

                <h3 id="title8-5">상수</h3>
                <div class="content">
                    <p>constexpr 또는 const로 선언되고 프로그램 기간 동안 값이 고정 된 변수는 앞에 "k"와 대소 문자가 혼합 된 이름이 지정됩니다. 드문 경우지만 대문자를 분리에
                        사용할
                        수없는 경우에는 밑줄 문자를 구분 기호로 사용할 수 있습니다. 예 :</p>
                    <pre>const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24; // Android 8.0.0
</pre>
                    <p>정적 저장 기간 (예 : 통계 및 전역, 자세한 내용은 <a
                            href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">저장 기간</a>참조)
                        과 같은 모든 변수는 이 방법으로 지정해야합니다. 이 규칙은 다른 저장 클래스의 변수, 예를 들어 자동 변수에서 선택 사항입니다. 그렇지 않으면 일반적인 변수 명명 규칙이
                        적용됩니다.</p>

                </div>

                <h3 id="title8-6">함수 이름</h3>
                <div class="content">
                    <p>정규 함수는 대소 문자가 혼합되어 있습니다. 액세서와 mutator는 변수처럼 명명 될 수 있습니다.</p>
                    <p>대개 함수는 대문자로 시작하고 각각의 새 단어에 대문자를 사용해야합니다.</p>
                    <pre>AddTableEntry ()
DeleteUrl ()
OpenFileOrDie ()
</pre>
                    <p>(동일한 이름 지정 규칙은 API의 일부로 노출되고 함수처럼 보이기 위해 의도 된 클래스 및 네임 스페이스 범위 상수에 적용됩니다. 함수가 아니라 객체라는 사실은 중요하지
                        않은 구현
                        세부 사항이기 때문에 동일하게 적용됩니다.)</p>
                    <p>액세서와 변경자 (get 및 set 함수)는 변수와 같은 이름을 가질 수 있습니다. 이들은 종종 실제 멤버 변수에 해당하지만 필수는 아닙니다. 예를 들어 <code>int
                        count()</code>및 <code>void set_count(int count)</code>.</p>

                </div>

                <h3 id="title8-7">네임 스페이스 이름</h3>
                <div class="content">
                    네임 스페이스 이름은 모두 소문자입니다. 최상위 네임 스페이스 이름은 프로젝트 이름을 기반으로합니다. 중첩 된 네임 스페이스와 잘 알려진 최상위 네임 스페이스 간의 충돌을
                    피하십시오.
                    <p>최상위 네임 스페이스의 이름은 대개 해당 네임 스페이스에 코드가 포함 된 프로젝트 또는 팀의 이름이어야합니다. 해당 네임 스페이스의 코드는 일반적으로 기본 이름이 네임
                        스페이스 이름
                        (또는 하위 디렉터리)과 일치하는 디렉터리에 있어야합니다.</p>
                    <p><a href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules">축약 된 이름에</a>대한
                        <a
                                href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules">규칙</a> 은
                        변수 이름만큼
                        많은 이름 공간에 적용됩니다. 네임 스페이스 내부의 코드는 네임 스페이스 이름을 언급 할 필요가 거의 없으므로 일반적으로 어쨌든 약어가 필요하지 않습니다.</p>

                    <p>잘 알려진 최상위 네임 스페이스와 일치하는 중첩 네임 스페이스는 피하십시오. 네임 스페이스 이름 간의 충돌은 이름 조회 규칙으로 인해 놀라운 빌드 중단을 초래할 수 있습니다.
                        특히
                        중첩 된 <code>std</code>네임 스페이스를 만들지 마십시오 . 충돌이 자주 발생하는 이름과 같이 고유 한 프로젝트 식별자 (
                        <code>websearch::index</code>, <code>websearch::index_util</code>)를
                        선호하십시오<code>websearch::util</code>.</p>

                    <p>들면 <code>internal</code>스페이스 같은 추가되는 다른 코드 조심 <code>internal</code>충돌 일으키는 공간 (팀 내의 내부 헬퍼 것은 관련되는
                        경향과의 충돌로 이어질 수있다). 이러한 경우 파일 이름을 사용하여 고유 한 내부 이름을 만드는 것이 유용합니다 ( <code>websearch::index::frobber_internal</code>사용
                        <code>frobber.h</code>)</p>

                </div>

                <h3 id="title8-8">열거 자 이름</h3>
                <div class="content">
                    <p>열거 (모두 범위 및 범위가 지정되지 않은 열거 형에 대한)를 지정해야 <i>하나</i> 같은<a
                            href="https://google.github.io/styleguide/cppguide.html#Constant_Names">상수</a> 또는 같은<a
                            href="https://google.github.io/styleguide/cppguide.html#Macro_Names">매크로를</a> :
                        중<code>kEnumName</code>또는<code>ENUM_NAME</code>.</p>
                    <p>바람직하게는 개별 열거자는 <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names">상수</a>
                        와 같이
                        명명되어야합니다 . 그러나 <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">매크로</a>
                        처럼
                        이름을<a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">지정할 수도</a>있습니다. 열거 형
                        이름<code>UrlTableErrors</code>(및<code>AlternateUrlTableErrors</code>)은 유형이므로 대 / 소문자가 혼용됩니다.</p>

                    <pre>enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>
                    <p>2009 년 1 월까지 스타일은 <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">매크로</a>
                        처럼
                        enum 값의 이름을 지정하는 것이 었습니다 . 이로 인해 enum 값과 매크로 사이의 이름 충돌 문제가 발생했습니다.
                        따라서 일정한 스타일의 명명 방식을 선호하는 변화가 이루어졌습니다. 가능한 경우 새 코드는 상수 스타일 명명을 선호해야합니다.
                        그러나 이전 이름이 실제로 컴파일 타임에 문제가되지 않는 한, 상수 스타일 이름을 사용하도록 이전 코드를 변경해야 할 이유는 없습니다.</p>

                </div>

                <h3 id="title8-9">매크로 이름</h3>
                <div class="content">
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">매크로</a>를 <a
                            href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">정의</a> 하지 않을거야
                        ,
                        그렇죠? 그렇게한다면 그들은 이렇게됩니다 :<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</code>.</p>
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">매크로에</a> 대한 <a
                            href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">설명을</a>참조하십시오 .
                        일반적으로 매크로는 사용 하지 않아야 합니다. 그러나 그들이 절대적으로 필요하다면, 그들은 모든 대문자와 밑줄로 지명되어야합니다.</p>

                    <pre>#define ROUND (x) ...
#define PI_ROUNDED 3.0
</pre>
                </div>

                <h3 id="title8-10">이름 지정 규칙의 예외</h3>
                <div class="content">
                    <p>기존 C 또는 C ++ 엔티티와 유사한 이름을 지정하는 경우 기존 명명 규칙 체계를 따를 수 있습니다.</p>
                    <dl>
                        <dt><code>bigopen()</code></dt>
                        <dd>함수 이름, 다음의 형식을 따른다. <code>open()</code></dd>
                        <dt><code>uint</code></dt>
                        <dd><code>typedef</code></dd>
                        <dt><code>bigpos</code></dt>
                        <dd><code>struct</code>또는 <code>class</code>, 형태를 다음과<code>pos</code></dd>
                        <dt><code>sparse_hash_map</code></dt>
                        <dd>STL과 같은 개체; STL 명명 규칙을 따릅니다.</dd>
                        <dt><code>LONGLONG_MAX</code></dt>
                        <dd>상수 <code>INT_MAX</code></dd>
                    </dl>
                </div>
            </div>

            <h2 id="title9">코멘트</h2>
            <div class="content">
                <p>작성해야 할 고통은 있지만 코드는 우리의 코드를 읽기 쉽게 유지하는 데 절대적으로 중요합니다. 다음 규칙은 설명해야 할 내용과 내용을 설명합니다. 하지만 메모는 매우 중요하지만
                    최고의 코드는 자체 문서화입니다. 유형과 변수에 의미있는 이름을 부여하는 것은 모호한 이름을 사용하는 것보다 훨씬 낫습니다. 그런 다음 주석을 통해 설명해야합니다.</p>
                <p>여러분의 의견을 쓸 때, 독자를 위해 다음 코드를 이해할 필요가있는 다음 기여자를 작성하십시오. 관대하십시오 - 다음 사람이 당신이 될 수 있습니다!</p>

                <h3 id="title9-1">댓글 스타일</h3>
                <div class="content">
                    <p>일관성 있는 한 <code>//</code>또는 <code>/* */</code>구문을 사용하십시오 .</p>
                    <p><code>//</code>또는 <code>/* */</code>구문을 사용할 수 있습니다 . 그러나, <code>//</code>이다 훨씬 더 많이. 당신이 어떻게
                        코멘트하고 어떤
                        스타일을 어디에 사용하는지 일관되게하십시오.</p>
                </div>

                <h3 id="title9-2">파일 설명</h3>
                <div class="content">
                    <p>라이선스 보일러 플레이트로 각 파일을 시작합니다.</p>
                    <p>파일 주석은 파일의 내용을 설명합니다. 파일이 선언 시점의 주석에 의해 문서화 된 하나의 추상화를 정확하게 선언, 구현 또는 테스트하는 경우 파일 주석은 필요하지 않습니다.
                        다른 모든 파일에는 파일 주석이 있어야합니다.</p>
                    <h4>법률 고지 및 저자 라인</h4>
                    <p>모든 파일에는 상용구가 있어야합니다. 프로젝트에서 사용하는 라이선스에 적합한 상용구를 선택하십시오 (예 : Apache 2.0, BSD, LGPL, GPL).</p>
                    <p>작성자 행이있는 파일을 크게 변경 한 경우 작성자 행을 삭제하십시오. 새 파일에는 보통 저작권 표시 또는 작성자 행이 포함되어서는 안됩니다.</p>
                    <h4>파일 내용</h4>
                    <p>A는 경우 <code>.h</code>여러 추상화를 선언, 파일 레벨의 의견은 크게 파일의 내용을 설명해야하며, 추상화는 어떻게 관련이 있습니다. 1 또는 2 문장의 파일
                        수준
                        주석으로 충분할 수 있습니다. 개별 추상화에 대한 자세한 문서는 파일 수준이 아닌 추상화에 속합니다.</p>
                    <p><code>.h</code>및<code>.cc</code>. 에서 주석을 복제하지 마십시오 . 중복 된 댓글이 분기됩니다.</p>
                </div>

                <h3 id="title9-3">클래스 주석</h3>
                <div class="content">
                    <p>모든 명확하지 않은 클래스 선언에는 그것이 무엇인지, 어떻게 사용해야 하는지를 설명하는 주석이 있어야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table->NewIterator();
//    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
//      process(iter->key(), iter->value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};</code></pre>
                    </div>
                    <p>클래스 주석은 클래스을 올바르게 사용하는 데 필요한 추가 고려 사항뿐만 아니라 클래스을 언제 어떻게 사용하는지 알 수있는 충분한 정보를 독자에게 제공해야합니다. 클래스가
                        만드는
                        동기화 가정을 문서화하십시오. 클래스의 인스턴스에 여러 스레드가 액세스 할 수있는 경우 다중 스레드 사용을 둘러싼 규칙 및 불변성을 문서화하는 데 특히주의하십시오.</p>
                    <p>클래스 주석은 간단하고 집중적 인 클래스 사용법을 보여주는 작은 예제 코드 스 니펫에 적합한 경우가 많습니다.</p>
                    <p>충분히 (예를 분리 할 때 <code>.h</code>및 <code>.cc</code> 파일)의 인터페이스 정의와 함께 이동한다 클래스의 사용을 설명하는 주석; 클래스 조작과
                        구현에 관한
                        주석은 클래스의 메소드 구현에 수반되어야한다.</p>
                </div>

                <h3 id="title9-4">함수 설명</h3>
                <div class="content">
                    <p>선언문은 기능의 사용을 기술한다 (명확하지 않은
                        경우); 함수의 정의에 대한 주석은 조작을 설명합니다.</p>
                    <h4>함수 선언</h4>
                    <p>거의 모든 함수 선언에는 함수의 기능과 사용법을
                        설명하는 주석이 있어야합니다. 이 주석은 함수가 단순하고 명백한 경우에만 생략 될 수 있습니다 (예 :
                        클래스의 명백한 속성에 대한 간단한 접근 자). 이러한 주석은 명령형 ( "파일 열기")이 아니라 서술형
                        ( "파일 열기")이어야합니다. 주석은 함수를 설명하고, 함수에 무엇을해야하는지 알려주지
                        않습니다. 일반적으로 이러한 주석은 함수가 해당 작업을 수행하는 방법을 설명하지 않습니다. 대신 함수 정의에 주석으로 남겨 두어야합니다.</p>
                    <p>함수 선언에서 주석에 언급 할 사항의 유형은
                        다음과 같습니다.</p>
                    <ul class="list-unstyled">
                        <li>입력 및 출력은 무엇입니까.</li>
                        <li>클래스 멤버 함수의 경우 : 개체가 메서드 호출 기간을 초과하여 참조 인수를 기억하는지 여부 및 개체를 해제할지 여부.</li>
                        <li>함수가 호출자가 해제해야하는 메모리를 할당하는 경우.</li>
                        <li>인수 중 하나가 널 (NULL) 포인터가 될 수 있는지 여부.</li>
                        <li>함수가 사용되는 방법과 관련하여 성능에 영향이있는 경우.</li>
                        <li>기능이 재진입 인 경우. 동기화 가정은 무엇입니까?</li>
                    </ul>
                    <p>다음은 그 예입니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table->NewIterator();
//    iter->Seek("");
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;</code></pre>
                    </div>
                    <p>그러나 불필요하게 장황하게하거나 완전히 명백하게 진술하지 마십시오.</p>
                    <p>함수 오버라이드를 문서화 할 때 오버라이드 된 함수에서 주석을 반복하는 대신 오버라이드 자체의 특성에 중점을 둡니다. 이 경우 대부분의 경우 대체
                        문서가 필요 없으므로 주석이 필요하지 않습니다.</p>
                    <p>생성자와 소멸자를 주석 처리 할 때는 코드를 읽는 사람이 생성자와 소멸자가 무엇인지 알고 있으므로 "이 객체를 파괴합니다"와 같은 말은 유용하지 않습니다. 인수를 사용하여
                        생성자가 수행하는 작업 (예 : 포인터의 소유권을 가져 오는 경우) 및 소멸자가 수행하는 정리 작업을 문서화하십시오. 이것이 사소한 것이라면 주석을 건너 뛰십시오. 소멸자가
                        머리글 주석을 사용하지 않는 것이 일반적입니다.</p>
                    <h4>기능 정의</h4>
                    <p>함수가 어떻게 작동하는지 까다로울 경우 함수 정의에는 설명 주석이 있어야합니다. 예를 들어, 정의 주석에서 사용하는 코딩 기법을 설명하거나, 수행하는
                        단계에 대한 개요를 제공하거나, 실행 가능한 대안을 사용하지 않고 수행 한 방식으로 기능을 구현하는 이유를 설명 할 수 있습니다. 예를 들어 함수의 전반부에 대해 잠금을
                        확보해야하는 이유는 설명 할 수 있지만 후반에는 잠금이 필요하지 않은 이유를 설명 할 수 있습니다.</p>
                    <p>파일이나 함수 선언과 함께 주어진 주석을 반복 해서는 안됩니다<code>.h</code> . 함수가하는 일을 간략히 정리해도 괜찮습니다.하지만 주석의 초점은 어떻게
                        수행되는지에 초점을 맞추어야합니다.</p>
                </div>

                <h3 id="title9-5">변수 설명</h3>
                <div class="content">
                    <p>일반적으로 변수의 실제 이름은 변수를 사용하는 데 대한 좋은 아이디어를 제공하기에 충분해야합니다. 어떤 경우에는 더 많은 의견이 필요합니다.</p>
                    <h4>클래스 데이터 멤버</h4>
                    <p>각 클래스 데이터 멤버 (인스턴스 변수 또는 멤버 변수라고도 함)의 목적은 명확해야합니다. 유형과 이름으로 명확하게 표현되지 않은 불변 값 (특수 값, 구성원 간 관계, 수명
                        요구 사항)이있는 경우 주석을 달아야합니다. 그러나 형식과 이름이 충분하면 ( <code>int num_events_;</code>), 주석이 필요하지 않습니다.</p>
                    <p>특히 nullptr 또는 -1과 같은 센티널 값의 존재와 의미를 설명하기 위해 주석을 추가하십시오. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;</code></pre>
                    </div>
                    <h4>전역 변수</h4>
                    <p>모든 전역 변수는 자신이 무엇인지, 무엇을 사용했는지, 그리고 왜 불명확 한지를 글로벌 변수로 설명해야한다는 설명이 있어야합니다. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;</code></pre>
                    </div>
                </div>

                <h3 id="title9-6">구현 코멘트</h3>
                <div class="content">
                    <p>구현시 코드의 까다 롭지 않은 부분, 흥미 있거나 중요한 부분에 주석을 포함해야합니다.</p>
                    <h4>설명문</h4>
                    <p>까다 롭거나 복잡한 코드 블록 앞에는 주석이
                        있어야합니다. 예:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Divides result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i < result->size(); i++) {
  x = (x << 8) + (*result)[i];
  (*result)[i] = x >> 1;
  x &= 1;
}
</code></pre>
                    </div>
                    <h4>회선 설명</h4>
                    <p>또한 명확하지 않은 행은 행의 끝에 주석을 가져야합니다. 이러한 줄 끝의 주석은 코드와 2 칸 씩 구분해야합니다. 예:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_->length());
if (mmap_budget >= data_size_ && !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.</code></pre>
                    </div>
                    <p>코드가 수행하는 작업을 설명하는 주석과 함수가 반환 될 때 이미 오류가 기록되었다는 주석이 있습니다.</p>
                    <p>후속 줄에 대해 여러 의견이 있으면 그 줄을 쉽게 읽을 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    "First item",
                    // .. and should be aligned appropriately.
                    "Second item"};
DoSomething(); /* For trailing block comments, one space is fine. */</code></pre>
                    </div>
                    <h4>함수 인수 주석</h4>
                    <p>함수 인수의 의미가 명확하지 않으면 다음 해결 방안 중 하나를 고려하십시오.</p>
                    <ul class="list-unstyled">
                        <li>인수가 리터럴 상수이고 동일한 상수가 암묵적으로 동일하다고 가정하는 방식으로 여러 함수 호출에서 사용되는 경우 명명 된 상수를 사용하여 해당 제약 조건을 명시 적으로
                            지정하고이를 유지하도록해야합니다.
                        </li>
                        <li><code>bool</code>인수를 인수 로 바꾸려면 함수 특성을 변경하십시오 <code>enum</code>. 이렇게하면 인수 값이 자체 설명됩니다.</li>
                        <li>여러 구성 옵션을 가진 함수의 경우, 모든 옵션을 보유 할 단일 클래스 또는 구조체를 정의한 후 해당 인스턴스를 전달하는 것이 좋습니다. 이 접근법은 몇 가지 장점이
                            있습니다. 옵션은 콜 사이트에서 이름의 의미를 명확히하는 이름으로 참조됩니다. 함수의 인수를 줄이기 때문에 함수 호출을 읽고 쓰는 것이 더 쉬워집니다.
                            추가 혜택으로 다른 옵션을 추가 할 때 전화 사이트를 변경할 필요가 없습니다.
                        </li>
                        <li>크거나 복잡한 중첩 식을 명명 된 변수로 바꿉니다.</li>
                        <li>최후의 수단으로 콜 사이트에서 논증의 의미를 명확히하기 위해 주석을 사용하십시오.</li>
                    </ul>
                    <p>다음 예제를 고려하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);</code></pre>
                    </div>
                    <p>대:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);</code></pre>
                    </div>
                    <h4>하지 말아야 할 것</h4>
                    <p>명백한 것을 말하지 마십시오. 특히, C ++을 잘 이해하는 독자에게는 그 행동이 모호하지 않는 한, 코드가하는 일을 문자 그대로 기술하지 마십시오. 대신,
                        코드가하는 일을하는 <i>이유</i> 를 설명하는 상위 수준의 주석을 제공 하거나 코드 자체를 설명하도록하십시오.</p>
                    <p>이것을 비교하십시오 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Find the element in the vector.  <-- Bad: obvious!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}</code></pre>
                    </div>
                    <p>이에:</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}</code></pre>
                    </div>
                    <p>자체 설명 코드에는 주석이 필요하지 않습니다. 위 예제의 주석은 분명합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (!IsAlreadyProcessed(element)) {
  Process(element);
}</code></pre>
                    </div>
                </div>
                <h3 id="title9-7">구두점, 철자법 및 문법</h3>
                <div class="content">
                    <p>구두점, 철자 및 문법에주의하십시오. 심하게 쓰여진 설명보다는 잘 쓰여진 설명을 읽는 것이 더 쉽습니다.</p>
                    <p>주석은 적절한 대문자와 구두법을 사용하여 서술 텍스트처럼 읽을 수 있어야합니다. 대부분의 경우, 완전한 문장은 문장 단편보다 읽기 쉽습니다.
                        코드 줄 끝의 주석과 같은 더 짧은 주석은 때로는 덜 형식적 일 수 있지만 사용자 스타일과 일치해야합니다.</p>
                    <p>세미콜론을 사용할 때 코드 검토자가 쉼표를 사용한다는 점을 지적하는 것은 좌절 할 수 있지만 소스 코드가 높은 수준의 명확성과 가독성을 유지하는 것이 매우 중요합니다.
                        적절한 구두점, 철자 및 문법이 그 목표에 도움이됩니다.</p>
                </div>

                <h3 id="title9-8">TODO 댓글</h3>
                <div class="content">
                    <p><code>TODO</code>일시적인 코드, 단기적인 솔루션 또는 충분하지만 좋지만 완벽하지는 않은 코드에 주석을 사용하십시오 .</p>
                    <p><code>TODO</code><code>TODO</code>모든 대문자 로 된 문자열 을 포함해야 하며 이름, 전자 메일 주소, 버그 ID 또는 사람의 다른 식별자가
                        포함되어야합니다
                        <code>TODO</code>. 주된 목적은 <code>TODO</code>요청에 따라 세부 정보를 얻는 방법을 찾기 위해 검색 할 수 있는 일관성 을 유지 하는
                        것입니다. A
                        <code>TODO</code>는 참조 된 사람이 문제를 해결할 것이라는 약속이 아닙니다. 따라서 <code>TODO</code>이름 을 사용하여 a를 만들면 거의 항상
                        주어진
                        이름이됩니다.</p>
                    <div>
                        <div class="code-box-copy">
                            <pre><code class="language-js">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature</code></pre>
                        </div>
                    </div>
                    <p><code>TODO</code>"미래의 일을 수행 할 때"라는 양식을 사용하는 경우 특정 날짜 ( "2005 년 11 월 수정") 또는 매우 구체적인 이벤트
                        ( "모든 클라이언트가 XML 응답을 처리 할 수있을 때이 코드 제거. ").</p>
                </div>

                <h3 id="title9-9">지원 중단 의견</h3>
                <div class="content">
                    <p>사용되지 않는 인터페이스 지점을 <code>DEPRECATED</code>주석으로 표시하십시오.</p>
                    <p><code>DEPRECATED</code>모든 대문자로 된 단어 를 포함하는 주석을 작성하여 인터페이스를 사용 중지 된 것으로 표시 할 수 있습니다 . 주석은 인터페이스의
                        선언 이전이나 선언과 같은 행에 있습니다.</p>
                    <p>단어 뒤에는<code>DEPRECATED</code>이름, 전자 메일 주소 또는 기타 식별자를 괄호 안에 기입하십시오.</p>
                    <p>비추천 의견에는 사람들이 부름을 해결할 수있는 간단하고 명확한 지침이 포함되어야합니다. C ++에서, 새로운 인터페이스 포인트를 호출하는 인라인 함수로서 비추천 함수를 구현할
                        수 있습니다.</p>
                    <p>인터페이스 포인트 <code>DEPRECATED</code>를 표시해도 마술로 인한 callites가 변경되지는 않습니다. 사람들이 실제로 더 이상 사용되지 않는 시설을
                        사용하지 못하도록하려면 콜 사이트를 직접 고치거나 승무원을 고용하여 도움을 받아야합니다.</p>
                    <p>새 코드에는 사용되지 않는 인터페이스 지점에 대한 호출이 없어야합니다. 새로운 인터페이스 지점을 대신 사용하십시오. 길 찾기를 이해할 수없는 경우, 사용 중단을 만든 사람을
                        찾아 새 인터페이스 지점을 사용하여 도움을 요청하십시오.</p>
                </div>
            </div>

            <h2 id="title10">서식 지정</h2>
            <div class="content">
                <p>코딩 스타일과 형식은 꽤 임의적이지만 모든 사람이 같은 스타일을 사용하면 프로젝트를 따르는 것이 훨씬 쉽습니다. 개인은 서식 규칙의 모든 측면에 동의하지 않을 수
                    있으며 규칙 중 일부는 익숙해 져야 할 수도 있지만 모든 프로젝트 참여자가 모든 사람의 코드를 읽고 이해할 수 있도록 스타일 규칙을 준수하는 것이 중요합니다.</p>
                <p>코드를 올바르게 포맷 할 수 있도록 <a
                        href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">
                    emacs 용 설정 파일을</a> 만들었습니다.</p>

                <h3 id="title10-1">선 길이</h3>
                <div class="content">
                    <p>코드의 각 텍스트 줄은 최대 80 자 여야합니다.</p>
                    <p>우리는이 규칙이 논란의 여지가 있음을 인정하지만 기존의 많은 코드가 이미이를 준수하고 있으며 일관성이 중요하다고 생각합니다.</p>
                    <p>이 규칙에 찬성하는 사람들은 창문의 크기를 조정하도록 강요하는 것이 무례하고 더 이상 아무것도 할 필요가 없다고 주장합니다.
                        어떤 사람들은 여러 개의 코드 윈도우를 나란히 배치하는 데 익숙하므로 어떤 경우에도 윈도우를 넓힐 여지가 없습니다.
                        사람들은 특정 최대 창 너비를 가정하여 작업 환경을 설정하고 80 열은 전통적인 표준이었습니다. 왜 그것을 바꿀까요?</p>
                    <p>변화를지지하는 사람들은 더 넓은 라인이 코드를 더 읽기 쉽게 만들 수 있다고 주장합니다. 80 칼럼 한도는 1960 년대 메인 프레임에 대한 은밀한 반감입니다. 현대 장비에는
                        넓은
                        화면이있어 더 긴 선을 쉽게 나타낼 수 있습니다.</p>
                    <p> 최대 80 자입니다.</p>
                    <p>줄이 80자를 초과 할 수 있습니다.</p>
                    <ul class="list-unstyled">
                        <li>가독성을 해치지 않으면 서 분할 할 수없는 주석 행, 잘라 내기 및 붙여 넣기 또는 자동 링크 용이성
                            - 예 : 한 줄에 80자를 넘는 예제 명령이나 리터럴 URL이 포함 된 경우.
                        </li>
                        <li>80자를 초과하는 내용을 가진 원시 문자열 리터럴. 테스트 코드를 제외하고는 파일의 맨 위에 이러한 리터럴이 표시되어야합니다.</li>
                        <li>include 문.</li>
                        <li><a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">헤더 가드</a></li>
                        <li>사용 신고</li>
                    </ul>
                </div>

                <h3 id="title10-2">비 ASCII 문자</h3>
                <div class="content">
                    <p>비 ASCII 문자는 희귀해야하며 UTF-8 형식을 사용해야합니다.</p>
                    <p>영어로 된 사용자 지향 텍스트를 소스 코드로 하드 ​​코딩하면 안되므로 비 ASCII 문자를 사용하는 경우는 거의 없습니다. 그러나 특정 경우에 이러한 단어를 코드에
                        포함시키는 것이
                        적절합니다. 예를 들어, 코드가 외부 소스의 데이터 파일을 구문 분석하는 경우 해당 데이터 파일에 사용 된 비 ASCII 문자열을 구분 기호로 하드 코드하는 것이 적절할 수
                        있습니다.
                        일반적으로 unittest 코드 (지역화 할 필요가없는)는 ASCII가 아닌 문자열을 포함 할 수 있습니다. 이 경우 UTF-8을 사용해야합니다. 그 이유는 ASCII
                        이상을 처리
                        할
                        수있는 대부분의 도구에서 이해할 수있는 인코딩이기 때문입니다.</p>
                    <p>16 진수 인코딩도 OK이며 가독성을 향상시키는 곳에서 권장됩니다. 예를 들어,<code>"\xEF\xBB\xBF"</code>또는 더
                        간단하게<code>u8"\uFEFF"</code>유니
                        코드 제로 폭의 no-break 공백 문자가 있습니다. 소스에 직선 UTF-8로 포함되어 있으면 보이지 않습니다. .</p>
                    <p><code>u8</code>접두사를 사용하여 <code>\uXXXX</code>이스케이프 시퀀스가 포함 된 문자열 리터럴이 UTF-8로 인코딩 되도록 보장합니다 . 컴파일러가
                        소스
                        파일을
                        UTF-8로 해석하지 않으면 잘못된 출력을 생성하기 때문에 UTF-8로 인코딩 된 비 ASCII 문자가 포함 된 문자열에는이 파일을 사용하지 마십시오.</p>
                    <p>C ++ 11 <code>char16_t</code>및<code>char32_t</code>문자 유형은 UTF-8이 아닌 텍스트 용이므로 사용하면 안됩니다 . 유사한 이유로
                        <code>wchar_t</code>Windows
                        API와 상호 작용하는 코드를 작성하지 않는 한 사용 하지 않아야합니다 <code>wchar_t</code>. 광범위하게 사용되는 Windows API와 상호 작용합니다 .
                    </p>
                </div>

                <h3 id="title10-3">공백 대 탭</h3>
                <div class="content">
                    <p>공백 만 사용하고 한 번에 2 칸 정도 들여 쓰기하십시오.</p>
                    <p>들여 쓰기에는 공백을 사용합니다. 코드에서 탭을 사용하지 마십시오. 탭 키를 누를 때 공백을 방출하도록 편집기를 설정해야합니다.</p>
                </div>

                <h3 id="title10-4">기능 선언 및 정의</h3>
                <div class="content">
                    <p>함수 이름과 같은 줄에있는 반환 유형, 일치하는
                        경우 동일한 줄에있는 매개 변수. <a
                                href="https://google.github.io/styleguide/cppguide.html#Function_Calls">함수 호출</a> 에서 인수를
                        감쌀
                        때처럼 한 줄에 들어 가지 않는
                        매개 변수 목록을 감싸십시오
                        .</p>

                    <p>함수는 다음과 같습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</code></pre>
                    </div>
                    <p>텍스트가 너무 많아 한 줄에 표시 할 수없는 경우 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}</code></pre>
                    </div>
                    <p>또는 첫 번째 매개 변수에도 적합하지 않은 경우</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</code></pre>
                    </div>
                    <p>주목해야 할 점이 몇 가지 있습니다.</p>
                    <ul class="list-unstyled">
                        <li>좋은 매개 변수 이름을 선택하십시오.</li>
                        <li>매개 변수 이름은 함수 정의에 매개 변수가 사용되지 않은 경우에만 생략 할 수 있습니다.</li>
                        <li>반환 형식과 함수 이름을 한 줄에 맞지 않으면 두 줄 사이를 구분하십시오.</li>
                        <li>반환 형식의 함수 선언이나 정의를 어기면 들여 쓰지 마십시오.</li>
                        <li>여는 괄호는 항상 함수 이름과 같은 줄에 있습니다.</li>
                        <li>함수 이름과 여는 괄호 사이에는 공백이 없습니다.</li>
                        <li>괄호와 매개 변수 사이에는 공백이 없습니다.</li>
                        <li>열린 중괄호는 항상 다음 줄의 시작이 아니라 함수 선언의 마지막 줄 끝에 있습니다.</li>
                        <li>닫는 중괄호는 마지막 줄에 단독으로 또는 중괄호와 같은 줄에 있습니다.</li>
                        <li>닫는 괄호와 열린 중괄호 사이에는 공백이 있어야합니다.</li>
                        <li>가능한 경우 모든 매개 변수가 정렬되어야합니다.</li>
                        <li>기본 들여 쓰기는 2 칸입니다.</li>
                        <li>래핑 된 매개 변수에는 4 개의 들여 쓰기가 있습니다.</li>
                    </ul>
                    <p>문맥으로부터 명백한 사용되지 않는 매개 변수는 생략 될 수 있습니다 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class Foo {
 public:
  Foo(Foo&&);
  Foo(const Foo&);
  Foo& operator=(Foo&&);
  Foo& operator=(const Foo&);
};</code></pre>
                    </div>
                    <p>명백하지 않은 사용되지 않는 매개 변수는 함수 정의에서 변수 이름을 주석 처리해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}</code></pre>
                    </div>
                    <p>특성으로 확장되는 특성 및 매크로는 반환 형식
                        앞에 함수 선언 또는 정의의 맨 처음에 나타납니다.</p>
                    <pre>MUST_USE_RESULT bool IsOK ();
</pre>
                </div>

                <h3 id="title10-5">람다 식</h3>
                <div class="content">
                    <p>다른 모든 함수와 마찬가지로 매개 변수와 본문을
                        형식화하고 쉼표로 구분 된 다른 목록과 같은 목록을 캡처합니다.</p>
                    <p>참조에 의한 캡처의 경우, 앰퍼샌드 (&amp;)와
                        변수 이름 사이에 공백을 두지 마십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int x = 0;
auto x_plus_n = [&x](int n) -> int { return x + n; }</code></pre>
                    </div>
                    <p>짧은 lambdas는 함수 인수로 인라인으로 작성 될 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());</code></pre>
                    </div>
                </div>

                <h3 id="title10-6">함수 호출</h3>
                <div class="content">
                    <p>호출을 모두 한 줄로 작성하거나 괄호에 인수를 감싸거나 4 줄의 들여 쓰기로 새 줄에 인수를 시작하고 4 줄의 들여 쓰기를 계속하십시오. 다른 고려
                        사항이없는 경우, 적절한 경우 각 행에 여러 인수를 넣는 것을 포함하여 최소 수의 행을 사용하십시오.</p>
                    <p>함수 호출 형식은 다음과 같습니다.</p>
                    <div class="code-box-copy">
                        <pre><code
                                class="language-js">bool result = DoSomething(argument1, argument2, argument3);</code></pre>
                    </div>
                    <p>인수가 모두 한 행에 들어 가지 않는 경우 인수는
                        여러 행으로 나눠야하며 각 행은 첫 번째 인수와 정렬됩니다. 열려있는 괄호 뒤에 또는 닫는 괄호 앞에
                        공백을 추가하지 마십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);</code></pre>
                    </div>
                    <p>인수는 선택적으로 모두 공백으로 4 개의 들여 쓰기로 후속 행에 배치 할 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</code></pre>
                    </div>
                    <p>특정 가독성 문제가없는 한 함수를 호출하는 데 필요한 행 수를 줄이기 위해 여러 인수를 단일 행에 두십시오. 일부에서는 각 행에 하나의 인수만으로
                        형식을 지정하는 것이 더 읽기 쉽고 인수를 쉽게 편집 할 수 있다는 것을 알게되었습니다. 그러나 우리는
                        인자를 쉽게 편집 할 수 있도록 독자의 우선 순위를 정하고 대부분의 가독성 문제는 다음과 같은 기술로 해결할 수 있습니다.</p>
                    <p>한 줄에 여러 개의 인수가있는 경우 일부 인수를 구성하는 식의 복잡성 또는 혼동으로 인해 가독성이 떨어지면 해당 인수를 설명하는 이름으로 캡처하는 변수를
                        만들어보십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);</code></pre>
                    </div>
                    <p>또는 혼란스러운 주장을 설명하는 주석과 함께 자신의 줄에 넣으십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);</code></pre>
                    </div>
                    <p>하나의 인수가 자체 행에서 훨씬 더 읽기 쉬운 경우가 여전히있는 경우에는 자체 행에 입력하십시오. 결정은 일반적인 정책보다는 읽기 쉽도록 만든 논증에
                        따라 결정되어야합니다.</p>
                    <p>때때로 인수는 가독성을 위해 중요한 구조를 형성합니다. 이 경우 해당 구조에 따라 인수를 형식화하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</code></pre>
                    </div>
                </div>

                <h3 id="title10-7">브레이스 드 이니셜 라이저 목록 형식</h3>
                <div class="content">
                    <p>형식 <a
                            href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List">보강 초기화
                        목록을</a>
                        당신이 그 자리에 함수 호출을 포맷하는 것과 같이.</p>
                    <p><code>{}</code>괄호 목록이 이름 (예 : 유형 또는 변수 이름) 다음 에 오는 경우 해당 이름을 가진 함수 호출의 괄호 처럼 형식 을 지정합니다. 이름이 없으면
                        길이가 0 인 이름을 사용하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};</code></pre>
                    </div>
                </div>

                <h3 id="title10-8">조건부</h3>
                <div class="content">
                    <p>괄호 안에 공백을 넣지 마십시오. <code>if</code> 및 <code>else</code>키워드는 별도의 줄에 속한다.</p>
                    <p>기본 조건문에는 두 가지 형식이 허용됩니다. 하나는 괄호와 조건 사이에 공백을 포함하고 하나는 포함하지 않습니다.</p>
                    <p>가장 일반적인 형태는 공백이 없습니다. 어느 쪽이든 좋지만 일관성을 유지하십시오. 파일을 수정하는 경우 이미있는 형식을 사용하십시오. 새 코드를 작성하는 경우 해당 디렉토리
                        또는 프로젝트의 다른 파일 형식을 사용하십시오. 의심스럽고 개인적인 취향이없는 경우에는 공백을 추가하지 마십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (condition) {  // no spaces inside parentheses
  ...  // 2 space indent.
} else if (...) {  // The else goes on the same line as the closing brace.
  ...
} else {
  ...
}</code></pre>
                    </div>
                    <p>원하는 경우 괄호 안에 공백을 추가 할 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if ( condition ) {  // spaces inside parentheses - rare
  ...  // 2 space indent.
} else {  // The else goes on the same line as the closing brace.
  ...
}</code></pre>
                    </div>
                    <p>모든 경우에 <code>if</code>괄호와 여는 괄호 사이에 공백이 있어야합니다 . 닫는 괄호와 중괄호 사이에 공백이
                        있어야합니다 (사용중인 경우).</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if(condition) {   // Bad - space missing after IF.
if (condition){   // Bad - space missing before {.
if(condition){    // Doubly bad.
</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code
                                class="language-js">if (condition) {  // Good - proper space after IF and before {.</code></pre>
                    </div>
                    <p>가독성을 높이려면 짧은 조건문을 한 줄에 써도됩니다. 행이 짧고 명령문이 <code>else</code>절을 사용하지 않을 때만 사용할 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();</code></pre>
                    </div>
                    <p>if 문에 다음이있는 경우에는 허용되지 않습니다 <code>else</code>.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Not allowed - IF statement on one line when there is an ELSE clause
if (x) DoThis();
else DoThat();</code></pre>
                    </div>
                    <p>일반적으로 중괄호는 단일 행 문에는 필요하지 않지만 원하는 경우에는 허용됩니다. 복잡한 조건이나 명령문이있는 조건문 또는 루프 문은 중괄호로 쉽게
                        읽을 수 있습니다. 일부 프로젝트는 <code>if</code>반드시 반드시 동행 한 중괄호가 있어야 한다고 요구합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (condition)
  DoSomething();  // 2 space indent.

if (condition) {
  DoSomething();  // 2 space indent.
}</code></pre>
                    </div>
                    <p>그러나 <code>if</code>- <code>else</code>문장 의 한 부분이 중괄호를 사용하는 경우 나머지 부분도 다음과 같이 사용해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Not allowed - curly on IF but not ELSE
if (condition) {
  foo;
} else
  bar;

// Not allowed - curly on ELSE but not IF
if (condition)
  foo;
else {
  bar;
}</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Curly braces around both IF and ELSE required because
// one of the clauses used braces.
if (condition) {
  foo;
} else {
  bar;
}</code></pre>
                    </div>
                </div>

                <h3 id="title10-9">루프 및 스위치 문</h3>
                <div class="content">
                    <p>switch 문은 블록에 중괄호를 사용할 수
                        있습니다. 사례 사이의 중요한 사안에 주석을 달아 라. 중괄호는 단일 명령문 루프의 경우 선택적입니다. 빈 루프 몸체는 빈 괄호 또는를 사용해야합니다
                        <code>continue</code>.</p>
                    <p><code>case</code><code>switch</code>
                        명령문의 블록은 사용자의 선호도에 따라 중괄호를 가질 수도 있고 그렇지 않을 수도 있습니다. 중괄호를 포함하는 경우 아래에 표시된 것과 같이 배치해야합니다.</p>
                    <p>열거 된 값에 조건이 없으면 switch 문에는 항상 <code>default</code>대소 문자 가 있어야합니다 (열거 형 값의 경우 컴파일러에서 값을 처리하지 않으면
                        경고합니다). 기본 케이스를 절대로 실행해서는 안되는 경우 오류로 처리하십시오. 예 :</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">switch (var) {
  case 0: {  // 2 space indent
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}</code></pre>
                    </div>
                    <p>하나의 사례 레이블에서 다른 사례 레이블로
                        넘어가는 <code>ABSL_FALLTHROUGH_INTENDED;</code>(정의 된 <code>absl/base/macros.h</code>) 매크로를

                        사용하여 주석을 달아야합니다
                        .
                        <code>ABSL_FALLTHROUGH_INTENDED;</code>다음 사례 레이블로 넘어가는 실행 지점에 배치되어야합니다. 일반적인 예외는 코드가 삽입되지 않은
                        연속적인 사례
                        레이블이며, 주석이 필요하지 않습니다.
                    </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">switch (x) {
  case 41:  // No annotation needed here.
  case 43:
    if (dont_be_picky) {
      // Use this instead of or along with annotations in comments.
      ABSL_FALLTHROUGH_INTENDED;
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    ABSL_FALLTHROUGH_INTENDED;
  default:
    DoSomethingGeneric();
    break;
}</code></pre>
                    </div>
                    <p> 중괄호는 단일 명령문 루프의 경우 선택적입니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">for (int i = 0; i < kSomeNumber; ++i)
  printf("I love you\n");

for (int i = 0; i < kSomeNumber; ++i) {
  printf("I take it back\n");
}</code></pre>
                    </div>
                    <p>빈 루프 바디는 <code>continue</code>하나의 세미콜론이 아닌 빈 중괄호 또는 중괄호를 사용해야합니다 .</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">while (condition) {
  // Repeat test until it returns false.
}
for (int i = 0; i < kSomeNumber; ++i) {}  // Good - one newline is also OK.
while (condition) continue;  // Good - continue indicates no logic.</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code
                                class="language-js">while (condition);  // Bad - looks like part of do/while loop.</code></pre>
                    </div>
                </div>

                <h3 id="title10-10">포인터 및 참조 식</h3>
                <div class="content">
                    <p>마침표 또는 화살표 주위에 공백이 없어야합니다. 포인터 연산자 뒤에 공백이 없습니다.</p>
                    <p>올바른 형식의 포인터 및 참조 식의 예는 다음과 같습니다.</p>
                    <pre>x = * p;
p = &amp; x;
x = ry;
x = r-&gt; y;
</pre>
                    <p>참고 사항 :</p>
                    <ul class="list-unstyled">
                        <li>멤버에 액세스 할 때 마침표 나 화살표 주위에는 공백이 없습니다.</li>
                        <li>포인터 연산자는 <code>*</code>또는 뒤에 공백이 없습니다<code>&amp;</code>.</li>
                    </ul>
                    <p>포인터 변수 또는 인수를 선언 할 때 별표를 유형 또는 변수 이름에 인접하게 배치 할 수 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// These are fine, space preceding.
char *c;
const string &amp;str;

// These are fine, space following.
char* c;
const string& str;</code></pre>
                    </div>

                    <p>이 작업은 단일 파일 내에서 일관되게 수행해야하므로 기존 파일을 수정할 때 해당 파일의 스타일을 사용하십시오.</p>
                    <p>특이한 경우 동일한 선언에서 여러 변수를 선언 할 수는 있지만 포인터 또는 참조 데코레이션이있는 변수가 있으면 허용되지 않습니다. 그러한 선언은 쉽게 오판됩니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Fine if helpful for readability.
int x, y;
</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int x, *y;  // Disallowed - no & or * in multiple declaration
char * c;  // Bad - spaces on both sides of *
const string & str;  // Bad - spaces on both sides of &</code></pre>
                    </div>
                </div>

                <h3 id="title10-11">부울 표현식</h3>
                <div class="content">
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Line_Length">표준 행 길이</a> 보다 긴 부울 표현식을
                        사용
                        하는 경우 행 분리 방법을 일관되게 유지하십시오.</p>
                    <p>이 예제에서 논리적 AND 연산자는 항상 행의 끝에 있습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
  ...
}
</code></pre>
                    </div>
                    <p>이 예제에서 코드가 줄 바꿈 될 때 두 <code>&amp;&amp;</code>논리 AND 연산자는 줄 끝 부분에 있습니다. 이는 Google 코드에서 더 일반적입니다.
                        단, 줄의
                        시작 부분에 모든 연산자를 배치하는 것도 허용됩니다. 여분의 괄호는 적절하게 사용하면 가독성을 높이는 데 매우 유용 할 수 있으므로주의하여 추가 괄호를 자유롭게
                        삽입하십시오. 또한
                        당신은 항상 같은 문장 부호 연산자를 사용한다는 것을 유의<code>&amp;&amp;</code>하고 <code>~</code>오히려 같은 단어 연산자보다,
                        <code>and</code>하고<code>compl</code>.</p>
                </div>

                <h3 id="title10-12">반환 값</h3>
                <div class="content">
                    <p>불필요하게 <code>return</code> 표현식을 괄호로 묶지 마십시오 .</p>

                    <p>괄호를 <code>return expr;</code>사용할 위치에서만 괄호를 사용하십시오 <code>x = expr;</code>.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &&
        another_condition);</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!</code></pre>
                    </div>
                </div>

                <h3 id="title10-13">변수 및 배열 초기화</h3>
                <div class="content">
                    <p>당신의 선택 <code>=</code>, <code>()</code>또는<code>{}</code>.</p>
                    <p>사이 <code>=</code>에서 선택할 수 있습니다 <code>()</code>,, 및 <code>{}</code>; 다음은 모두 정확합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int x = 3;
int x(3);
int x{3};
string name = "Some Name";
string name("Some Name");
string name{"Some Name"};</code></pre>
                    </div>
                    <p>생성자가 <code>{...}</code>
                        있는 유형에서 중괄호로 묶은 초기화 목록 을 사용할
                        때는주의하십시오 <code>std::initializer_list</code>. 비어 있지
                        않은 <i>braced-init-list</i> 는 <code>std::initializer_list</code>가능할 때마다 생성자를 선호
                        합니다. 빈
                        괄호 <code>{}</code>는 특별하며 사용 가능한 경우 기본 생성자를 호출합니다. <code>std::initializer_list</code>생성자 가 아닌 생성자
                        를
                        강제하려면 괄호 대신 괄호를
                        사용하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">std::vector&lt;int&gt; v(100, 1);  // A vector containing 100 items: All 1s.
std::vector&lt;int&gt; v{100, 1};  // A vector containing 2 items: 100 and 1.</code></pre>
                    </div>
                    <p>또한 중괄호 형식은 전체 유형의 축소를 방지합니다. 이렇게하면 일부 유형의 프로그래밍 오류를 방지 할 수 있습니다. </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</code></pre>
                    </div>
                </div>

                <h3 id="title10-14">전 처리기 지시문</h3>
                <div class="content">
                    <p>선행 처리기 지시문을 시작하는 해시 표시는 항상 줄의 시작 부분에 있어야합니다.</p>
                    <p>선행 처리기 지시문이 들여 쓰기 된 코드 본문 내에 있더라도 지시문은 줄 시작 부분에서 시작해야합니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }</code></pre>
                    </div>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }</code></pre>
                    </div>
                </div>

                <h3 id="title10-15">클래스 형식</h3>
                <div class="content">
                    <p>섹션 <code>public</code>, <code>protected</code>및 <code>private</code>순서는 각각 하나 개의 공간을 들여 쓰기.</p>
                    <p>클래스 정의의 기본 형식 ( 주석이 없으면 필요한 <a
                            href="https://google.github.io/styleguide/cppguide.html#Class_Comments">주석</a> 에 대한 설명 은 <a
                            href="https://google.github.io/styleguide/cppguide.html#Class_Comments">클래스 주석</a>을 참조하십시오
                        )은
                        다음과 같습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};</code></pre>
                    </div>
                    <p>주의 사항 :</p>
                    <ul class="list-unstyled">
                        <li>모든 기본 클래스 이름은 서브 클래스 이름과 동일한 행에 있어야하며 80 열 한계가 있어야합니다.</li>
                        <li><code>public:</code>, <code>protected:</code>및 <code>private:</code>키워드는 한 칸 들여 쓰기를해야한다.
                        </li>
                        <li>첫 번째 인스턴스를 제외하고 이러한 키워드 앞에는 빈 줄이 와야합니다. 이 규칙은 소규모 클래스에서는 선택 사항입니다.</li>
                        <li>이 키워드 다음에 빈 줄을 남기지 마십시오.</li>
                        <li><code>public</code>부분은이어서 제되어야 <code>protected</code>하고 마지막<code>private</code>부분.</li>
                        <li>각 섹션에서 주문 선언에 대한 규칙 은 <a
                                href="https://google.github.io/styleguide/cppguide.html#Declaration_Order">선언 순서</a>를
                            참조하십시오
                            .
                        </li>
                    </ul>
                </div>

                <h3 id="title10-16">생성자 이니셜 라이저 목록</h3>
                <div class="content">
                    <p>생성자 이니셜 라이저 목록은 모두 한 행에 있거나 4 행으로 들여 쓰기 된 후속 행이 될 수 있습니다.</p>
                    <p>이니셜 라이저 목록에 허용되는 형식은 다음과 같습니다.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}</code></pre>
                    </div>
                </div>

                <h3 id="title10-17">네임 스페이스 서식</h3>
                <div class="content">
                    <p>네임 스페이스의 내용은 들여 쓰여지지 않습니다.</p>
                    <p><a href="https://google.github.io/styleguide/cppguide.html#Namespaces">네임 스페이스</a> 는 추가 수준의 들여
                        쓰기를
                        추가하지 않습니다. 예를 들어 다음을 사용하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</code></pre>
                    </div>
                    <p>네임 스페이스 내에서 들여 쓰기 : </p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace {

  // Wrong!  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace</code></pre>
                    </div>
                    <p>중첩 네임 스페이스를 선언 할 때는 각 네임 스페이스를 고유 한 줄에 배치하십시오.</p>
                    <div class="code-box-copy">
                        <pre><code class="language-js">namespace foo {
namespace bar {</code></pre>
                    </div>
                </div>

                <h3 id="title10-18">가로 공백</h3>
                <div class="content">
                    <p>가로 공백 사용은 위치에 따라 다릅니다. 줄 끝 부분에 후행 공백을 두지 마십시오.</p>
                    <h4>일반</h4>
                    <div class="code-box-copy">
                        <pre><code class="language-js">void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...</code></pre>
                    </div>
                    <p>후행 공백을 추가하면 기존의 공백을 제거 할 수있는 것처럼 병합 할 때 동일한 파일을 편집하는 다른 사람들을 위해 추가 작업이 발생할 수 있습니다. 그래서 : 후행 공백을
                        삽입하지 마십시오. 해당 행을 이미 변경 한 경우 제거하거나 별도의 정리 작업 (다른 사람이 파일 작업을하지 않는 경우)에서 제거하십시오.</p>

                    <h4>루프 및 조건부</h4>
                    <div class="code-box-copy">
                        <pre><code class="language-js">if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i < 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i < 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i < 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</code></pre>
                    </div>
                    <h4>연산자</h4>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x && !y)
  ...</code></pre>
                    </div>
                    <h4>템플릿 및 캐스트</h4>
                    <div class="code-box-copy">
                        <pre><code class="language-js">// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
std::vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector&lt;char *&gt; x;</code></pre>
                    </div>
                </div>

                <h3 id="title10-19">세로 공백</h3>
                <div class="content">
                    <p>수직 공백의 사용을 최소화하십시오.</p>
                    <p>이는 규칙보다 원칙입니다 : 할 필요가 없을 때 빈 줄을 사용하지 마십시오. 특히, 함수 사이에 하나 또는 두 개의 공백 행을 두지 말고 공백 행을 사용하여 함수를 시작하지
                        말고 공백 행을 사용하여 함수를 끝내지 말고 공백 행을 사용하여 절약하십시오. 코드 블록 내의 빈 줄은 산문의 단락처럼 두 가지 생각을 시각적으로 구분합니다.</p>
                    <p>기본 원칙은 다음과 같습니다. 한 화면에 더 많은 코드가수록할수록 프로그램의 제어 흐름을 더 쉽게 이해하고 이해할 수 있습니다. 공백을 의도적으로 사용하여 해당 흐름을
                        분리하십시오.</p>
                    <p>빈 줄이 유용 할 때 도움이되는 몇 가지 경험 법칙 :</p>
                    <ul class="list-unstyled">
                        <li>함수의 처음이나 끝에있는 빈 줄은 가독성에 도움이되지 않습니다.</li>
                        <li>if-else 블록 체인 안의 빈 줄은 가독성을 높이는 데 도움이 될 수 있습니다.</li>
                        <li>주석 줄 앞의 빈 줄은 일반적으로 가독성을 높이는 데 도움이됩니다. 새 주석을 사용하면 새로운 생각이 시작되고 빈 줄을 사용하면 앞의 주석 대신 다음과 같은 내용이
                            사용됩니다.
                        </li>
                    </ul>
                </div>
            </div>

            <h2 id="title11">예외 규칙</h2>
            <div class="content">
                <p>위에서 설명한 코딩 규칙은 필수 사항입니다. 그러나 모든 좋은 규칙과 마찬가지로 때때로 이러한 예외가있을 수 있습니다. 여기서 논의합니다.</p>
                <h3>기존의 부적합 코드</h3>
                <div class="content">
                    <p>이 스타일 가이드를 따르지 않는 코드를 다룰 때 규칙에서 벗어날 수 있습니다.</p>
                    <p>이 가이드에서 제시하지 않은 사양으로 작성된 코드를 수정하는 경우 해당 코드의 현지 규칙을 준수하기 위해 이러한 규칙을 벗어나야 할 수 있습니다. 이 작업을 수행하는
                        방법에 대해 의심이가는 경우 원본 작성자 또는 현재 코드를 담당 한 사람에게 문의하십시오. 일관성 에는 지역 일관성도 포함 된다는 것을 기억하십시오 .</p>
                </div>

                <h3 id="title11-1">Windows 코드</h3>
                <div class="content">
                    <p>Windows 프로그래머는 Windows 헤더 및
                        다른 Microsoft 코드의 규칙을 기반으로하여 자체 코딩 규칙을 개발했습니다. 누구나 코드를 쉽게 이해할 수 있도록 모든 플랫폼에서 C ++을 작성하는 모든
                        사람들을위한 가이드
                        라인이 하나 있습니다.</p>
                    <p>널리 사용되는 Windows 스타일에 익숙하다면 잊어 버릴지도 모르는 몇 가지 지침을 반복해서 설명하는 것이 좋습니다.</p>
                    <ul class="list-unstyled">
                        <li>헝가리 표기법 (예 : 정수 이름 지정)을 사용하지 마십시오 <code>iNum</code>. <code>.cc</code>소스 파일 확장명을 포함하여
                            Google 명명
                            규칙을 사용하십시오 .
                        </li>
                        <li>윈도우와 같은 기본 유형에 대한 자신의 동의어의 많은 정의 <code>DWORD</code>,<code>HANDLE</code>등 그것은 Windows API
                            함수를 호출
                            할 때 이러한 유형을 사용하는 것이 완벽하게 허용하고 권장합니다. 그렇다고하더라도 기본 C ++ 유형에 가능한 한 가까이 있어야합니다. 예를 들어 <code>const
                                TCHAR *</code>대신 사용하십시오<code>LPCTSTR</code>.
                        </li>
                        <li>Microsoft Visual C ++로 컴파일 할 때 컴파일러를 경고 수준 3 이상으로 설정하고 모든 경고를 오류로 처리하십시오.</li>
                        <li>사용하지 마십시오 <code>#pragma once</code>. 대신 표준 Google 포함 경비원을 사용하십시오. 포함 가드의 경로는 프로젝트 트리의 맨
                            위에
                            상대적이어야합니다.
                        </li>
                        <li>사실 꼭 필요한 경우가 아니라면 <code>#pragma</code>and와 같은 비표준 확장을 사용하지 마십시오 <code>__declspec</code>.
                            사용<code>__declspec(dllimport)</code>및<code>__declspec(dllexport)</code>허용된다; 그러나 코드를
                            공유하는 사용자는
                            확장 프로그램을 쉽게 사용 중지 할 수 있도록 <code>DLLIMPORT</code>and와 같은 매크로를
                            사용해야합니다<code>DLLEXPORT</code>.
                        </li>
                    </ul>
                    <p>그러나 Windows에서 자주 중단해야하는 몇 가지 규칙이 있습니다.</p>
                    <ul class="list-unstyled">
                        <li>일반적으로 우리 <a
                                href="https://google.github.io/styleguide/cppguide.html#Multiple_Inheritance">는 다중
                            구현 상속의 사용을 금지합니다</a> . 그러나 COM 및 일부 ATL / WTL 클래스를 사용할 때 필요합니다. 여러 구현 상속을 사용하여 COM 또는
                            ATL / WTL
                            클래스 및 인터페이스를 구현할 수 있습니다.
                        </li>
                        <li>자신의 코드에서 예외를 사용하면 안되지만 Visual C ++와 함께 제공되는 예외를 포함하여 ATL 및 일부 STL에서 광범위하게 사용됩니다.
                            ATL <code>_ATL_NO_EXCEPTIONS</code>을 사용할 때 예외를 사용하지 않도록 정의해야합니다.
                            STL에서 예외를 비활성화 할 수 있는지 여부를 조사해야하지만 그렇지 않은 경우 컴파일러에서 예외를 설정하는 것이 좋습니다.
                            (이것은 STL을 컴파일하기위한 것일 뿐이므로 예외 처리 코드는 직접 작성하지 않아야합니다.)
                        </li>
                        <li>미리 컴파일 된 헤더로 작업하는 일반적인 방법은 헤더 파일을 각 소스 파일의 맨 위에 포함 <code>StdAfx.h</code>하거나 일반적으로 또는와 같은
                            이름으로
                            포함시키는 것 <code>precompile.h</code>입니다. 코드를 다른 프로젝트와 더 쉽게 공유하려면이 파일을 명시 적으로 포함하지 말고 (in을
                            제외하고
                            <code>precompile.cc</code>) <code>/FI</code>컴파일러 옵션을 사용 하여 파일을 자동으로 포함하십시오.
                        </li>
                        <li>일반적으로 이름이 지정 <code>resource.h</code>되고 매크로 만 포함 하는 리소스 헤더는 이러한 스타일 가이드 라인을 준수 할 필요가
                            없습니다.
                        </li>
                    </ul>
                </div>
            </div>

            <h2 id="title12">분리 단어</h2>
            <div class="content">
                <p>상식을 사용하고 일관성을 유지하십시오 .</p>
                <p>코드를 편집하는 경우 몇 분 정도 시간을내어 주변의 코드를보고 스타일을 결정하십시오. 그들이 그들의 <code>if</code>절 주위에 공백을 사용한다면 , 당신도
                    그렇게해야합니다. 그들의 의견에 주변에 별표 상자가 거의없는 경우 의견에 별표 상자가 너무 적도록하십시오.</p>
                <p>스타일 지침의 요점은 공통된 코딩 어휘를 사용하여 사람들이 어떻게 말하고있는 것보다 말하고있는 것에 집중할 수 있도록하는 것입니다.
                    사람들이 어휘를 알 수 있도록 여기에 글로벌 스타일 규칙을 제시합니다. 그러나 지역 스타일 또한 중요합니다.
                    파일에 추가하는 코드가 기존 코드와 크게 다르다면 불연속은 독자가 읽으 려 할 때 자신의 리듬에서 벗어납니다. 이것을 피하십시오.</p>
            </div>


            <!-- 최상단 이동 btn -->
            <div>
                    <span id="topBtn"> <i class="glyphicon glyphicon-menu-up"></i><span
                            class="sr-only">top</span></span>
            </div>

        </div>
        <!-- END container -->

    </main>
    <!-- END main -->

</div>
<!-- END wrap -->

<!-- Include script -->
<script>
    w3.includeHTML();
</script>
</body>
</html>